/* This file is automatically generated. Any changes made to it may be overwritten. */

using System;
using System.IO;
using System.Collections.Generic;

namespace MavLinkNet
{

    /// <summary>
    /// Micro air vehicle / autopilot classes. This identifies the individual model.
    /// </summary>
    public enum MavAutopilot { 

        /// <summary> Generic autopilot, full support for everything </summary>
        Generic = 0, 

        /// <summary> Reserved for future use. </summary>
        Reserved = 1, 

        /// <summary> SLUGS autopilot, http://slugsuav.soe.ucsc.edu </summary>
        Slugs = 2, 

        /// <summary> ArduPilotMega / ArduCopter, http://diydrones.com </summary>
        Ardupilotmega = 3, 

        /// <summary> OpenPilot, http://openpilot.org </summary>
        Openpilot = 4, 

        /// <summary> Generic autopilot only supporting simple waypoints </summary>
        GenericWaypointsOnly = 5, 

        /// <summary> Generic autopilot supporting waypoints and other simple navigation commands </summary>
        GenericWaypointsAndSimpleNavigationOnly = 6, 

        /// <summary> Generic autopilot supporting the full mission command set </summary>
        GenericMissionFull = 7, 

        /// <summary> No valid autopilot, e.g. a GCS or other MAVLink component </summary>
        Invalid = 8, 

        /// <summary> PPZ UAV - http://nongnu.org/paparazzi </summary>
        Ppz = 9, 

        /// <summary> UAV Dev Board </summary>
        Udb = 10, 

        /// <summary> FlexiPilot </summary>
        Fp = 11, 

        /// <summary> PX4 Autopilot - http://pixhawk.ethz.ch/px4/ </summary>
        Px4 = 12, 

        /// <summary> SMACCMPilot - http://smaccmpilot.org </summary>
        Smaccmpilot = 13, 

        /// <summary> AutoQuad -- http://autoquad.org </summary>
        Autoquad = 14, 

        /// <summary> Armazila -- http://armazila.com </summary>
        Armazila = 15, 

        /// <summary> Aerob -- http://aerob.ru </summary>
        Aerob = 16, 

        /// <summary> ASLUAV autopilot -- http://www.asl.ethz.ch </summary>
        Asluav = 17 };

    public enum MavType { 

        /// <summary> Generic micro air vehicle. </summary>
        Generic = 0, 

        /// <summary> Fixed wing aircraft. </summary>
        FixedWing = 1, 

        /// <summary> Quadrotor </summary>
        Quadrotor = 2, 

        /// <summary> Coaxial helicopter </summary>
        Coaxial = 3, 

        /// <summary> Normal helicopter with tail rotor. </summary>
        Helicopter = 4, 

        /// <summary> Ground installation </summary>
        AntennaTracker = 5, 

        /// <summary> Operator control unit / ground control station </summary>
        Gcs = 6, 

        /// <summary> Airship, controlled </summary>
        Airship = 7, 

        /// <summary> Free balloon, uncontrolled </summary>
        FreeBalloon = 8, 

        /// <summary> Rocket </summary>
        Rocket = 9, 

        /// <summary> Ground rover </summary>
        GroundRover = 10, 

        /// <summary> Surface vessel, boat, ship </summary>
        SurfaceBoat = 11, 

        /// <summary> Submarine </summary>
        Submarine = 12, 

        /// <summary> Hexarotor </summary>
        Hexarotor = 13, 

        /// <summary> Octorotor </summary>
        Octorotor = 14, 

        /// <summary> Octorotor </summary>
        Tricopter = 15, 

        /// <summary> Flapping wing </summary>
        FlappingWing = 16, 

        /// <summary> Flapping wing </summary>
        Kite = 17, 

        /// <summary> Onboard companion controller </summary>
        OnboardController = 18, 

        /// <summary> Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter. </summary>
        VtolDuorotor = 19, 

        /// <summary> Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter. </summary>
        VtolQuadrotor = 20, 

        /// <summary> Tiltrotor VTOL </summary>
        VtolTiltrotor = 21, 

        /// <summary> VTOL reserved 2 </summary>
        VtolReserved2 = 22, 

        /// <summary> VTOL reserved 3 </summary>
        VtolReserved3 = 23, 

        /// <summary> VTOL reserved 4 </summary>
        VtolReserved4 = 24, 

        /// <summary> VTOL reserved 5 </summary>
        VtolReserved5 = 25, 

        /// <summary> Onboard gimbal </summary>
        Gimbal = 26, 

        /// <summary> Onboard ADSB peripheral </summary>
        Adsb = 27 };

    /// <summary>
    /// These values define the type of firmware release.  These values indicate the first version or release of this type.  For example the first alpha release would be 64, the second would be 65.
    /// </summary>
    public enum FirmwareVersionType { 

        /// <summary> development release </summary>
        Dev = 0, 

        /// <summary> alpha release </summary>
        Alpha = 64, 

        /// <summary> beta release </summary>
        Beta = 128, 

        /// <summary> release candidate </summary>
        Rc = 192, 

        /// <summary> official stable release </summary>
        Official = 255 };

    /// <summary>
    /// These flags encode the MAV mode.
    /// </summary>
    public enum MavModeFlag { 

        /// <summary> 0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. </summary>
        SafetyArmed = 128, 

        /// <summary> 0b01000000 remote control input is enabled. </summary>
        ManualInputEnabled = 64, 

        /// <summary> 0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software is full operational. </summary>
        HilEnabled = 32, 

        /// <summary> 0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further control inputs to move around. </summary>
        StabilizeEnabled = 16, 

        /// <summary> 0b00001000 guided mode enabled, system flies MISSIONs / mission items. </summary>
        GuidedEnabled = 8, 

        /// <summary> 0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not, depends on the actual implementation. </summary>
        AutoEnabled = 4, 

        /// <summary> 0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should not be used for stable implementations. </summary>
        TestEnabled = 2, 

        /// <summary> 0b00000001 Reserved for future use. </summary>
        CustomModeEnabled = 1 };

    /// <summary>
    /// These values encode the bit positions of the decode position. These values can be used to read the value of a flag bit by combining the base_mode variable with AND with the flag position value. The result will be either 0 or 1, depending on if the flag is set or not.
    /// </summary>
    public enum MavModeFlagDecodePosition { 

        /// <summary> First bit:  10000000 </summary>
        Safety = 128, 

        /// <summary> Second bit: 01000000 </summary>
        Manual = 64, 

        /// <summary> Third bit:  00100000 </summary>
        Hil = 32, 

        /// <summary> Fourth bit: 00010000 </summary>
        Stabilize = 16, 

        /// <summary> Fifth bit:  00001000 </summary>
        Guided = 8, 

        /// <summary> Sixt bit:   00000100 </summary>
        Auto = 4, 

        /// <summary> Seventh bit: 00000010 </summary>
        Test = 2, 

        /// <summary> Eighth bit: 00000001 </summary>
        CustomMode = 1 };

    /// <summary>
    /// Override command, pauses current mission execution and moves immediately to a position
    /// </summary>
    public enum MavGoto { 

        /// <summary> Hold at the current position. </summary>
        DoHold = 0, 

        /// <summary> Continue with the next item in mission execution. </summary>
        DoContinue = 1, 

        /// <summary> Hold at the current position of the system </summary>
        HoldAtCurrentPosition = 2, 

        /// <summary> Hold at the position specified in the parameters of the DO_HOLD action </summary>
        HoldAtSpecifiedPosition = 3 };

    /// <summary>
    /// These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it                simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override.
    /// </summary>
    public enum MavMode { 

        /// <summary> System is not ready to fly, booting, calibrating, etc. No flag is set. </summary>
        Preflight = 0, 

        /// <summary> System is allowed to be active, under assisted RC control. </summary>
        StabilizeDisarmed = 80, 

        /// <summary> System is allowed to be active, under assisted RC control. </summary>
        StabilizeArmed = 208, 

        /// <summary> System is allowed to be active, under manual (RC) control, no stabilization </summary>
        ManualDisarmed = 64, 

        /// <summary> System is allowed to be active, under manual (RC) control, no stabilization </summary>
        ManualArmed = 192, 

        /// <summary> System is allowed to be active, under autonomous control, manual setpoint </summary>
        GuidedDisarmed = 88, 

        /// <summary> System is allowed to be active, under autonomous control, manual setpoint </summary>
        GuidedArmed = 216, 

        /// <summary> System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by MISSIONs) </summary>
        AutoDisarmed = 92, 

        /// <summary> System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by MISSIONs) </summary>
        AutoArmed = 220, 

        /// <summary> UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only. </summary>
        TestDisarmed = 66, 

        /// <summary> UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only. </summary>
        TestArmed = 194 };

    public enum MavState { 

        /// <summary> Uninitialized system, state is unknown. </summary>
        Uninit = 0, 

        /// <summary> System is booting up. </summary>
        Boot = 1, 

        /// <summary> System is calibrating and not flight-ready. </summary>
        Calibrating = 2, 

        /// <summary> System is grounded and on standby. It can be launched any time. </summary>
        Standby = 3, 

        /// <summary> System is active and might be already airborne. Motors are engaged. </summary>
        Active = 4, 

        /// <summary> System is in a non-normal flight mode. It can however still navigate. </summary>
        Critical = 5, 

        /// <summary> System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in mayday and going down. </summary>
        Emergency = 6, 

        /// <summary> System just initialized its power-down sequence, will shut down now. </summary>
        Poweroff = 7 };

    public enum MavComponent { 

        /// <summary>  </summary>
        MavCompIdAll = 0, 

        /// <summary>  </summary>
        MavCompIdGps = 220, 

        /// <summary>  </summary>
        MavCompIdMissionplanner = 190, 

        /// <summary>  </summary>
        MavCompIdPathplanner = 195, 

        /// <summary>  </summary>
        MavCompIdMapper = 180, 

        /// <summary>  </summary>
        MavCompIdCamera = 100, 

        /// <summary>  </summary>
        MavCompIdImu = 200, 

        /// <summary>  </summary>
        MavCompIdImu2 = 201, 

        /// <summary>  </summary>
        MavCompIdImu3 = 202, 

        /// <summary>  </summary>
        MavCompIdUdpBridge = 240, 

        /// <summary>  </summary>
        MavCompIdUartBridge = 241, 

        /// <summary>  </summary>
        MavCompIdSystemControl = 250, 

        /// <summary>  </summary>
        MavCompIdServo1 = 140, 

        /// <summary>  </summary>
        MavCompIdServo2 = 141, 

        /// <summary>  </summary>
        MavCompIdServo3 = 142, 

        /// <summary>  </summary>
        MavCompIdServo4 = 143, 

        /// <summary>  </summary>
        MavCompIdServo5 = 144, 

        /// <summary>  </summary>
        MavCompIdServo6 = 145, 

        /// <summary>  </summary>
        MavCompIdServo7 = 146, 

        /// <summary>  </summary>
        MavCompIdServo8 = 147, 

        /// <summary>  </summary>
        MavCompIdServo9 = 148, 

        /// <summary>  </summary>
        MavCompIdServo10 = 149, 

        /// <summary>  </summary>
        MavCompIdServo11 = 150, 

        /// <summary>  </summary>
        MavCompIdServo12 = 151, 

        /// <summary>  </summary>
        MavCompIdServo13 = 152, 

        /// <summary>  </summary>
        MavCompIdServo14 = 153, 

        /// <summary>  </summary>
        MavCompIdGimbal = 154, 

        /// <summary>  </summary>
        MavCompIdLog = 155, 

        /// <summary>  </summary>
        MavCompIdAdsb = 156, 

        /// <summary> On Screen Display (OSD) devices for video links </summary>
        MavCompIdOsd = 157, 

        /// <summary> Generic autopilot peripheral component ID. Meant for devices that do not implement the parameter sub-protocol </summary>
        MavCompIdPeripheral = 158 };

    /// <summary>
    /// These encode the sensors whose status is sent as part of the SYS_STATUS message.
    /// </summary>
    public enum MavSysStatusSensor { 

        /// <summary> 0x01 3D gyro </summary>
        _3dGyro = 1, 

        /// <summary> 0x02 3D accelerometer </summary>
        _3dAccel = 2, 

        /// <summary> 0x04 3D magnetometer </summary>
        _3dMag = 4, 

        /// <summary> 0x08 absolute pressure </summary>
        AbsolutePressure = 8, 

        /// <summary> 0x10 differential pressure </summary>
        DifferentialPressure = 16, 

        /// <summary> 0x20 GPS </summary>
        Gps = 32, 

        /// <summary> 0x40 optical flow </summary>
        OpticalFlow = 64, 

        /// <summary> 0x80 computer vision position </summary>
        VisionPosition = 128, 

        /// <summary> 0x100 laser based position </summary>
        LaserPosition = 256, 

        /// <summary> 0x200 external ground truth (Vicon or Leica) </summary>
        ExternalGroundTruth = 512, 

        /// <summary> 0x400 3D angular rate control </summary>
        AngularRateControl = 1024, 

        /// <summary> 0x800 attitude stabilization </summary>
        AttitudeStabilization = 2048, 

        /// <summary> 0x1000 yaw position </summary>
        YawPosition = 4096, 

        /// <summary> 0x2000 z/altitude control </summary>
        ZAltitudeControl = 8192, 

        /// <summary> 0x4000 x/y position control </summary>
        XyPositionControl = 16384, 

        /// <summary> 0x8000 motor outputs / control </summary>
        MotorOutputs = 32768, 

        /// <summary> 0x10000 rc receiver </summary>
        RcReceiver = 65536, 

        /// <summary> 0x20000 2nd 3D gyro </summary>
        _3dGyro2 = 131072, 

        /// <summary> 0x40000 2nd 3D accelerometer </summary>
        _3dAccel2 = 262144, 

        /// <summary> 0x80000 2nd 3D magnetometer </summary>
        _3dMag2 = 524288, 

        /// <summary> 0x100000 geofence </summary>
        MavSysStatusGeofence = 1048576, 

        /// <summary> 0x200000 AHRS subsystem health </summary>
        MavSysStatusAhrs = 2097152, 

        /// <summary> 0x400000 Terrain subsystem health </summary>
        MavSysStatusTerrain = 4194304, 

        /// <summary> 0x800000 Motors are reversed </summary>
        MavSysStatusReverseMotor = 8388608 };

    public enum MavFrame { 

        /// <summary> Global coordinate frame, WGS84 coordinate system. First value / x: latitude, second value / y: longitude, third value / z: positive altitude over mean sea level (MSL) </summary>
        Global = 0, 

        /// <summary> Local coordinate frame, Z-up (x: north, y: east, z: down). </summary>
        LocalNed = 1, 

        /// <summary> NOT a coordinate frame, indicates a mission command. </summary>
        Mission = 2, 

        /// <summary> Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude with 0 being at the altitude of the home location. </summary>
        GlobalRelativeAlt = 3, 

        /// <summary> Local coordinate frame, Z-down (x: east, y: north, z: up) </summary>
        LocalEnu = 4, 

        /// <summary> Global coordinate frame, WGS84 coordinate system. First value / x: latitude in degrees*1.0e-7, second value / y: longitude in degrees*1.0e-7, third value / z: positive altitude over mean sea level (MSL) </summary>
        GlobalInt = 5, 

        /// <summary> Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home position. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third value / z: positive altitude with 0 being at the altitude of the home location. </summary>
        GlobalRelativeAltInt = 6, 

        /// <summary> Offset to the current local frame. Anything expressed in this frame should be added to the current local frame position. </summary>
        LocalOffsetNed = 7, 

        /// <summary> Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to command 2 m/s^2 acceleration to the right. </summary>
        BodyNed = 8, 

        /// <summary> Offset in body NED frame. This makes sense if adding setpoints to the current flight path, to avoid an obstacle - e.g. useful to command 2 m/s^2 acceleration to the east. </summary>
        BodyOffsetNed = 9, 

        /// <summary> Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees, second value / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level in terrain model. </summary>
        GlobalTerrainAlt = 10, 

        /// <summary> Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third value / z: positive altitude in meters with 0 being at ground level in terrain model. </summary>
        GlobalTerrainAltInt = 11 };

    public enum MavlinkDataStreamType { 

        /// <summary>  </summary>
        MavlinkDataStreamImgJpeg = 1, 

        /// <summary>  </summary>
        MavlinkDataStreamImgBmp = 2, 

        /// <summary>  </summary>
        MavlinkDataStreamImgRaw8u = 3, 

        /// <summary>  </summary>
        MavlinkDataStreamImgRaw32u = 4, 

        /// <summary>  </summary>
        MavlinkDataStreamImgPgm = 5, 

        /// <summary>  </summary>
        MavlinkDataStreamImgPng = 6 };

    public enum FenceAction { 

        /// <summary> Disable fenced mode </summary>
        None = 0, 

        /// <summary> Switched to guided mode to return point (fence point 0) </summary>
        Guided = 1, 

        /// <summary> Report fence breach, but don't take action </summary>
        Report = 2, 

        /// <summary> Switched to guided mode to return point (fence point 0) with manual throttle control </summary>
        GuidedThrPass = 3, 

        /// <summary> Switch to RTL (return to launch) mode and head for the return point. </summary>
        Rtl = 4 };

    public enum FenceBreach { 

        /// <summary> No last fence breach </summary>
        None = 0, 

        /// <summary> Breached minimum altitude </summary>
        Minalt = 1, 

        /// <summary> Breached maximum altitude </summary>
        Maxalt = 2, 

        /// <summary> Breached fence boundary </summary>
        Boundary = 3 };

    /// <summary>
    /// Enumeration of possible mount operation modes
    /// </summary>
    public enum MavMountMode { 

        /// <summary> Load and keep safe position (Roll,Pitch,Yaw) from permant memory and stop stabilization </summary>
        Retract = 0, 

        /// <summary> Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory. </summary>
        Neutral = 1, 

        /// <summary> Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization </summary>
        MavlinkTargeting = 2, 

        /// <summary> Load neutral position and start RC Roll,Pitch,Yaw control with stabilization </summary>
        RcTargeting = 3, 

        /// <summary> Load neutral position and start to point to Lat,Lon,Alt </summary>
        GpsPoint = 4 };

    /// <summary>
    /// Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data.
    /// </summary>
    public enum MavCmd { 

        /// <summary> Navigate to MISSION. </summary>
        NavWaypoint = 16, 

        /// <summary> Loiter around this MISSION an unlimited amount of time </summary>
        NavLoiterUnlim = 17, 

        /// <summary> Loiter around this MISSION for X turns </summary>
        NavLoiterTurns = 18, 

        /// <summary> Loiter around this MISSION for X seconds </summary>
        NavLoiterTime = 19, 

        /// <summary> Return to launch location </summary>
        NavReturnToLaunch = 20, 

        /// <summary> Land at location </summary>
        NavLand = 21, 

        /// <summary> Takeoff from ground / hand </summary>
        NavTakeoff = 22, 

        /// <summary> Land at local position (local frame only) </summary>
        NavLandLocal = 23, 

        /// <summary> Takeoff from local position (local frame only) </summary>
        NavTakeoffLocal = 24, 

        /// <summary> Vehicle following, i.e. this waypoint represents the position of a moving vehicle </summary>
        NavFollow = 25, 

        /// <summary> Continue on the current course and climb/descend to specified altitude.  When the altitude is reached continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached. </summary>
        NavContinueAndChangeAlt = 30, 

        /// <summary> Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.  Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached.  Additionally, if the Heading Required parameter is non-zero the  aircraft will not leave the loiter until heading toward the next waypoint.  </summary>
        NavLoiterToAlt = 31, 

        /// <summary> Being following a target </summary>
        DoFollow = 32, 

        /// <summary> Reposition the MAV after a follow target command has been sent </summary>
        DoFollowReposition = 33, 

        /// <summary> Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras. </summary>
        NavRoi = 80, 

        /// <summary> Control autonomous path planning on the MAV. </summary>
        NavPathplanning = 81, 

        /// <summary> Navigate to MISSION using a spline path. </summary>
        NavSplineWaypoint = 82, 

        /// <summary> Takeoff from ground using VTOL mode </summary>
        NavVtolTakeoff = 84, 

        /// <summary> Land using VTOL mode </summary>
        NavVtolLand = 85, 

        /// <summary> hand control over to an external controller </summary>
        NavGuidedEnable = 92, 

        /// <summary> Delay the next navigation command a number of seconds or until a specified time </summary>
        NavDelay = 93, 

        /// <summary> NOP - This command is only used to mark the upper limit of the NAV/ACTION commands in the enumeration </summary>
        NavLast = 95, 

        /// <summary> Delay mission state machine. </summary>
        ConditionDelay = 112, 

        /// <summary> Ascend/descend at rate.  Delay mission state machine until desired altitude reached. </summary>
        ConditionChangeAlt = 113, 

        /// <summary> Delay mission state machine until within desired distance of next NAV point. </summary>
        ConditionDistance = 114, 

        /// <summary> Reach a certain target angle. </summary>
        ConditionYaw = 115, 

        /// <summary> NOP - This command is only used to mark the upper limit of the CONDITION commands in the enumeration </summary>
        ConditionLast = 159, 

        /// <summary> Set system mode. </summary>
        DoSetMode = 176, 

        /// <summary> Jump to the desired command in the mission list.  Repeat this action only the specified number of times </summary>
        DoJump = 177, 

        /// <summary> Change speed and/or throttle set points. </summary>
        DoChangeSpeed = 178, 

        /// <summary> Changes the home location either to the current location or a specified location. </summary>
        DoSetHome = 179, 

        /// <summary> Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value of the parameter. </summary>
        DoSetParameter = 180, 

        /// <summary> Set a relay to a condition. </summary>
        DoSetRelay = 181, 

        /// <summary> Cycle a relay on and off for a desired number of cyles with a desired period. </summary>
        DoRepeatRelay = 182, 

        /// <summary> Set a servo to a desired PWM value. </summary>
        DoSetServo = 183, 

        /// <summary> Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period. </summary>
        DoRepeatServo = 184, 

        /// <summary> Terminate flight immediately </summary>
        DoFlighttermination = 185, 

        /// <summary> Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where a sequence of mission items that represents a landing starts. It may also be sent via a COMMAND_LONG to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will be used. The Latitude/Longitude is optional, and may be set to 0/0 if not needed. If specified then it will be used to help find the closest landing sequence. </summary>
        DoLandStart = 189, 

        /// <summary> Mission command to perform a landing from a rally point. </summary>
        DoRallyLand = 190, 

        /// <summary> Mission command to safely abort an autonmous landing. </summary>
        DoGoAround = 191, 

        /// <summary> Reposition the vehicle to a specific WGS84 global position. </summary>
        DoReposition = 192, 

        /// <summary> If in a GPS controlled position mode, hold the current position or continue. </summary>
        DoPauseContinue = 193, 

        /// <summary> Control onboard camera system. </summary>
        DoControlVideo = 200, 

        /// <summary> Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras. </summary>
        DoSetRoi = 201, 

        /// <summary> Mission command to configure an on-board camera controller system. </summary>
        DoDigicamConfigure = 202, 

        /// <summary> Mission command to control an on-board camera controller system. </summary>
        DoDigicamControl = 203, 

        /// <summary> Mission command to configure a camera or antenna mount </summary>
        DoMountConfigure = 204, 

        /// <summary> Mission command to control a camera or antenna mount </summary>
        DoMountControl = 205, 

        /// <summary> Mission command to set CAM_TRIGG_DIST for this flight </summary>
        DoSetCamTriggDist = 206, 

        /// <summary> Mission command to enable the geofence </summary>
        DoFenceEnable = 207, 

        /// <summary> Mission command to trigger a parachute </summary>
        DoParachute = 208, 

        /// <summary> Change to/from inverted flight </summary>
        DoInvertedFlight = 210, 

        /// <summary> Mission command to control a camera or antenna mount, using a quaternion as reference. </summary>
        DoMountControlQuat = 220, 

        /// <summary> set id of master controller </summary>
        DoGuidedMaster = 221, 

        /// <summary> set limits for external control </summary>
        DoGuidedLimits = 222, 

        /// <summary> NOP - This command is only used to mark the upper limit of the DO commands in the enumeration </summary>
        DoLast = 240, 

        /// <summary> Trigger calibration. This command will be only accepted if in pre-flight mode. </summary>
        PreflightCalibration = 241, 

        /// <summary> Set sensor offsets. This command will be only accepted if in pre-flight mode. </summary>
        PreflightSetSensorOffsets = 242, 

        /// <summary> Trigger UAVCAN config. This command will be only accepted if in pre-flight mode. </summary>
        PreflightUavcan = 243, 

        /// <summary> Request storage of different parameter values and logs. This command will be only accepted if in pre-flight mode. </summary>
        PreflightStorage = 245, 

        /// <summary> Request the reboot or shutdown of system components. </summary>
        PreflightRebootShutdown = 246, 

        /// <summary> Hold / continue the current action </summary>
        OverrideGoto = 252, 

        /// <summary> start running a mission </summary>
        MissionStart = 300, 

        /// <summary> Arms / Disarms a component </summary>
        ComponentArmDisarm = 400, 

        /// <summary> Request the home position from the vehicle. </summary>
        GetHomePosition = 410, 

        /// <summary> Starts receiver pairing </summary>
        StartRxPair = 500, 

        /// <summary> Request the interval between messages for a particular MAVLink message ID </summary>
        GetMessageInterval = 510, 

        /// <summary> Request the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREAM </summary>
        SetMessageInterval = 511, 

        /// <summary> Request autopilot capabilities </summary>
        RequestAutopilotCapabilities = 520, 

        /// <summary> Start image capture sequence </summary>
        ImageStartCapture = 2000, 

        /// <summary> Stop image capture sequence </summary>
        ImageStopCapture = 2001, 

        /// <summary> Enable or disable on-board camera triggering system. </summary>
        DoTriggerControl = 2003, 

        /// <summary> Starts video capture </summary>
        VideoStartCapture = 2500, 

        /// <summary> Stop the current video capture </summary>
        VideoStopCapture = 2501, 

        /// <summary> Create a panorama at the current position </summary>
        PanoramaCreate = 2800, 

        /// <summary> Request VTOL transition </summary>
        DoVtolTransition = 3000, 

        /// <summary> Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release position and velocity. </summary>
        PayloadPrepareDeploy = 30001, 

        /// <summary> Control the payload deployment. </summary>
        PayloadControlDeploy = 30002, 

        /// <summary> User defined waypoint item. Ground Station will show the Vehicle as flying through this item. </summary>
        WaypointUser1 = 31000, 

        /// <summary> User defined waypoint item. Ground Station will show the Vehicle as flying through this item. </summary>
        WaypointUser2 = 31001, 

        /// <summary> User defined waypoint item. Ground Station will show the Vehicle as flying through this item. </summary>
        WaypointUser3 = 31002, 

        /// <summary> User defined waypoint item. Ground Station will show the Vehicle as flying through this item. </summary>
        WaypointUser4 = 31003, 

        /// <summary> User defined waypoint item. Ground Station will show the Vehicle as flying through this item. </summary>
        WaypointUser5 = 31004, 

        /// <summary> User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. </summary>
        SpatialUser1 = 31005, 

        /// <summary> User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. </summary>
        SpatialUser2 = 31006, 

        /// <summary> User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. </summary>
        SpatialUser3 = 31007, 

        /// <summary> User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. </summary>
        SpatialUser4 = 31008, 

        /// <summary> User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item. </summary>
        SpatialUser5 = 31009, 

        /// <summary> User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. </summary>
        User1 = 31010, 

        /// <summary> User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. </summary>
        User2 = 31011, 

        /// <summary> User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. </summary>
        User3 = 31012, 

        /// <summary> User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. </summary>
        User4 = 31013, 

        /// <summary> User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item. </summary>
        User5 = 31014, 

        /// <summary> Mission command to perform motor test </summary>
        DoMotorTest = 209, 

        /// <summary> Mission command to operate EPM gripper </summary>
        DoGripper = 211, 

        /// <summary> Enable/disable autotune </summary>
        DoAutotuneEnable = 212, 

        /// <summary> Mission command to wait for an altitude or downwards vertical speed. This is meant for high altitude balloon launches, allowing the aircraft to be idle until either an altitude is reached or a negative vertical speed is reached (indicating early balloon burst). The wiggle time is how often to wiggle the control surfaces to prevent them seizing up. </summary>
        NavAltitudeWait = 83, 

        /// <summary> A system wide power-off event has been initiated. </summary>
        PowerOffInitiated = 42000, 

        /// <summary> FLY button has been clicked. </summary>
        SoloBtnFlyClick = 42001, 

        /// <summary> FLY button has been held for 1.5 seconds. </summary>
        SoloBtnFlyHold = 42002, 

        /// <summary> PAUSE button has been clicked. </summary>
        SoloBtnPauseClick = 42003, 

        /// <summary> Initiate a magnetometer calibration </summary>
        DoStartMagCal = 42424, 

        /// <summary> Initiate a magnetometer calibration </summary>
        DoAcceptMagCal = 42425, 

        /// <summary> Cancel a running magnetometer calibration </summary>
        DoCancelMagCal = 42426, 

        /// <summary> Reply with the version banner </summary>
        DoSendBanner = 42428, 

        /// <summary> Causes the gimbal to reset and boot as if it was just powered on </summary>
        GimbalReset = 42501, 

        /// <summary> Command autopilot to get into factory test/diagnostic mode </summary>
        SetFactoryTestMode = 42427, 

        /// <summary> Reports progress and success or failure of gimbal axis calibration procedure </summary>
        GimbalAxisCalibrationStatus = 42502, 

        /// <summary> Starts commutation calibration on the gimbal </summary>
        GimbalRequestAxisCalibration = 42503, 

        /// <summary> Erases gimbal application and parameters </summary>
        GimbalFullReset = 42505 };

    /// <summary>
    /// THIS INTERFACE IS DEPRECATED AS OF JULY 2015. Please use MESSAGE_INTERVAL instead. A data stream is not a fixed set of messages, but rather a      recommendation to the autopilot software. Individual autopilots may or may not obey      the recommended messages.
    /// </summary>
    public enum MavDataStream { 

        /// <summary> Enable all data streams </summary>
        All = 0, 

        /// <summary> Enable IMU_RAW, GPS_RAW, GPS_STATUS packets. </summary>
        RawSensors = 1, 

        /// <summary> Enable GPS_STATUS, CONTROL_STATUS, AUX_STATUS </summary>
        ExtendedStatus = 2, 

        /// <summary> Enable RC_CHANNELS_SCALED, RC_CHANNELS_RAW, SERVO_OUTPUT_RAW </summary>
        RcChannels = 3, 

        /// <summary> Enable ATTITUDE_CONTROLLER_OUTPUT, POSITION_CONTROLLER_OUTPUT, NAV_CONTROLLER_OUTPUT. </summary>
        RawController = 4, 

        /// <summary> Enable LOCAL_POSITION, GLOBAL_POSITION/GLOBAL_POSITION_INT messages. </summary>
        Position = 6, 

        /// <summary> Dependent on the autopilot </summary>
        Extra1 = 10, 

        /// <summary> Dependent on the autopilot </summary>
        Extra2 = 11, 

        /// <summary> Dependent on the autopilot </summary>
        Extra3 = 12 };

    /// <summary>
    ///  The ROI (region of interest) for the vehicle. This can be                 be used by the vehicle for camera/vehicle attitude alignment (see                 MAV_CMD_NAV_ROI).
    /// </summary>
    public enum MavRoi { 

        /// <summary> No region of interest. </summary>
        None = 0, 

        /// <summary> Point toward next MISSION. </summary>
        Wpnext = 1, 

        /// <summary> Point toward given MISSION. </summary>
        Wpindex = 2, 

        /// <summary> Point toward fixed location. </summary>
        Location = 3, 

        /// <summary> Point toward of given id. </summary>
        Target = 4 };

    /// <summary>
    /// ACK / NACK / ERROR values as a result of MAV_CMDs and for mission item transmission.
    /// </summary>
    public enum MavCmdAck { 

        /// <summary> Command / mission item is ok. </summary>
        Ok = 1, 

        /// <summary> Generic error message if none of the other reasons fails or if no detailed error reporting is implemented. </summary>
        ErrFail = 2, 

        /// <summary> The system is refusing to accept this command from this source / communication partner. </summary>
        ErrAccessDenied = 3, 

        /// <summary> Command or mission item is not supported, other commands would be accepted. </summary>
        ErrNotSupported = 4, 

        /// <summary> The coordinate frame of this command / mission item is not supported. </summary>
        ErrCoordinateFrameNotSupported = 5, 

        /// <summary> The coordinate frame of this command is ok, but he coordinate values exceed the safety limits of this system. This is a generic error, please use the more specific error messages below if possible. </summary>
        ErrCoordinatesOutOfRange = 6, 

        /// <summary> The X or latitude value is out of range. </summary>
        ErrXLatOutOfRange = 7, 

        /// <summary> The Y or longitude value is out of range. </summary>
        ErrYLonOutOfRange = 8, 

        /// <summary> The Z or altitude value is out of range. </summary>
        ErrZAltOutOfRange = 9 };

    /// <summary>
    /// Specifies the datatype of a MAVLink parameter.
    /// </summary>
    public enum MavParamType { 

        /// <summary> 8-bit unsigned integer </summary>
        Uint8 = 1, 

        /// <summary> 8-bit signed integer </summary>
        Int8 = 2, 

        /// <summary> 16-bit unsigned integer </summary>
        Uint16 = 3, 

        /// <summary> 16-bit signed integer </summary>
        Int16 = 4, 

        /// <summary> 32-bit unsigned integer </summary>
        Uint32 = 5, 

        /// <summary> 32-bit signed integer </summary>
        Int32 = 6, 

        /// <summary> 64-bit unsigned integer </summary>
        Uint64 = 7, 

        /// <summary> 64-bit signed integer </summary>
        Int64 = 8, 

        /// <summary> 32-bit floating-point </summary>
        Real32 = 9, 

        /// <summary> 64-bit floating-point </summary>
        Real64 = 10 };

    /// <summary>
    /// result from a mavlink command
    /// </summary>
    public enum MavResult { 

        /// <summary> Command ACCEPTED and EXECUTED </summary>
        Accepted = 0, 

        /// <summary> Command TEMPORARY REJECTED/DENIED </summary>
        TemporarilyRejected = 1, 

        /// <summary> Command PERMANENTLY DENIED </summary>
        Denied = 2, 

        /// <summary> Command UNKNOWN/UNSUPPORTED </summary>
        Unsupported = 3, 

        /// <summary> Command executed, but failed </summary>
        Failed = 4 };

    /// <summary>
    /// result in a mavlink mission ack
    /// </summary>
    public enum MavMissionResult { 

        /// <summary> mission accepted OK </summary>
        MavMissionAccepted = 0, 

        /// <summary> generic error / not accepting mission commands at all right now </summary>
        MavMissionError = 1, 

        /// <summary> coordinate frame is not supported </summary>
        MavMissionUnsupportedFrame = 2, 

        /// <summary> command is not supported </summary>
        MavMissionUnsupported = 3, 

        /// <summary> mission item exceeds storage space </summary>
        MavMissionNoSpace = 4, 

        /// <summary> one of the parameters has an invalid value </summary>
        MavMissionInvalid = 5, 

        /// <summary> param1 has an invalid value </summary>
        MavMissionInvalidParam1 = 6, 

        /// <summary> param2 has an invalid value </summary>
        MavMissionInvalidParam2 = 7, 

        /// <summary> param3 has an invalid value </summary>
        MavMissionInvalidParam3 = 8, 

        /// <summary> param4 has an invalid value </summary>
        MavMissionInvalidParam4 = 9, 

        /// <summary> x/param5 has an invalid value </summary>
        MavMissionInvalidParam5X = 10, 

        /// <summary> y/param6 has an invalid value </summary>
        MavMissionInvalidParam6Y = 11, 

        /// <summary> param7 has an invalid value </summary>
        MavMissionInvalidParam7 = 12, 

        /// <summary> received waypoint out of sequence </summary>
        MavMissionInvalidSequence = 13, 

        /// <summary> not accepting any mission commands from this communication partner </summary>
        MavMissionDenied = 14 };

    /// <summary>
    /// Indicates the severity level, generally used for status messages to indicate their relative urgency. Based on RFC-5424 using expanded definitions at: http://www.kiwisyslog.com/kb/info:-syslog-message-levels/.
    /// </summary>
    public enum MavSeverity { 

        /// <summary> System is unusable. This is a 'panic' condition. </summary>
        Emergency = 0, 

        /// <summary> Action should be taken immediately. Indicates error in non-critical systems. </summary>
        Alert = 1, 

        /// <summary> Action must be taken immediately. Indicates failure in a primary system. </summary>
        Critical = 2, 

        /// <summary> Indicates an error in secondary/redundant systems. </summary>
        Error = 3, 

        /// <summary> Indicates about a possible future error if this is not resolved within a given timeframe. Example would be a low battery warning. </summary>
        Warning = 4, 

        /// <summary> An unusual event has occured, though not an error condition. This should be investigated for the root cause. </summary>
        Notice = 5, 

        /// <summary> Normal operational messages. Useful for logging. No action is required for these messages. </summary>
        Info = 6, 

        /// <summary> Useful non-operational messages that can assist in debugging. These should not occur during normal operation. </summary>
        Debug = 7 };

    /// <summary>
    /// Power supply status flags (bitmask)
    /// </summary>
    public enum MavPowerStatus { 

        /// <summary> main brick power supply valid </summary>
        BrickValid = 1, 

        /// <summary> main servo power supply valid for FMU </summary>
        ServoValid = 2, 

        /// <summary> USB power is connected </summary>
        UsbConnected = 4, 

        /// <summary> peripheral supply is in over-current state </summary>
        PeriphOvercurrent = 8, 

        /// <summary> hi-power peripheral supply is in over-current state </summary>
        PeriphHipowerOvercurrent = 16, 

        /// <summary> Power status has changed since boot </summary>
        Changed = 32 };

    /// <summary>
    /// SERIAL_CONTROL device types
    /// </summary>
    public enum SerialControlDev { 

        /// <summary> First telemetry port </summary>
        Telem1 = 0, 

        /// <summary> Second telemetry port </summary>
        Telem2 = 1, 

        /// <summary> First GPS port </summary>
        Gps1 = 2, 

        /// <summary> Second GPS port </summary>
        Gps2 = 3, 

        /// <summary> system shell </summary>
        Shell = 10 };

    /// <summary>
    /// SERIAL_CONTROL flags (bitmask)
    /// </summary>
    public enum SerialControlFlag { 

        /// <summary> Set if this is a reply </summary>
        Reply = 1, 

        /// <summary> Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message </summary>
        Respond = 2, 

        /// <summary> Set if access to the serial port should be removed from whatever driver is currently using it, giving exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without this flag set </summary>
        Exclusive = 4, 

        /// <summary> Block on writes to the serial port </summary>
        Blocking = 8, 

        /// <summary> Send multiple replies until port is drained </summary>
        Multi = 16 };

    /// <summary>
    /// Enumeration of distance sensor types
    /// </summary>
    public enum MavDistanceSensor { 

        /// <summary> Laser rangefinder, e.g. LightWare SF02/F or PulsedLight units </summary>
        Laser = 0, 

        /// <summary> Ultrasound rangefinder, e.g. MaxBotix units </summary>
        Ultrasound = 1, 

        /// <summary> Infrared rangefinder, e.g. Sharp units </summary>
        Infrared = 2 };

    /// <summary>
    /// Enumeration of sensor orientation, according to its rotations
    /// </summary>
    public enum MavSensorOrientation { 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 0 </summary>
        MavSensorRotationNone = 0, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 45 </summary>
        MavSensorRotationYaw45 = 1, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 90 </summary>
        MavSensorRotationYaw90 = 2, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 135 </summary>
        MavSensorRotationYaw135 = 3, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 180 </summary>
        MavSensorRotationYaw180 = 4, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 225 </summary>
        MavSensorRotationYaw225 = 5, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 270 </summary>
        MavSensorRotationYaw270 = 6, 

        /// <summary> Roll: 0, Pitch: 0, Yaw: 315 </summary>
        MavSensorRotationYaw315 = 7, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 0 </summary>
        MavSensorRotationRoll180 = 8, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 45 </summary>
        MavSensorRotationRoll180Yaw45 = 9, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 90 </summary>
        MavSensorRotationRoll180Yaw90 = 10, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 135 </summary>
        MavSensorRotationRoll180Yaw135 = 11, 

        /// <summary> Roll: 0, Pitch: 180, Yaw: 0 </summary>
        MavSensorRotationPitch180 = 12, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 225 </summary>
        MavSensorRotationRoll180Yaw225 = 13, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 270 </summary>
        MavSensorRotationRoll180Yaw270 = 14, 

        /// <summary> Roll: 180, Pitch: 0, Yaw: 315 </summary>
        MavSensorRotationRoll180Yaw315 = 15, 

        /// <summary> Roll: 90, Pitch: 0, Yaw: 0 </summary>
        MavSensorRotationRoll90 = 16, 

        /// <summary> Roll: 90, Pitch: 0, Yaw: 45 </summary>
        MavSensorRotationRoll90Yaw45 = 17, 

        /// <summary> Roll: 90, Pitch: 0, Yaw: 90 </summary>
        MavSensorRotationRoll90Yaw90 = 18, 

        /// <summary> Roll: 90, Pitch: 0, Yaw: 135 </summary>
        MavSensorRotationRoll90Yaw135 = 19, 

        /// <summary> Roll: 270, Pitch: 0, Yaw: 0 </summary>
        MavSensorRotationRoll270 = 20, 

        /// <summary> Roll: 270, Pitch: 0, Yaw: 45 </summary>
        MavSensorRotationRoll270Yaw45 = 21, 

        /// <summary> Roll: 270, Pitch: 0, Yaw: 90 </summary>
        MavSensorRotationRoll270Yaw90 = 22, 

        /// <summary> Roll: 270, Pitch: 0, Yaw: 135 </summary>
        MavSensorRotationRoll270Yaw135 = 23, 

        /// <summary> Roll: 0, Pitch: 90, Yaw: 0 </summary>
        MavSensorRotationPitch90 = 24, 

        /// <summary> Roll: 0, Pitch: 270, Yaw: 0 </summary>
        MavSensorRotationPitch270 = 25, 

        /// <summary> Roll: 0, Pitch: 180, Yaw: 90 </summary>
        MavSensorRotationPitch180Yaw90 = 26, 

        /// <summary> Roll: 0, Pitch: 180, Yaw: 270 </summary>
        MavSensorRotationPitch180Yaw270 = 27, 

        /// <summary> Roll: 90, Pitch: 90, Yaw: 0 </summary>
        MavSensorRotationRoll90Pitch90 = 28, 

        /// <summary> Roll: 180, Pitch: 90, Yaw: 0 </summary>
        MavSensorRotationRoll180Pitch90 = 29, 

        /// <summary> Roll: 270, Pitch: 90, Yaw: 0 </summary>
        MavSensorRotationRoll270Pitch90 = 30, 

        /// <summary> Roll: 90, Pitch: 180, Yaw: 0 </summary>
        MavSensorRotationRoll90Pitch180 = 31, 

        /// <summary> Roll: 270, Pitch: 180, Yaw: 0 </summary>
        MavSensorRotationRoll270Pitch180 = 32, 

        /// <summary> Roll: 90, Pitch: 270, Yaw: 0 </summary>
        MavSensorRotationRoll90Pitch270 = 33, 

        /// <summary> Roll: 180, Pitch: 270, Yaw: 0 </summary>
        MavSensorRotationRoll180Pitch270 = 34, 

        /// <summary> Roll: 270, Pitch: 270, Yaw: 0 </summary>
        MavSensorRotationRoll270Pitch270 = 35, 

        /// <summary> Roll: 90, Pitch: 180, Yaw: 90 </summary>
        MavSensorRotationRoll90Pitch180Yaw90 = 36, 

        /// <summary> Roll: 90, Pitch: 0, Yaw: 270 </summary>
        MavSensorRotationRoll90Yaw270 = 37, 

        /// <summary> Roll: 315, Pitch: 315, Yaw: 315 </summary>
        MavSensorRotationRoll315Pitch315Yaw315 = 38 };

    /// <summary>
    /// Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability.
    /// </summary>
    public enum MavProtocolCapability { 

        /// <summary> Autopilot supports MISSION float message type. </summary>
        MissionFloat = 1, 

        /// <summary> Autopilot supports the new param float message type. </summary>
        ParamFloat = 2, 

        /// <summary> Autopilot supports MISSION_INT scaled integer message type. </summary>
        MissionInt = 4, 

        /// <summary> Autopilot supports COMMAND_INT scaled integer message type. </summary>
        CommandInt = 8, 

        /// <summary> Autopilot supports the new param union message type. </summary>
        ParamUnion = 16, 

        /// <summary> Autopilot supports the new FILE_TRANSFER_PROTOCOL message type. </summary>
        Ftp = 32, 

        /// <summary> Autopilot supports commanding attitude offboard. </summary>
        SetAttitudeTarget = 64, 

        /// <summary> Autopilot supports commanding position and velocity targets in local NED frame. </summary>
        SetPositionTargetLocalNed = 128, 

        /// <summary> Autopilot supports commanding position and velocity targets in global scaled integers. </summary>
        SetPositionTargetGlobalInt = 256, 

        /// <summary> Autopilot supports terrain protocol / data handling. </summary>
        Terrain = 512, 

        /// <summary> Autopilot supports direct actuator control. </summary>
        SetActuatorTarget = 1024, 

        /// <summary> Autopilot supports the flight termination command. </summary>
        FlightTermination = 2048, 

        /// <summary> Autopilot supports onboard compass calibration. </summary>
        CompassCalibration = 4096 };

    /// <summary>
    /// Enumeration of estimator types
    /// </summary>
    public enum MavEstimatorType { 

        /// <summary> This is a naive estimator without any real covariance feedback. </summary>
        Naive = 1, 

        /// <summary> Computer vision based estimate. Might be up to scale. </summary>
        Vision = 2, 

        /// <summary> Visual-inertial estimate. </summary>
        Vio = 3, 

        /// <summary> Plain GPS estimate. </summary>
        Gps = 4, 

        /// <summary> Estimator integrating GPS and inertial sensing. </summary>
        GpsIns = 5 };

    /// <summary>
    /// Enumeration of battery types
    /// </summary>
    public enum MavBatteryType { 

        /// <summary> Not specified. </summary>
        Unknown = 0, 

        /// <summary> Lithium polymer battery </summary>
        Lipo = 1, 

        /// <summary> Lithium-iron-phosphate battery </summary>
        Life = 2, 

        /// <summary> Lithium-ION battery </summary>
        Lion = 3, 

        /// <summary> Nickel metal hydride battery </summary>
        Nimh = 4 };

    /// <summary>
    /// Enumeration of battery functions
    /// </summary>
    public enum MavBatteryFunction { 

        /// <summary> Battery function is unknown </summary>
        Unknown = 0, 

        /// <summary> Battery supports all flight systems </summary>
        All = 1, 

        /// <summary> Battery for the propulsion system </summary>
        Propulsion = 2, 

        /// <summary> Avionics battery </summary>
        Avionics = 3, 

        /// <summary> Payload battery </summary>
        MavBatteryTypePayload = 4 };

    /// <summary>
    /// Enumeration of VTOL states
    /// </summary>
    public enum MavVtolState { 

        /// <summary> MAV is not configured as VTOL </summary>
        Undefined = 0, 

        /// <summary> VTOL is in transition from multicopter to fixed-wing </summary>
        TransitionToFw = 1, 

        /// <summary> VTOL is in transition from fixed-wing to multicopter </summary>
        TransitionToMc = 2, 

        /// <summary> VTOL is in multicopter state </summary>
        Mc = 3, 

        /// <summary> VTOL is in fixed-wing state </summary>
        Fw = 4 };

    /// <summary>
    /// Enumeration of landed detector states
    /// </summary>
    public enum MavLandedState { 

        /// <summary> MAV landed state is unknown </summary>
        Undefined = 0, 

        /// <summary> MAV is landed (on ground) </summary>
        OnGround = 1, 

        /// <summary> MAV is in air </summary>
        InAir = 2 };

    /// <summary>
    /// Enumeration of the ADSB altimeter types
    /// </summary>
    public enum AdsbAltitudeType { 

        /// <summary> Altitude reported from a Baro source using QNH reference </summary>
        PressureQnh = 0, 

        /// <summary> Altitude reported from a GNSS source </summary>
        Geometric = 1 };

    /// <summary>
    /// ADSB classification for the type of vehicle emitting the transponder signal
    /// </summary>
    public enum AdsbEmitterType { 

        /// <summary>  </summary>
        NoInfo = 0, 

        /// <summary>  </summary>
        Light = 1, 

        /// <summary>  </summary>
        Small = 2, 

        /// <summary>  </summary>
        Large = 3, 

        /// <summary>  </summary>
        HighVortexLarge = 4, 

        /// <summary>  </summary>
        Heavy = 5, 

        /// <summary>  </summary>
        HighlyManuv = 6, 

        /// <summary>  </summary>
        Rotocraft = 7, 

        /// <summary>  </summary>
        Unassigned = 8, 

        /// <summary>  </summary>
        Glider = 9, 

        /// <summary>  </summary>
        LighterAir = 10, 

        /// <summary>  </summary>
        Parachute = 11, 

        /// <summary>  </summary>
        UltraLight = 12, 

        /// <summary>  </summary>
        Unassigned2 = 13, 

        /// <summary>  </summary>
        Uav = 14, 

        /// <summary>  </summary>
        Space = 15, 

        /// <summary>  </summary>
        Unassgined3 = 16, 

        /// <summary>  </summary>
        EmergencySurface = 17, 

        /// <summary>  </summary>
        ServiceSurface = 18, 

        /// <summary>  </summary>
        PointObstacle = 19 };

    /// <summary>
    /// These flags indicate status such as data validity of each data source. Set = data valid
    /// </summary>
    public enum AdsbFlags { 

        /// <summary>  </summary>
        ValidCoords = 1, 

        /// <summary>  </summary>
        ValidAltitude = 2, 

        /// <summary>  </summary>
        ValidHeading = 4, 

        /// <summary>  </summary>
        ValidVelocity = 8, 

        /// <summary>  </summary>
        ValidCallsign = 16, 

        /// <summary>  </summary>
        ValidSquawk = 32, 

        /// <summary>  </summary>
        Simulated = 64 };

    /// <summary>
    /// Bitmask of options for the MAV_CMD_DO_REPOSITION
    /// </summary>
    public enum MavDoRepositionFlags { 

        /// <summary> The aircraft should immediately transition into guided. This should not be set for follow me applications </summary>
        ChangeMode = 1 };

    /// <summary>
    /// Flags in EKF_STATUS message
    /// </summary>
    public enum EstimatorStatusFlags { 

        /// <summary> True if the attitude estimate is good </summary>
        EstimatorAttitude = 1, 

        /// <summary> True if the horizontal velocity estimate is good </summary>
        EstimatorVelocityHoriz = 2, 

        /// <summary> True if the  vertical velocity estimate is good </summary>
        EstimatorVelocityVert = 4, 

        /// <summary> True if the horizontal position (relative) estimate is good </summary>
        EstimatorPosHorizRel = 8, 

        /// <summary> True if the horizontal position (absolute) estimate is good </summary>
        EstimatorPosHorizAbs = 16, 

        /// <summary> True if the vertical position (absolute) estimate is good </summary>
        EstimatorPosVertAbs = 32, 

        /// <summary> True if the vertical position (above ground) estimate is good </summary>
        EstimatorPosVertAgl = 64, 

        /// <summary> True if the EKF is in a constant position mode and is not using external measurements (eg GPS or optical flow) </summary>
        EstimatorConstPosMode = 128, 

        /// <summary> True if the EKF has sufficient data to enter a mode that will provide a (relative) position estimate </summary>
        EstimatorPredPosHorizRel = 256, 

        /// <summary> True if the EKF has sufficient data to enter a mode that will provide a (absolute) position estimate </summary>
        EstimatorPredPosHorizAbs = 512, 

        /// <summary> True if the EKF has detected a GPS glitch </summary>
        EstimatorGpsGlitch = 1024 };

    public enum LimitsState { 

        /// <summary> pre-initialization </summary>
        LimitsInit = 0, 

        /// <summary> disabled </summary>
        LimitsDisabled = 1, 

        /// <summary> checking limits </summary>
        LimitsEnabled = 2, 

        /// <summary> a limit has been breached </summary>
        LimitsTriggered = 3, 

        /// <summary> taking action eg. RTL </summary>
        LimitsRecovering = 4, 

        /// <summary> we're no longer in breach of a limit </summary>
        LimitsRecovered = 5 };

    public enum LimitModule { 

        /// <summary> pre-initialization </summary>
        LimitGpslock = 1, 

        /// <summary> disabled </summary>
        LimitGeofence = 2, 

        /// <summary> checking limits </summary>
        LimitAltitude = 4 };

    /// <summary>
    /// Flags in RALLY_POINT message
    /// </summary>
    public enum RallyFlags { 

        /// <summary> Flag set when requiring favorable winds for landing. </summary>
        FavorableWind = 1, 

        /// <summary> Flag set when plane is to immediately descend to break altitude and land without GCS intervention. Flag not set when plane is to loiter at Rally point until commanded to land. </summary>
        LandImmediately = 2 };

    public enum ParachuteAction { 

        /// <summary> Disable parachute release </summary>
        ParachuteDisable = 0, 

        /// <summary> Enable parachute release </summary>
        ParachuteEnable = 1, 

        /// <summary> Release parachute </summary>
        ParachuteRelease = 2 };

    public enum MotorTestThrottleType { 

        /// <summary> throttle as a percentage from 0 ~ 100 </summary>
        MotorTestThrottlePercent = 0, 

        /// <summary> throttle as an absolute PWM value (normally in range of 1000~2000) </summary>
        MotorTestThrottlePwm = 1, 

        /// <summary> throttle pass-through from pilot's transmitter </summary>
        MotorTestThrottlePilot = 2 };

    /// <summary>
    /// Gripper actions.
    /// </summary>
    public enum GripperActions { 

        /// <summary> gripper release of cargo </summary>
        GripperActionRelease = 0, 

        /// <summary> gripper grabs onto cargo </summary>
        GripperActionGrab = 1 };

    public enum CameraStatusTypes { 

        /// <summary> Camera heartbeat, announce camera component ID at 1hz </summary>
        CameraStatusTypeHeartbeat = 0, 

        /// <summary> Camera image triggered </summary>
        CameraStatusTypeTrigger = 1, 

        /// <summary> Camera connection lost </summary>
        CameraStatusTypeDisconnect = 2, 

        /// <summary> Camera unknown error </summary>
        CameraStatusTypeError = 3, 

        /// <summary> Camera battery low. Parameter p1 shows reported voltage </summary>
        CameraStatusTypeLowbatt = 4, 

        /// <summary> Camera storage low. Parameter p1 shows reported shots remaining </summary>
        CameraStatusTypeLowstore = 5, 

        /// <summary> Camera storage low. Parameter p1 shows reported video minutes remaining </summary>
        CameraStatusTypeLowstorev = 6 };

    public enum CameraFeedbackFlags { 

        /// <summary> Shooting photos, not video </summary>
        CameraFeedbackPhoto = 0, 

        /// <summary> Shooting video, not stills </summary>
        CameraFeedbackVideo = 1, 

        /// <summary> Unable to achieve requested exposure (e.g. shutter speed too low) </summary>
        CameraFeedbackBadexposure = 2, 

        /// <summary> Closed loop feedback from camera, we know for sure it has successfully taken a picture </summary>
        CameraFeedbackClosedloop = 3, 

        /// <summary> Open loop camera, an image trigger has been requested but we can't know for sure it has successfully taken a picture </summary>
        CameraFeedbackOpenloop = 4 };

    public enum MavModeGimbal { 

        /// <summary> Gimbal is powered on but has not started initializing yet </summary>
        Uninitialized = 0, 

        /// <summary> Gimbal is currently running calibration on the pitch axis </summary>
        CalibratingPitch = 1, 

        /// <summary> Gimbal is currently running calibration on the roll axis </summary>
        CalibratingRoll = 2, 

        /// <summary> Gimbal is currently running calibration on the yaw axis </summary>
        CalibratingYaw = 3, 

        /// <summary> Gimbal has finished calibrating and initializing, but is relaxed pending reception of first rate command from copter </summary>
        Initialized = 4, 

        /// <summary> Gimbal is actively stabilizing </summary>
        Active = 5, 

        /// <summary> Gimbal is relaxed because it missed more than 10 expected rate command messages in a row. Gimbal will move back to active mode when it receives a new rate command </summary>
        RateCmdTimeout = 6 };

    public enum GimbalAxis { 

        /// <summary> Gimbal yaw axis </summary>
        Yaw = 0, 

        /// <summary> Gimbal pitch axis </summary>
        Pitch = 1, 

        /// <summary> Gimbal roll axis </summary>
        Roll = 2 };

    public enum GimbalAxisCalibrationStatus { 

        /// <summary> Axis calibration is in progress </summary>
        InProgress = 0, 

        /// <summary> Axis calibration succeeded </summary>
        Succeeded = 1, 

        /// <summary> Axis calibration failed </summary>
        Failed = 2 };

    public enum GimbalAxisCalibrationRequired { 

        /// <summary> Whether or not this axis requires calibration is unknown at this time </summary>
        Unknown = 0, 

        /// <summary> This axis requires calibration </summary>
        True = 1, 

        /// <summary> This axis does not require calibration </summary>
        False = 2 };

    public enum GoproHeartbeatStatus { 

        /// <summary> No GoPro connected </summary>
        Disconnected = 0, 

        /// <summary> The detected GoPro is not HeroBus compatible </summary>
        Incompatible = 1, 

        /// <summary> A HeroBus compatible GoPro is connected </summary>
        Connected = 2, 

        /// <summary> An unrecoverable error was encountered with the connected GoPro, it may require a power cycle </summary>
        Error = 3 };

    public enum GoproHeartbeatFlags { 

        /// <summary> GoPro is currently recording </summary>
        GoproFlagRecording = 1 };

    public enum GoproRequestStatus { 

        /// <summary> The write message with ID indicated succeeded </summary>
        GoproRequestSuccess = 0, 

        /// <summary> The write message with ID indicated failed </summary>
        GoproRequestFailed = 1 };

    public enum GoproCommand { 

        /// <summary> (Get/Set) </summary>
        Power = 0, 

        /// <summary> (Get/Set) </summary>
        CaptureMode = 1, 

        /// <summary> (___/Set) </summary>
        Shutter = 2, 

        /// <summary> (Get/___) </summary>
        Battery = 3, 

        /// <summary> (Get/___) </summary>
        Model = 4, 

        /// <summary> (Get/Set) </summary>
        VideoSettings = 5, 

        /// <summary> (Get/Set) </summary>
        LowLight = 6, 

        /// <summary> (Get/Set) </summary>
        PhotoResolution = 7, 

        /// <summary> (Get/Set) </summary>
        PhotoBurstRate = 8, 

        /// <summary> (Get/Set) </summary>
        Protune = 9, 

        /// <summary> (Get/Set) Hero 3+ Only </summary>
        ProtuneWhiteBalance = 10, 

        /// <summary> (Get/Set) Hero 3+ Only </summary>
        ProtuneColour = 11, 

        /// <summary> (Get/Set) Hero 3+ Only </summary>
        ProtuneGain = 12, 

        /// <summary> (Get/Set) Hero 3+ Only </summary>
        ProtuneSharpness = 13, 

        /// <summary> (Get/Set) Hero 3+ Only </summary>
        ProtuneExposure = 14, 

        /// <summary> (Get/Set) </summary>
        Time = 15, 

        /// <summary> (Get/Set) </summary>
        Charging = 16 };

    public enum GoproCaptureMode { 

        /// <summary> Video mode </summary>
        Video = 0, 

        /// <summary> Photo mode </summary>
        Photo = 1, 

        /// <summary> Burst mode, hero 3+ only </summary>
        Burst = 2, 

        /// <summary> Time lapse mode, hero 3+ only </summary>
        TimeLapse = 3, 

        /// <summary> Multi shot mode, hero 4 only </summary>
        MultiShot = 4, 

        /// <summary> Playback mode, hero 4 only, silver only except when LCD or HDMI is connected to black </summary>
        Playback = 5, 

        /// <summary> Playback mode, hero 4 only </summary>
        Setup = 6, 

        /// <summary> Mode not yet known </summary>
        Unknown = 255 };

    public enum GoproResolution { 

        /// <summary> 848 x 480 (480p) </summary>
        _480p = 0, 

        /// <summary> 1280 x 720 (720p) </summary>
        _720p = 1, 

        /// <summary> 1280 x 960 (960p) </summary>
        _960p = 2, 

        /// <summary> 1920 x 1080 (1080p) </summary>
        _1080p = 3, 

        /// <summary> 1920 x 1440 (1440p) </summary>
        _1440p = 4, 

        /// <summary> 2704 x 1440 (2.7k-17:9) </summary>
        _27k179 = 5, 

        /// <summary> 2704 x 1524 (2.7k-16:9) </summary>
        _27k169 = 6, 

        /// <summary> 2704 x 2028 (2.7k-4:3) </summary>
        _27k43 = 7, 

        /// <summary> 3840 x 2160 (4k-16:9) </summary>
        _4k169 = 8, 

        /// <summary> 4096 x 2160 (4k-17:9) </summary>
        _4k179 = 9, 

        /// <summary> 1280 x 720 (720p-SuperView) </summary>
        _720pSuperview = 10, 

        /// <summary> 1920 x 1080 (1080p-SuperView) </summary>
        _1080pSuperview = 11, 

        /// <summary> 2704 x 1520 (2.7k-SuperView) </summary>
        _27kSuperview = 12, 

        /// <summary> 3840 x 2160 (4k-SuperView) </summary>
        _4kSuperview = 13 };

    public enum GoproFrameRate { 

        /// <summary> 12 FPS </summary>
        _12 = 0, 

        /// <summary> 15 FPS </summary>
        _15 = 1, 

        /// <summary> 24 FPS </summary>
        _24 = 2, 

        /// <summary> 25 FPS </summary>
        _25 = 3, 

        /// <summary> 30 FPS </summary>
        _30 = 4, 

        /// <summary> 48 FPS </summary>
        _48 = 5, 

        /// <summary> 50 FPS </summary>
        _50 = 6, 

        /// <summary> 60 FPS </summary>
        _60 = 7, 

        /// <summary> 80 FPS </summary>
        _80 = 8, 

        /// <summary> 90 FPS </summary>
        _90 = 9, 

        /// <summary> 100 FPS </summary>
        _100 = 10, 

        /// <summary> 120 FPS </summary>
        _120 = 11, 

        /// <summary> 240 FPS </summary>
        _240 = 12, 

        /// <summary> 12.5 FPS </summary>
        _125 = 13 };

    public enum GoproFieldOfView { 

        /// <summary> 0x00: Wide </summary>
        Wide = 0, 

        /// <summary> 0x01: Medium </summary>
        Medium = 1, 

        /// <summary> 0x02: Narrow </summary>
        Narrow = 2 };

    public enum GoproVideoSettingsFlags { 

        /// <summary> 0=NTSC, 1=PAL </summary>
        GoproVideoSettingsTvMode = 1 };

    public enum GoproPhotoResolution { 

        /// <summary> 5MP Medium </summary>
        _5mpMedium = 0, 

        /// <summary> 7MP Medium </summary>
        _7mpMedium = 1, 

        /// <summary> 7MP Wide </summary>
        _7mpWide = 2, 

        /// <summary> 10MP Wide </summary>
        _10mpWide = 3, 

        /// <summary> 12MP Wide </summary>
        _12mpWide = 4 };

    public enum GoproProtuneWhiteBalance { 

        /// <summary> Auto </summary>
        Auto = 0, 

        /// <summary> 3000K </summary>
        _3000k = 1, 

        /// <summary> 5500K </summary>
        _5500k = 2, 

        /// <summary> 6500K </summary>
        _6500k = 3, 

        /// <summary> Camera Raw </summary>
        Raw = 4 };

    public enum GoproProtuneColour { 

        /// <summary> Auto </summary>
        Standard = 0, 

        /// <summary> Neutral </summary>
        Neutral = 1 };

    public enum GoproProtuneGain { 

        /// <summary> ISO 400 </summary>
        _400 = 0, 

        /// <summary> ISO 800 (Only Hero 4) </summary>
        _800 = 1, 

        /// <summary> ISO 1600 </summary>
        _1600 = 2, 

        /// <summary> ISO 3200 (Only Hero 4) </summary>
        _3200 = 3, 

        /// <summary> ISO 6400 </summary>
        _6400 = 4 };

    public enum GoproProtuneSharpness { 

        /// <summary> Low Sharpness </summary>
        Low = 0, 

        /// <summary> Medium Sharpness </summary>
        Medium = 1, 

        /// <summary> High Sharpness </summary>
        High = 2 };

    public enum GoproProtuneExposure { 

        /// <summary> -5.0 EV (Hero 3+ Only) </summary>
        Neg50 = 0, 

        /// <summary> -4.5 EV (Hero 3+ Only) </summary>
        Neg45 = 1, 

        /// <summary> -4.0 EV (Hero 3+ Only) </summary>
        Neg40 = 2, 

        /// <summary> -3.5 EV (Hero 3+ Only) </summary>
        Neg35 = 3, 

        /// <summary> -3.0 EV (Hero 3+ Only) </summary>
        Neg30 = 4, 

        /// <summary> -2.5 EV (Hero 3+ Only) </summary>
        Neg25 = 5, 

        /// <summary> -2.0 EV </summary>
        Neg20 = 6, 

        /// <summary> -1.5 EV </summary>
        Neg15 = 7, 

        /// <summary> -1.0 EV </summary>
        Neg10 = 8, 

        /// <summary> -0.5 EV </summary>
        Neg05 = 9, 

        /// <summary> 0.0 EV </summary>
        Zero = 10, 

        /// <summary> +0.5 EV </summary>
        Pos05 = 11, 

        /// <summary> +1.0 EV </summary>
        Pos10 = 12, 

        /// <summary> +1.5 EV </summary>
        Pos15 = 13, 

        /// <summary> +2.0 EV </summary>
        Pos20 = 14, 

        /// <summary> +2.5 EV (Hero 3+ Only) </summary>
        Pos25 = 15, 

        /// <summary> +3.0 EV (Hero 3+ Only) </summary>
        Pos30 = 16, 

        /// <summary> +3.5 EV (Hero 3+ Only) </summary>
        Pos35 = 17, 

        /// <summary> +4.0 EV (Hero 3+ Only) </summary>
        Pos40 = 18, 

        /// <summary> +4.5 EV (Hero 3+ Only) </summary>
        Pos45 = 19, 

        /// <summary> +5.0 EV (Hero 3+ Only) </summary>
        Pos50 = 20 };

    public enum GoproCharging { 

        /// <summary> Charging disabled </summary>
        Disabled = 0, 

        /// <summary> Charging enabled </summary>
        Enabled = 1 };

    public enum GoproModel { 

        /// <summary> Unknown gopro model </summary>
        Unknown = 0, 

        /// <summary> Hero 3+ Silver (HeroBus not supported by GoPro) </summary>
        Hero3PlusSilver = 1, 

        /// <summary> Hero 3+ Black </summary>
        Hero3PlusBlack = 2, 

        /// <summary> Hero 4 Silver </summary>
        Hero4Silver = 3, 

        /// <summary> Hero 4 Black </summary>
        Hero4Black = 4 };

    public enum GoproBurstRate { 

        /// <summary> 3 Shots / 1 Second </summary>
        _3In1Second = 0, 

        /// <summary> 5 Shots / 1 Second </summary>
        _5In1Second = 1, 

        /// <summary> 10 Shots / 1 Second </summary>
        _10In1Second = 2, 

        /// <summary> 10 Shots / 2 Second </summary>
        _10In2Second = 3, 

        /// <summary> 10 Shots / 3 Second (Hero 4 Only) </summary>
        _10In3Second = 4, 

        /// <summary> 30 Shots / 1 Second </summary>
        _30In1Second = 5, 

        /// <summary> 30 Shots / 2 Second </summary>
        _30In2Second = 6, 

        /// <summary> 30 Shots / 3 Second </summary>
        _30In3Second = 7, 

        /// <summary> 30 Shots / 6 Second </summary>
        _30In6Second = 8 };

    public enum LedControlPattern { 

        /// <summary> LED patterns off (return control to regular vehicle control) </summary>
        Off = 0, 

        /// <summary> LEDs show pattern during firmware update </summary>
        Firmwareupdate = 1, 

        /// <summary> Custom Pattern using custom bytes fields </summary>
        Custom = 255 };

    /// <summary>
    /// Flags in EKF_STATUS message
    /// </summary>
    public enum EkfStatusFlags { 

        /// <summary> set if EKF's attitude estimate is good </summary>
        EkfAttitude = 1, 

        /// <summary> set if EKF's horizontal velocity estimate is good </summary>
        EkfVelocityHoriz = 2, 

        /// <summary> set if EKF's vertical velocity estimate is good </summary>
        EkfVelocityVert = 4, 

        /// <summary> set if EKF's horizontal position (relative) estimate is good </summary>
        EkfPosHorizRel = 8, 

        /// <summary> set if EKF's horizontal position (absolute) estimate is good </summary>
        EkfPosHorizAbs = 16, 

        /// <summary> set if EKF's vertical position (absolute) estimate is good </summary>
        EkfPosVertAbs = 32, 

        /// <summary> set if EKF's vertical position (above ground) estimate is good </summary>
        EkfPosVertAgl = 64, 

        /// <summary> EKF is in constant position mode and does not know it's absolute or relative position </summary>
        EkfConstPosMode = 128, 

        /// <summary> set if EKF's predicted horizontal position (relative) estimate is good </summary>
        EkfPredPosHorizRel = 256, 

        /// <summary> set if EKF's predicted horizontal position (absolute) estimate is good </summary>
        EkfPredPosHorizAbs = 512 };

    public enum PidTuningAxis { 

        /// <summary>  </summary>
        PidTuningRoll = 1, 

        /// <summary>  </summary>
        PidTuningPitch = 2, 

        /// <summary>  </summary>
        PidTuningYaw = 3, 

        /// <summary>  </summary>
        PidTuningAccz = 4, 

        /// <summary>  </summary>
        PidTuningSteer = 5 };

    public enum MagCalStatus { 

        /// <summary>  </summary>
        MagCalNotStarted = 0, 

        /// <summary>  </summary>
        MagCalWaitingToStart = 1, 

        /// <summary>  </summary>
        MagCalRunningStepOne = 2, 

        /// <summary>  </summary>
        MagCalRunningStepTwo = 3, 

        /// <summary>  </summary>
        MagCalSuccess = 4, 

        /// <summary>  </summary>
        MagCalFailed = 5 };

    /// <summary>
    /// Special ACK block numbers control activation of dataflash log streaming
    /// </summary>
    public enum MavRemoteLogDataBlockCommands { 

        /// <summary> UAV to stop sending DataFlash blocks </summary>
        MavRemoteLogDataBlockStop = 2147483645, 

        /// <summary> UAV to start sending DataFlash blocks </summary>
        MavRemoteLogDataBlockStart = 2147483646 };

    /// <summary>
    /// Possible remote log data block statuses
    /// </summary>
    public enum MavRemoteLogDataBlockStatuses { 

        /// <summary> This block has NOT been received </summary>
        MavRemoteLogDataBlockNack = 0, 

        /// <summary> This block has been received </summary>
        MavRemoteLogDataBlockAck = 1 };


    // ___________________________________________________________________________________


    /// <summary>
    /// The heartbeat message shows that a system is present and responding. The type of the MAV and Autopilot hardware allow the receiving system to treat further messages from this system appropriate (e.g. by laying out the user interface based on the autopilot).
    /// </summary>
    public class UasHeartbeat: UasMessage
    {
        /// <summary>
        /// A bitfield for use for autopilot-specific flags.
        /// </summary>
        public UInt32 CustomMode {
            get { return mCustomMode; }
            set { mCustomMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM)
        /// </summary>
        public MavType Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot type / class. defined in MAV_AUTOPILOT ENUM
        /// </summary>
        public MavAutopilot Autopilot {
            get { return mAutopilot; }
            set { mAutopilot = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System mode bitfield, see MAV_MODE_FLAG ENUM in mavlink/include/mavlink_types.h
        /// </summary>
        public MavModeFlag BaseMode {
            get { return mBaseMode; }
            set { mBaseMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System status flag, see MAV_STATE ENUM
        /// </summary>
        public MavState SystemStatus {
            get { return mSystemStatus; }
            set { mSystemStatus = value; NotifyUpdated(); }
        }

        /// <summary>
        /// MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version
        /// </summary>
        public byte MavlinkVersion {
            get { return mMavlinkVersion; }
            set { mMavlinkVersion = value; NotifyUpdated(); }
        }

        public UasHeartbeat()
        {
            mMessageId = 0;
            CrcExtra = 50;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mCustomMode);
            s.Write((byte)mType);
            s.Write((byte)mAutopilot);
            s.Write((byte)mBaseMode);
            s.Write((byte)mSystemStatus);
            s.Write(mMavlinkVersion);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mCustomMode = s.ReadUInt32();
            this.mType = (MavType)s.ReadByte();
            this.mAutopilot = (MavAutopilot)s.ReadByte();
            this.mBaseMode = (MavModeFlag)s.ReadByte();
            this.mSystemStatus = (MavState)s.ReadByte();
            this.mMavlinkVersion = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The heartbeat message shows that a system is present and responding. The type of the MAV and Autopilot hardware allow the receiving system to treat further messages from this system appropriate (e.g. by laying out the user interface based on the autopilot)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CustomMode",
                Description = "A bitfield for use for autopilot-specific flags.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autopilot",
                Description = "Autopilot type / class. defined in MAV_AUTOPILOT ENUM",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavAutopilot"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaseMode",
                Description = "System mode bitfield, see MAV_MODE_FLAG ENUM in mavlink/include/mavlink_types.h",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavModeFlag"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SystemStatus",
                Description = "System status flag, see MAV_STATE ENUM",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavState"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MavlinkVersion",
                Description = "MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version",
                NumElements = 1,
            });

        }

        private UInt32 mCustomMode;
        private MavType mType;
        private MavAutopilot mAutopilot;
        private MavModeFlag mBaseMode;
        private MavState mSystemStatus;
        private byte mMavlinkVersion;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows wether the system is currently active or not and if an emergency occured. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occured it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout.
    /// </summary>
    public class UasSysStatus: UasMessage
    {
        /// <summary>
        /// Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
        /// </summary>
        public MavSysStatusSensor OnboardControlSensorsPresent {
            get { return mOnboardControlSensorsPresent; }
            set { mOnboardControlSensorsPresent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
        /// </summary>
        public MavSysStatusSensor OnboardControlSensorsEnabled {
            get { return mOnboardControlSensorsEnabled; }
            set { mOnboardControlSensorsEnabled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR
        /// </summary>
        public MavSysStatusSensor OnboardControlSensorsHealth {
            get { return mOnboardControlSensorsHealth; }
            set { mOnboardControlSensorsHealth = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000
        /// </summary>
        public UInt16 Load {
            get { return mLoad; }
            set { mLoad = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery voltage, in millivolts (1 = 1 millivolt)
        /// </summary>
        public UInt16 VoltageBattery {
            get { return mVoltageBattery; }
            set { mVoltageBattery = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
        /// </summary>
        public Int16 CurrentBattery {
            get { return mCurrentBattery; }
            set { mCurrentBattery = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Communication drops in percent, (0%: 0, 100%: 10'000), (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
        /// </summary>
        public UInt16 DropRateComm {
            get { return mDropRateComm; }
            set { mDropRateComm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
        /// </summary>
        public UInt16 ErrorsComm {
            get { return mErrorsComm; }
            set { mErrorsComm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot-specific errors
        /// </summary>
        public UInt16 ErrorsCount1 {
            get { return mErrorsCount1; }
            set { mErrorsCount1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot-specific errors
        /// </summary>
        public UInt16 ErrorsCount2 {
            get { return mErrorsCount2; }
            set { mErrorsCount2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot-specific errors
        /// </summary>
        public UInt16 ErrorsCount3 {
            get { return mErrorsCount3; }
            set { mErrorsCount3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Autopilot-specific errors
        /// </summary>
        public UInt16 ErrorsCount4 {
            get { return mErrorsCount4; }
            set { mErrorsCount4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery
        /// </summary>
        public SByte BatteryRemaining {
            get { return mBatteryRemaining; }
            set { mBatteryRemaining = value; NotifyUpdated(); }
        }

        public UasSysStatus()
        {
            mMessageId = 1;
            CrcExtra = 124;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write((UInt32)mOnboardControlSensorsPresent);
            s.Write((UInt32)mOnboardControlSensorsEnabled);
            s.Write((UInt32)mOnboardControlSensorsHealth);
            s.Write(mLoad);
            s.Write(mVoltageBattery);
            s.Write(mCurrentBattery);
            s.Write(mDropRateComm);
            s.Write(mErrorsComm);
            s.Write(mErrorsCount1);
            s.Write(mErrorsCount2);
            s.Write(mErrorsCount3);
            s.Write(mErrorsCount4);
            s.Write(mBatteryRemaining);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mOnboardControlSensorsPresent = (MavSysStatusSensor)s.ReadUInt32();
            this.mOnboardControlSensorsEnabled = (MavSysStatusSensor)s.ReadUInt32();
            this.mOnboardControlSensorsHealth = (MavSysStatusSensor)s.ReadUInt32();
            this.mLoad = s.ReadUInt16();
            this.mVoltageBattery = s.ReadUInt16();
            this.mCurrentBattery = s.ReadInt16();
            this.mDropRateComm = s.ReadUInt16();
            this.mErrorsComm = s.ReadUInt16();
            this.mErrorsCount1 = s.ReadUInt16();
            this.mErrorsCount2 = s.ReadUInt16();
            this.mErrorsCount3 = s.ReadUInt16();
            this.mErrorsCount4 = s.ReadUInt16();
            this.mBatteryRemaining = s.ReadSByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows wether the system is currently active or not and if an emergency occured. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occured it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OnboardControlSensorsPresent",
                Description = "Bitmask showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present. Indices defined by ENUM MAV_SYS_STATUS_SENSOR",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavSysStatusSensor"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OnboardControlSensorsEnabled",
                Description = "Bitmask showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavSysStatusSensor"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OnboardControlSensorsHealth",
                Description = "Bitmask showing which onboard controllers and sensors are operational or have an error:  Value of 0: not enabled. Value of 1: enabled. Indices defined by ENUM MAV_SYS_STATUS_SENSOR",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavSysStatusSensor"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Load",
                Description = "Maximum usage in percent of the mainloop time, (0%: 0, 100%: 1000) should be always below 1000",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VoltageBattery",
                Description = "Battery voltage, in millivolts (1 = 1 millivolt)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentBattery",
                Description = "Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DropRateComm",
                Description = "Communication drops in percent, (0%: 0, 100%: 10'000), (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorsComm",
                Description = "Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorsCount1",
                Description = "Autopilot-specific errors",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorsCount2",
                Description = "Autopilot-specific errors",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorsCount3",
                Description = "Autopilot-specific errors",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorsCount4",
                Description = "Autopilot-specific errors",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BatteryRemaining",
                Description = "Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot estimate the remaining battery",
                NumElements = 1,
            });

        }

        private MavSysStatusSensor mOnboardControlSensorsPresent;
        private MavSysStatusSensor mOnboardControlSensorsEnabled;
        private MavSysStatusSensor mOnboardControlSensorsHealth;
        private UInt16 mLoad;
        private UInt16 mVoltageBattery;
        private Int16 mCurrentBattery;
        private UInt16 mDropRateComm;
        private UInt16 mErrorsComm;
        private UInt16 mErrorsCount1;
        private UInt16 mErrorsCount2;
        private UInt16 mErrorsCount3;
        private UInt16 mErrorsCount4;
        private SByte mBatteryRemaining;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The system time is the time of the master clock, typically the computer clock of the main onboard computer.
    /// </summary>
    public class UasSystemTime: UasMessage
    {
        /// <summary>
        /// Timestamp of the master clock in microseconds since UNIX epoch.
        /// </summary>
        public UInt64 TimeUnixUsec {
            get { return mTimeUnixUsec; }
            set { mTimeUnixUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Timestamp of the component clock since boot time in milliseconds.
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        public UasSystemTime()
        {
            mMessageId = 2;
            CrcExtra = 137;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUnixUsec);
            s.Write(mTimeBootMs);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUnixUsec = s.ReadUInt64();
            this.mTimeBootMs = s.ReadUInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The system time is the time of the master clock, typically the computer clock of the main onboard computer."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUnixUsec",
                Description = "Timestamp of the master clock in microseconds since UNIX epoch.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp of the component clock since boot time in milliseconds.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUnixUsec;
        private UInt32 mTimeBootMs;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections.
    /// </summary>
    public class UasPing: UasMessage
    {
        /// <summary>
        /// Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PING sequence
        /// </summary>
        public UInt32 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasPing()
        {
            mMessageId = 4;
            CrcExtra = 237;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mSeq);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mSeq = s.ReadUInt32();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Unix timestamp in microseconds or since system boot if smaller than MAVLink epoch (1.1.2009)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "PING sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "0: request ping from all receiving systems, if greater than 0: message is a ping response and number is the system id of the requesting system",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "0: request ping from all receiving components, if greater than 0: message is a ping response and number is the system id of the requesting system",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt32 mSeq;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request to control this MAV
    /// </summary>
    public class UasChangeOperatorControl: UasMessage
    {
        /// <summary>
        /// System the GCS requests control for
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: request control of this MAV, 1: Release control of this MAV
        /// </summary>
        public byte ControlRequest {
            get { return mControlRequest; }
            set { mControlRequest = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.
        /// </summary>
        public byte Version {
            get { return mVersion; }
            set { mVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Password / Key, depending on version plaintext or encrypted. 25 or less characters, NULL terminated. The characters may involve A-Z, a-z, 0-9, and '!?,.-'
        /// </summary>
        public char[] Passkey {
            get { return mPasskey; }
            set { mPasskey = value; NotifyUpdated(); }
        }

        public UasChangeOperatorControl()
        {
            mMessageId = 5;
            CrcExtra = 217;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mControlRequest);
            s.Write(mVersion);
            s.Write(mPasskey[0]); 
            s.Write(mPasskey[1]); 
            s.Write(mPasskey[2]); 
            s.Write(mPasskey[3]); 
            s.Write(mPasskey[4]); 
            s.Write(mPasskey[5]); 
            s.Write(mPasskey[6]); 
            s.Write(mPasskey[7]); 
            s.Write(mPasskey[8]); 
            s.Write(mPasskey[9]); 
            s.Write(mPasskey[10]); 
            s.Write(mPasskey[11]); 
            s.Write(mPasskey[12]); 
            s.Write(mPasskey[13]); 
            s.Write(mPasskey[14]); 
            s.Write(mPasskey[15]); 
            s.Write(mPasskey[16]); 
            s.Write(mPasskey[17]); 
            s.Write(mPasskey[18]); 
            s.Write(mPasskey[19]); 
            s.Write(mPasskey[20]); 
            s.Write(mPasskey[21]); 
            s.Write(mPasskey[22]); 
            s.Write(mPasskey[23]); 
            s.Write(mPasskey[24]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mControlRequest = s.ReadByte();
            this.mVersion = s.ReadByte();
            this.mPasskey[0] = s.ReadChar();
            this.mPasskey[1] = s.ReadChar();
            this.mPasskey[2] = s.ReadChar();
            this.mPasskey[3] = s.ReadChar();
            this.mPasskey[4] = s.ReadChar();
            this.mPasskey[5] = s.ReadChar();
            this.mPasskey[6] = s.ReadChar();
            this.mPasskey[7] = s.ReadChar();
            this.mPasskey[8] = s.ReadChar();
            this.mPasskey[9] = s.ReadChar();
            this.mPasskey[10] = s.ReadChar();
            this.mPasskey[11] = s.ReadChar();
            this.mPasskey[12] = s.ReadChar();
            this.mPasskey[13] = s.ReadChar();
            this.mPasskey[14] = s.ReadChar();
            this.mPasskey[15] = s.ReadChar();
            this.mPasskey[16] = s.ReadChar();
            this.mPasskey[17] = s.ReadChar();
            this.mPasskey[18] = s.ReadChar();
            this.mPasskey[19] = s.ReadChar();
            this.mPasskey[20] = s.ReadChar();
            this.mPasskey[21] = s.ReadChar();
            this.mPasskey[22] = s.ReadChar();
            this.mPasskey[23] = s.ReadChar();
            this.mPasskey[24] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request to control this MAV"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System the GCS requests control for",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ControlRequest",
                Description = "0: request control of this MAV, 1: Release control of this MAV",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Version",
                Description = "0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Passkey",
                Description = "Password / Key, depending on version plaintext or encrypted. 25 or less characters, NULL terminated. The characters may involve A-Z, a-z, 0-9, and '!?,.-'",
                NumElements = 25,
            });

        }

        private byte mTargetSystem;
        private byte mControlRequest;
        private byte mVersion;
        private char[] mPasskey = new char[25];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Accept / deny control of this MAV
    /// </summary>
    public class UasChangeOperatorControlAck: UasMessage
    {
        /// <summary>
        /// ID of the GCS this message 
        /// </summary>
        public byte GcsSystemId {
            get { return mGcsSystemId; }
            set { mGcsSystemId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: request control of this MAV, 1: Release control of this MAV
        /// </summary>
        public byte ControlRequest {
            get { return mControlRequest; }
            set { mControlRequest = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control
        /// </summary>
        public byte Ack {
            get { return mAck; }
            set { mAck = value; NotifyUpdated(); }
        }

        public UasChangeOperatorControlAck()
        {
            mMessageId = 6;
            CrcExtra = 104;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mGcsSystemId);
            s.Write(mControlRequest);
            s.Write(mAck);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mGcsSystemId = s.ReadByte();
            this.mControlRequest = s.ReadByte();
            this.mAck = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Accept / deny control of this MAV"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GcsSystemId",
                Description = "ID of the GCS this message ",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ControlRequest",
                Description = "0: request control of this MAV, 1: Release control of this MAV",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ack",
                Description = "0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control",
                NumElements = 1,
            });

        }

        private byte mGcsSystemId;
        private byte mControlRequest;
        private byte mAck;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple, so transmitting the key requires an encrypted channel for true safety.
    /// </summary>
    public class UasAuthKey: UasMessage
    {
        /// <summary>
        /// key
        /// </summary>
        public char[] Key {
            get { return mKey; }
            set { mKey = value; NotifyUpdated(); }
        }

        public UasAuthKey()
        {
            mMessageId = 7;
            CrcExtra = 119;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mKey[0]); 
            s.Write(mKey[1]); 
            s.Write(mKey[2]); 
            s.Write(mKey[3]); 
            s.Write(mKey[4]); 
            s.Write(mKey[5]); 
            s.Write(mKey[6]); 
            s.Write(mKey[7]); 
            s.Write(mKey[8]); 
            s.Write(mKey[9]); 
            s.Write(mKey[10]); 
            s.Write(mKey[11]); 
            s.Write(mKey[12]); 
            s.Write(mKey[13]); 
            s.Write(mKey[14]); 
            s.Write(mKey[15]); 
            s.Write(mKey[16]); 
            s.Write(mKey[17]); 
            s.Write(mKey[18]); 
            s.Write(mKey[19]); 
            s.Write(mKey[20]); 
            s.Write(mKey[21]); 
            s.Write(mKey[22]); 
            s.Write(mKey[23]); 
            s.Write(mKey[24]); 
            s.Write(mKey[25]); 
            s.Write(mKey[26]); 
            s.Write(mKey[27]); 
            s.Write(mKey[28]); 
            s.Write(mKey[29]); 
            s.Write(mKey[30]); 
            s.Write(mKey[31]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mKey[0] = s.ReadChar();
            this.mKey[1] = s.ReadChar();
            this.mKey[2] = s.ReadChar();
            this.mKey[3] = s.ReadChar();
            this.mKey[4] = s.ReadChar();
            this.mKey[5] = s.ReadChar();
            this.mKey[6] = s.ReadChar();
            this.mKey[7] = s.ReadChar();
            this.mKey[8] = s.ReadChar();
            this.mKey[9] = s.ReadChar();
            this.mKey[10] = s.ReadChar();
            this.mKey[11] = s.ReadChar();
            this.mKey[12] = s.ReadChar();
            this.mKey[13] = s.ReadChar();
            this.mKey[14] = s.ReadChar();
            this.mKey[15] = s.ReadChar();
            this.mKey[16] = s.ReadChar();
            this.mKey[17] = s.ReadChar();
            this.mKey[18] = s.ReadChar();
            this.mKey[19] = s.ReadChar();
            this.mKey[20] = s.ReadChar();
            this.mKey[21] = s.ReadChar();
            this.mKey[22] = s.ReadChar();
            this.mKey[23] = s.ReadChar();
            this.mKey[24] = s.ReadChar();
            this.mKey[25] = s.ReadChar();
            this.mKey[26] = s.ReadChar();
            this.mKey[27] = s.ReadChar();
            this.mKey[28] = s.ReadChar();
            this.mKey[29] = s.ReadChar();
            this.mKey[30] = s.ReadChar();
            this.mKey[31] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple, so transmitting the key requires an encrypted channel for true safety."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Key",
                Description = "key",
                NumElements = 32,
            });

        }

        private char[] mKey = new char[32];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// THIS INTERFACE IS DEPRECATED. USE COMMAND_LONG with MAV_CMD_DO_SET_MODE INSTEAD. Set the system mode, as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall aircraft, not only for one component.
    /// </summary>
    public class UasSetMode: UasMessage
    {
        /// <summary>
        /// The new autopilot-specific mode. This field can be ignored by an autopilot.
        /// </summary>
        public UInt32 CustomMode {
            get { return mCustomMode; }
            set { mCustomMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The system setting the mode
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The new base mode
        /// </summary>
        public byte BaseMode {
            get { return mBaseMode; }
            set { mBaseMode = value; NotifyUpdated(); }
        }

        public UasSetMode()
        {
            mMessageId = 11;
            CrcExtra = 89;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mCustomMode);
            s.Write(mTargetSystem);
            s.Write(mBaseMode);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mCustomMode = s.ReadUInt32();
            this.mTargetSystem = s.ReadByte();
            this.mBaseMode = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "THIS INTERFACE IS DEPRECATED. USE COMMAND_LONG with MAV_CMD_DO_SET_MODE INSTEAD. Set the system mode, as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall aircraft, not only for one component."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CustomMode",
                Description = "The new autopilot-specific mode. This field can be ignored by an autopilot.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "The system setting the mode",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaseMode",
                Description = "The new base mode",
                NumElements = 1,
            });

        }

        private UInt32 mCustomMode;
        private byte mTargetSystem;
        private byte mBaseMode;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request to read the onboard parameter with the param_id string id. Onboard parameters are stored as key[const char*] -> value[float]. This allows to send a parameter to any other component (such as the GCS) without the need of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for different autopilots. See also http://qgroundcontrol.org/parameter_interface for a full documentation of QGroundControl and IMU code.
    /// </summary>
    public class UasParamRequestRead: UasMessage
    {
        /// <summary>
        /// Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
        /// </summary>
        public Int16 ParamIndex {
            get { return mParamIndex; }
            set { mParamIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
        /// </summary>
        public char[] ParamId {
            get { return mParamId; }
            set { mParamId = value; NotifyUpdated(); }
        }

        public UasParamRequestRead()
        {
            mMessageId = 20;
            CrcExtra = 214;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mParamIndex);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mParamId[0]); 
            s.Write(mParamId[1]); 
            s.Write(mParamId[2]); 
            s.Write(mParamId[3]); 
            s.Write(mParamId[4]); 
            s.Write(mParamId[5]); 
            s.Write(mParamId[6]); 
            s.Write(mParamId[7]); 
            s.Write(mParamId[8]); 
            s.Write(mParamId[9]); 
            s.Write(mParamId[10]); 
            s.Write(mParamId[11]); 
            s.Write(mParamId[12]); 
            s.Write(mParamId[13]); 
            s.Write(mParamId[14]); 
            s.Write(mParamId[15]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mParamIndex = s.ReadInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mParamId[0] = s.ReadChar();
            this.mParamId[1] = s.ReadChar();
            this.mParamId[2] = s.ReadChar();
            this.mParamId[3] = s.ReadChar();
            this.mParamId[4] = s.ReadChar();
            this.mParamId[5] = s.ReadChar();
            this.mParamId[6] = s.ReadChar();
            this.mParamId[7] = s.ReadChar();
            this.mParamId[8] = s.ReadChar();
            this.mParamId[9] = s.ReadChar();
            this.mParamId[10] = s.ReadChar();
            this.mParamId[11] = s.ReadChar();
            this.mParamId[12] = s.ReadChar();
            this.mParamId[13] = s.ReadChar();
            this.mParamId[14] = s.ReadChar();
            this.mParamId[15] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request to read the onboard parameter with the param_id string id. Onboard parameters are stored as key[const char*] -> value[float]. This allows to send a parameter to any other component (such as the GCS) without the need of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for different autopilots. See also http://qgroundcontrol.org/parameter_interface for a full documentation of QGroundControl and IMU code."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamIndex",
                Description = "Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamId",
                Description = "Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string",
                NumElements = 16,
            });

        }

        private Int16 mParamIndex;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private char[] mParamId = new char[16];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request all parameters of this component. After this request, all parameters are emitted.
    /// </summary>
    public class UasParamRequestList: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasParamRequestList()
        {
            mMessageId = 21;
            CrcExtra = 159;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request all parameters of this component. After this request, all parameters are emitted."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows him to re-request missing parameters after a loss or timeout.
    /// </summary>
    public class UasParamValue: UasMessage
    {
        /// <summary>
        /// Onboard parameter value
        /// </summary>
        public float ParamValue {
            get { return mParamValue; }
            set { mParamValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Total number of onboard parameters
        /// </summary>
        public UInt16 ParamCount {
            get { return mParamCount; }
            set { mParamCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Index of this onboard parameter
        /// </summary>
        public UInt16 ParamIndex {
            get { return mParamIndex; }
            set { mParamIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
        /// </summary>
        public char[] ParamId {
            get { return mParamId; }
            set { mParamId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
        /// </summary>
        public MavParamType ParamType {
            get { return mParamType; }
            set { mParamType = value; NotifyUpdated(); }
        }

        public UasParamValue()
        {
            mMessageId = 22;
            CrcExtra = 220;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mParamValue);
            s.Write(mParamCount);
            s.Write(mParamIndex);
            s.Write(mParamId[0]); 
            s.Write(mParamId[1]); 
            s.Write(mParamId[2]); 
            s.Write(mParamId[3]); 
            s.Write(mParamId[4]); 
            s.Write(mParamId[5]); 
            s.Write(mParamId[6]); 
            s.Write(mParamId[7]); 
            s.Write(mParamId[8]); 
            s.Write(mParamId[9]); 
            s.Write(mParamId[10]); 
            s.Write(mParamId[11]); 
            s.Write(mParamId[12]); 
            s.Write(mParamId[13]); 
            s.Write(mParamId[14]); 
            s.Write(mParamId[15]); 
            s.Write((byte)mParamType);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mParamValue = s.ReadSingle();
            this.mParamCount = s.ReadUInt16();
            this.mParamIndex = s.ReadUInt16();
            this.mParamId[0] = s.ReadChar();
            this.mParamId[1] = s.ReadChar();
            this.mParamId[2] = s.ReadChar();
            this.mParamId[3] = s.ReadChar();
            this.mParamId[4] = s.ReadChar();
            this.mParamId[5] = s.ReadChar();
            this.mParamId[6] = s.ReadChar();
            this.mParamId[7] = s.ReadChar();
            this.mParamId[8] = s.ReadChar();
            this.mParamId[9] = s.ReadChar();
            this.mParamId[10] = s.ReadChar();
            this.mParamId[11] = s.ReadChar();
            this.mParamId[12] = s.ReadChar();
            this.mParamId[13] = s.ReadChar();
            this.mParamId[14] = s.ReadChar();
            this.mParamId[15] = s.ReadChar();
            this.mParamType = (MavParamType)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows him to re-request missing parameters after a loss or timeout."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamValue",
                Description = "Onboard parameter value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamCount",
                Description = "Total number of onboard parameters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamIndex",
                Description = "Index of this onboard parameter",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamId",
                Description = "Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string",
                NumElements = 16,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamType",
                Description = "Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavParamType"),
            });

        }

        private float mParamValue;
        private UInt16 mParamCount;
        private UInt16 mParamIndex;
        private char[] mParamId = new char[16];
        private MavParamType mParamType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set a parameter value TEMPORARILY to RAM. It will be reset to default on system reboot. Send the ACTION MAV_ACTION_STORAGE_WRITE to PERMANENTLY write the RAM contents to EEPROM. IMPORTANT: The receiving component should acknowledge the new parameter value by sending a param_value message to all communication partners. This will also ensure that multiple GCS all have an up-to-date list of all parameters. If the sending GCS did not receive a PARAM_VALUE message within its timeout time, it should re-send the PARAM_SET message.
    /// </summary>
    public class UasParamSet: UasMessage
    {
        /// <summary>
        /// Onboard parameter value
        /// </summary>
        public float ParamValue {
            get { return mParamValue; }
            set { mParamValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
        /// </summary>
        public char[] ParamId {
            get { return mParamId; }
            set { mParamId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.
        /// </summary>
        public MavParamType ParamType {
            get { return mParamType; }
            set { mParamType = value; NotifyUpdated(); }
        }

        public UasParamSet()
        {
            mMessageId = 23;
            CrcExtra = 168;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mParamValue);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mParamId[0]); 
            s.Write(mParamId[1]); 
            s.Write(mParamId[2]); 
            s.Write(mParamId[3]); 
            s.Write(mParamId[4]); 
            s.Write(mParamId[5]); 
            s.Write(mParamId[6]); 
            s.Write(mParamId[7]); 
            s.Write(mParamId[8]); 
            s.Write(mParamId[9]); 
            s.Write(mParamId[10]); 
            s.Write(mParamId[11]); 
            s.Write(mParamId[12]); 
            s.Write(mParamId[13]); 
            s.Write(mParamId[14]); 
            s.Write(mParamId[15]); 
            s.Write((byte)mParamType);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mParamValue = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mParamId[0] = s.ReadChar();
            this.mParamId[1] = s.ReadChar();
            this.mParamId[2] = s.ReadChar();
            this.mParamId[3] = s.ReadChar();
            this.mParamId[4] = s.ReadChar();
            this.mParamId[5] = s.ReadChar();
            this.mParamId[6] = s.ReadChar();
            this.mParamId[7] = s.ReadChar();
            this.mParamId[8] = s.ReadChar();
            this.mParamId[9] = s.ReadChar();
            this.mParamId[10] = s.ReadChar();
            this.mParamId[11] = s.ReadChar();
            this.mParamId[12] = s.ReadChar();
            this.mParamId[13] = s.ReadChar();
            this.mParamId[14] = s.ReadChar();
            this.mParamId[15] = s.ReadChar();
            this.mParamType = (MavParamType)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set a parameter value TEMPORARILY to RAM. It will be reset to default on system reboot. Send the ACTION MAV_ACTION_STORAGE_WRITE to PERMANENTLY write the RAM contents to EEPROM. IMPORTANT: The receiving component should acknowledge the new parameter value by sending a param_value message to all communication partners. This will also ensure that multiple GCS all have an up-to-date list of all parameters. If the sending GCS did not receive a PARAM_VALUE message within its timeout time, it should re-send the PARAM_SET message."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamValue",
                Description = "Onboard parameter value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamId",
                Description = "Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string",
                NumElements = 16,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamType",
                Description = "Onboard parameter type: see the MAV_PARAM_TYPE enum for supported data types.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavParamType"),
            });

        }

        private float mParamValue;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private char[] mParamId = new char[16];
        private MavParamType mParamType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The global position, as returned by the Global Positioning System (GPS). This is                 NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame).
    /// </summary>
    public class UasGpsRawInt: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch or microseconds since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (AMSL, NOT WGS84), in meters * 1000 (positive for up). Note that virtually all GPS modules provide the AMSL altitude in addition to the WGS84 altitude.
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS HDOP horizontal dilution of position (unitless). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Eph {
            get { return mEph; }
            set { mEph = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS VDOP vertical dilution of position (unitless). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Epv {
            get { return mEpv; }
            set { mEpv = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Vel {
            get { return mVel; }
            set { mVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Cog {
            get { return mCog; }
            set { mCog = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
        /// </summary>
        public byte FixType {
            get { return mFixType; }
            set { mFixType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of satellites visible. If unknown, set to 255
        /// </summary>
        public byte SatellitesVisible {
            get { return mSatellitesVisible; }
            set { mSatellitesVisible = value; NotifyUpdated(); }
        }

        public UasGpsRawInt()
        {
            mMessageId = 24;
            CrcExtra = 24;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mEph);
            s.Write(mEpv);
            s.Write(mVel);
            s.Write(mCog);
            s.Write(mFixType);
            s.Write(mSatellitesVisible);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mEph = s.ReadUInt16();
            this.mEpv = s.ReadUInt16();
            this.mVel = s.ReadUInt16();
            this.mCog = s.ReadUInt16();
            this.mFixType = s.ReadByte();
            this.mSatellitesVisible = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The global position, as returned by the Global Positioning System (GPS). This is                 NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds since UNIX epoch or microseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (AMSL, NOT WGS84), in meters * 1000 (positive for up). Note that virtually all GPS modules provide the AMSL altitude in addition to the WGS84 altitude.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Eph",
                Description = "GPS HDOP horizontal dilution of position (unitless). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Epv",
                Description = "GPS VDOP vertical dilution of position (unitless). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vel",
                Description = "GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Cog",
                Description = "Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FixType",
                Description = "0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitesVisible",
                Description = "Number of satellites visible. If unknown, set to 255",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private UInt16 mEph;
        private UInt16 mEpv;
        private UInt16 mVel;
        private UInt16 mCog;
        private byte mFixType;
        private byte mSatellitesVisible;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The positioning status, as reported by GPS. This message is intended to display status information about each satellite visible to the receiver. See message GLOBAL_POSITION for the global position estimate. This message can contain information for up to 20 satellites.
    /// </summary>
    public class UasGpsStatus: UasMessage
    {
        /// <summary>
        /// Number of satellites visible
        /// </summary>
        public byte SatellitesVisible {
            get { return mSatellitesVisible; }
            set { mSatellitesVisible = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global satellite ID
        /// </summary>
        public byte[] SatellitePrn {
            get { return mSatellitePrn; }
            set { mSatellitePrn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: Satellite not used, 1: used for localization
        /// </summary>
        public byte[] SatelliteUsed {
            get { return mSatelliteUsed; }
            set { mSatelliteUsed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Elevation (0: right on top of receiver, 90: on the horizon) of satellite
        /// </summary>
        public byte[] SatelliteElevation {
            get { return mSatelliteElevation; }
            set { mSatelliteElevation = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Direction of satellite, 0: 0 deg, 255: 360 deg.
        /// </summary>
        public byte[] SatelliteAzimuth {
            get { return mSatelliteAzimuth; }
            set { mSatelliteAzimuth = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Signal to noise ratio of satellite
        /// </summary>
        public byte[] SatelliteSnr {
            get { return mSatelliteSnr; }
            set { mSatelliteSnr = value; NotifyUpdated(); }
        }

        public UasGpsStatus()
        {
            mMessageId = 25;
            CrcExtra = 23;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mSatellitesVisible);
            s.Write(mSatellitePrn[0]); 
            s.Write(mSatellitePrn[1]); 
            s.Write(mSatellitePrn[2]); 
            s.Write(mSatellitePrn[3]); 
            s.Write(mSatellitePrn[4]); 
            s.Write(mSatellitePrn[5]); 
            s.Write(mSatellitePrn[6]); 
            s.Write(mSatellitePrn[7]); 
            s.Write(mSatellitePrn[8]); 
            s.Write(mSatellitePrn[9]); 
            s.Write(mSatellitePrn[10]); 
            s.Write(mSatellitePrn[11]); 
            s.Write(mSatellitePrn[12]); 
            s.Write(mSatellitePrn[13]); 
            s.Write(mSatellitePrn[14]); 
            s.Write(mSatellitePrn[15]); 
            s.Write(mSatellitePrn[16]); 
            s.Write(mSatellitePrn[17]); 
            s.Write(mSatellitePrn[18]); 
            s.Write(mSatellitePrn[19]); 
            s.Write(mSatelliteUsed[0]); 
            s.Write(mSatelliteUsed[1]); 
            s.Write(mSatelliteUsed[2]); 
            s.Write(mSatelliteUsed[3]); 
            s.Write(mSatelliteUsed[4]); 
            s.Write(mSatelliteUsed[5]); 
            s.Write(mSatelliteUsed[6]); 
            s.Write(mSatelliteUsed[7]); 
            s.Write(mSatelliteUsed[8]); 
            s.Write(mSatelliteUsed[9]); 
            s.Write(mSatelliteUsed[10]); 
            s.Write(mSatelliteUsed[11]); 
            s.Write(mSatelliteUsed[12]); 
            s.Write(mSatelliteUsed[13]); 
            s.Write(mSatelliteUsed[14]); 
            s.Write(mSatelliteUsed[15]); 
            s.Write(mSatelliteUsed[16]); 
            s.Write(mSatelliteUsed[17]); 
            s.Write(mSatelliteUsed[18]); 
            s.Write(mSatelliteUsed[19]); 
            s.Write(mSatelliteElevation[0]); 
            s.Write(mSatelliteElevation[1]); 
            s.Write(mSatelliteElevation[2]); 
            s.Write(mSatelliteElevation[3]); 
            s.Write(mSatelliteElevation[4]); 
            s.Write(mSatelliteElevation[5]); 
            s.Write(mSatelliteElevation[6]); 
            s.Write(mSatelliteElevation[7]); 
            s.Write(mSatelliteElevation[8]); 
            s.Write(mSatelliteElevation[9]); 
            s.Write(mSatelliteElevation[10]); 
            s.Write(mSatelliteElevation[11]); 
            s.Write(mSatelliteElevation[12]); 
            s.Write(mSatelliteElevation[13]); 
            s.Write(mSatelliteElevation[14]); 
            s.Write(mSatelliteElevation[15]); 
            s.Write(mSatelliteElevation[16]); 
            s.Write(mSatelliteElevation[17]); 
            s.Write(mSatelliteElevation[18]); 
            s.Write(mSatelliteElevation[19]); 
            s.Write(mSatelliteAzimuth[0]); 
            s.Write(mSatelliteAzimuth[1]); 
            s.Write(mSatelliteAzimuth[2]); 
            s.Write(mSatelliteAzimuth[3]); 
            s.Write(mSatelliteAzimuth[4]); 
            s.Write(mSatelliteAzimuth[5]); 
            s.Write(mSatelliteAzimuth[6]); 
            s.Write(mSatelliteAzimuth[7]); 
            s.Write(mSatelliteAzimuth[8]); 
            s.Write(mSatelliteAzimuth[9]); 
            s.Write(mSatelliteAzimuth[10]); 
            s.Write(mSatelliteAzimuth[11]); 
            s.Write(mSatelliteAzimuth[12]); 
            s.Write(mSatelliteAzimuth[13]); 
            s.Write(mSatelliteAzimuth[14]); 
            s.Write(mSatelliteAzimuth[15]); 
            s.Write(mSatelliteAzimuth[16]); 
            s.Write(mSatelliteAzimuth[17]); 
            s.Write(mSatelliteAzimuth[18]); 
            s.Write(mSatelliteAzimuth[19]); 
            s.Write(mSatelliteSnr[0]); 
            s.Write(mSatelliteSnr[1]); 
            s.Write(mSatelliteSnr[2]); 
            s.Write(mSatelliteSnr[3]); 
            s.Write(mSatelliteSnr[4]); 
            s.Write(mSatelliteSnr[5]); 
            s.Write(mSatelliteSnr[6]); 
            s.Write(mSatelliteSnr[7]); 
            s.Write(mSatelliteSnr[8]); 
            s.Write(mSatelliteSnr[9]); 
            s.Write(mSatelliteSnr[10]); 
            s.Write(mSatelliteSnr[11]); 
            s.Write(mSatelliteSnr[12]); 
            s.Write(mSatelliteSnr[13]); 
            s.Write(mSatelliteSnr[14]); 
            s.Write(mSatelliteSnr[15]); 
            s.Write(mSatelliteSnr[16]); 
            s.Write(mSatelliteSnr[17]); 
            s.Write(mSatelliteSnr[18]); 
            s.Write(mSatelliteSnr[19]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSatellitesVisible = s.ReadByte();
            this.mSatellitePrn[0] = s.ReadByte();
            this.mSatellitePrn[1] = s.ReadByte();
            this.mSatellitePrn[2] = s.ReadByte();
            this.mSatellitePrn[3] = s.ReadByte();
            this.mSatellitePrn[4] = s.ReadByte();
            this.mSatellitePrn[5] = s.ReadByte();
            this.mSatellitePrn[6] = s.ReadByte();
            this.mSatellitePrn[7] = s.ReadByte();
            this.mSatellitePrn[8] = s.ReadByte();
            this.mSatellitePrn[9] = s.ReadByte();
            this.mSatellitePrn[10] = s.ReadByte();
            this.mSatellitePrn[11] = s.ReadByte();
            this.mSatellitePrn[12] = s.ReadByte();
            this.mSatellitePrn[13] = s.ReadByte();
            this.mSatellitePrn[14] = s.ReadByte();
            this.mSatellitePrn[15] = s.ReadByte();
            this.mSatellitePrn[16] = s.ReadByte();
            this.mSatellitePrn[17] = s.ReadByte();
            this.mSatellitePrn[18] = s.ReadByte();
            this.mSatellitePrn[19] = s.ReadByte();
            this.mSatelliteUsed[0] = s.ReadByte();
            this.mSatelliteUsed[1] = s.ReadByte();
            this.mSatelliteUsed[2] = s.ReadByte();
            this.mSatelliteUsed[3] = s.ReadByte();
            this.mSatelliteUsed[4] = s.ReadByte();
            this.mSatelliteUsed[5] = s.ReadByte();
            this.mSatelliteUsed[6] = s.ReadByte();
            this.mSatelliteUsed[7] = s.ReadByte();
            this.mSatelliteUsed[8] = s.ReadByte();
            this.mSatelliteUsed[9] = s.ReadByte();
            this.mSatelliteUsed[10] = s.ReadByte();
            this.mSatelliteUsed[11] = s.ReadByte();
            this.mSatelliteUsed[12] = s.ReadByte();
            this.mSatelliteUsed[13] = s.ReadByte();
            this.mSatelliteUsed[14] = s.ReadByte();
            this.mSatelliteUsed[15] = s.ReadByte();
            this.mSatelliteUsed[16] = s.ReadByte();
            this.mSatelliteUsed[17] = s.ReadByte();
            this.mSatelliteUsed[18] = s.ReadByte();
            this.mSatelliteUsed[19] = s.ReadByte();
            this.mSatelliteElevation[0] = s.ReadByte();
            this.mSatelliteElevation[1] = s.ReadByte();
            this.mSatelliteElevation[2] = s.ReadByte();
            this.mSatelliteElevation[3] = s.ReadByte();
            this.mSatelliteElevation[4] = s.ReadByte();
            this.mSatelliteElevation[5] = s.ReadByte();
            this.mSatelliteElevation[6] = s.ReadByte();
            this.mSatelliteElevation[7] = s.ReadByte();
            this.mSatelliteElevation[8] = s.ReadByte();
            this.mSatelliteElevation[9] = s.ReadByte();
            this.mSatelliteElevation[10] = s.ReadByte();
            this.mSatelliteElevation[11] = s.ReadByte();
            this.mSatelliteElevation[12] = s.ReadByte();
            this.mSatelliteElevation[13] = s.ReadByte();
            this.mSatelliteElevation[14] = s.ReadByte();
            this.mSatelliteElevation[15] = s.ReadByte();
            this.mSatelliteElevation[16] = s.ReadByte();
            this.mSatelliteElevation[17] = s.ReadByte();
            this.mSatelliteElevation[18] = s.ReadByte();
            this.mSatelliteElevation[19] = s.ReadByte();
            this.mSatelliteAzimuth[0] = s.ReadByte();
            this.mSatelliteAzimuth[1] = s.ReadByte();
            this.mSatelliteAzimuth[2] = s.ReadByte();
            this.mSatelliteAzimuth[3] = s.ReadByte();
            this.mSatelliteAzimuth[4] = s.ReadByte();
            this.mSatelliteAzimuth[5] = s.ReadByte();
            this.mSatelliteAzimuth[6] = s.ReadByte();
            this.mSatelliteAzimuth[7] = s.ReadByte();
            this.mSatelliteAzimuth[8] = s.ReadByte();
            this.mSatelliteAzimuth[9] = s.ReadByte();
            this.mSatelliteAzimuth[10] = s.ReadByte();
            this.mSatelliteAzimuth[11] = s.ReadByte();
            this.mSatelliteAzimuth[12] = s.ReadByte();
            this.mSatelliteAzimuth[13] = s.ReadByte();
            this.mSatelliteAzimuth[14] = s.ReadByte();
            this.mSatelliteAzimuth[15] = s.ReadByte();
            this.mSatelliteAzimuth[16] = s.ReadByte();
            this.mSatelliteAzimuth[17] = s.ReadByte();
            this.mSatelliteAzimuth[18] = s.ReadByte();
            this.mSatelliteAzimuth[19] = s.ReadByte();
            this.mSatelliteSnr[0] = s.ReadByte();
            this.mSatelliteSnr[1] = s.ReadByte();
            this.mSatelliteSnr[2] = s.ReadByte();
            this.mSatelliteSnr[3] = s.ReadByte();
            this.mSatelliteSnr[4] = s.ReadByte();
            this.mSatelliteSnr[5] = s.ReadByte();
            this.mSatelliteSnr[6] = s.ReadByte();
            this.mSatelliteSnr[7] = s.ReadByte();
            this.mSatelliteSnr[8] = s.ReadByte();
            this.mSatelliteSnr[9] = s.ReadByte();
            this.mSatelliteSnr[10] = s.ReadByte();
            this.mSatelliteSnr[11] = s.ReadByte();
            this.mSatelliteSnr[12] = s.ReadByte();
            this.mSatelliteSnr[13] = s.ReadByte();
            this.mSatelliteSnr[14] = s.ReadByte();
            this.mSatelliteSnr[15] = s.ReadByte();
            this.mSatelliteSnr[16] = s.ReadByte();
            this.mSatelliteSnr[17] = s.ReadByte();
            this.mSatelliteSnr[18] = s.ReadByte();
            this.mSatelliteSnr[19] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The positioning status, as reported by GPS. This message is intended to display status information about each satellite visible to the receiver. See message GLOBAL_POSITION for the global position estimate. This message can contain information for up to 20 satellites."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitesVisible",
                Description = "Number of satellites visible",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitePrn",
                Description = "Global satellite ID",
                NumElements = 20,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatelliteUsed",
                Description = "0: Satellite not used, 1: used for localization",
                NumElements = 20,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatelliteElevation",
                Description = "Elevation (0: right on top of receiver, 90: on the horizon) of satellite",
                NumElements = 20,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatelliteAzimuth",
                Description = "Direction of satellite, 0: 0 deg, 255: 360 deg.",
                NumElements = 20,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatelliteSnr",
                Description = "Signal to noise ratio of satellite",
                NumElements = 20,
            });

        }

        private byte mSatellitesVisible;
        private byte[] mSatellitePrn = new byte[20];
        private byte[] mSatelliteUsed = new byte[20];
        private byte[] mSatelliteElevation = new byte[20];
        private byte[] mSatelliteAzimuth = new byte[20];
        private byte[] mSatelliteSnr = new byte[20];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to the described units
    /// </summary>
    public class UasScaledImu: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration (mg)
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration (mg)
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration (mg)
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis (millirad /sec)
        /// </summary>
        public Int16 Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis (millirad /sec)
        /// </summary>
        public Int16 Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis (millirad /sec)
        /// </summary>
        public Int16 Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field (milli tesla)
        /// </summary>
        public Int16 Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field (milli tesla)
        /// </summary>
        public Int16 Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field (milli tesla)
        /// </summary>
        public Int16 Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        public UasScaledImu()
        {
            mMessageId = 26;
            CrcExtra = 170;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
            this.mXgyro = s.ReadInt16();
            this.mYgyro = s.ReadInt16();
            this.mZgyro = s.ReadInt16();
            this.mXmag = s.ReadInt16();
            this.mYmag = s.ReadInt16();
            this.mZmag = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to the described units"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis (millirad /sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis (millirad /sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis (millirad /sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field (milli tesla)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field (milli tesla)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field (milli tesla)",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
        private Int16 mXgyro;
        private Int16 mYgyro;
        private Int16 mZgyro;
        private Int16 mXmag;
        private Int16 mYmag;
        private Int16 mZmag;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW IMU readings for the usual 9DOF sensor setup. This message should always contain the true raw values without any scaling to allow data capture and system debugging.
    /// </summary>
    public class UasRawImu: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch or microseconds since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration (raw)
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration (raw)
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration (raw)
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis (raw)
        /// </summary>
        public Int16 Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis (raw)
        /// </summary>
        public Int16 Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis (raw)
        /// </summary>
        public Int16 Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field (raw)
        /// </summary>
        public Int16 Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field (raw)
        /// </summary>
        public Int16 Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field (raw)
        /// </summary>
        public Int16 Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        public UasRawImu()
        {
            mMessageId = 27;
            CrcExtra = 144;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
            this.mXgyro = s.ReadInt16();
            this.mYgyro = s.ReadInt16();
            this.mZgyro = s.ReadInt16();
            this.mXmag = s.ReadInt16();
            this.mYmag = s.ReadInt16();
            this.mZmag = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW IMU readings for the usual 9DOF sensor setup. This message should always contain the true raw values without any scaling to allow data capture and system debugging."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds since UNIX epoch or microseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field (raw)",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
        private Int16 mXgyro;
        private Int16 mYgyro;
        private Int16 mZgyro;
        private Int16 mXmag;
        private Int16 mYmag;
        private Int16 mZmag;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure sensor. The sensor values should be the raw, UNSCALED ADC values.
    /// </summary>
    public class UasRawPressure: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch or microseconds since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure (raw)
        /// </summary>
        public Int16 PressAbs {
            get { return mPressAbs; }
            set { mPressAbs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure 1 (raw, 0 if nonexistant)
        /// </summary>
        public Int16 PressDiff1 {
            get { return mPressDiff1; }
            set { mPressDiff1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure 2 (raw, 0 if nonexistant)
        /// </summary>
        public Int16 PressDiff2 {
            get { return mPressDiff2; }
            set { mPressDiff2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Raw Temperature measurement (raw)
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        public UasRawPressure()
        {
            mMessageId = 28;
            CrcExtra = 67;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mPressAbs);
            s.Write(mPressDiff1);
            s.Write(mPressDiff2);
            s.Write(mTemperature);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mPressAbs = s.ReadInt16();
            this.mPressDiff1 = s.ReadInt16();
            this.mPressDiff2 = s.ReadInt16();
            this.mTemperature = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure sensor. The sensor values should be the raw, UNSCALED ADC values."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds since UNIX epoch or microseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressAbs",
                Description = "Absolute pressure (raw)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressDiff1",
                Description = "Differential pressure 1 (raw, 0 if nonexistant)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressDiff2",
                Description = "Differential pressure 2 (raw, 0 if nonexistant)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Raw Temperature measurement (raw)",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private Int16 mPressAbs;
        private Int16 mPressDiff1;
        private Int16 mPressDiff2;
        private Int16 mTemperature;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The pressure readings for the typical setup of one absolute and differential pressure sensor. The units are as specified in each field.
    /// </summary>
    public class UasScaledPressure: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure (hectopascal)
        /// </summary>
        public float PressAbs {
            get { return mPressAbs; }
            set { mPressAbs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure 1 (hectopascal)
        /// </summary>
        public float PressDiff {
            get { return mPressDiff; }
            set { mPressDiff = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature measurement (0.01 degrees celsius)
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        public UasScaledPressure()
        {
            mMessageId = 29;
            CrcExtra = 115;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mPressAbs);
            s.Write(mPressDiff);
            s.Write(mTemperature);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mPressAbs = s.ReadSingle();
            this.mPressDiff = s.ReadSingle();
            this.mTemperature = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The pressure readings for the typical setup of one absolute and differential pressure sensor. The units are as specified in each field."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressAbs",
                Description = "Absolute pressure (hectopascal)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressDiff",
                Description = "Differential pressure 1 (hectopascal)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature measurement (0.01 degrees celsius)",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mPressAbs;
        private float mPressDiff;
        private Int16 mTemperature;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right).
    /// </summary>
    public class UasAttitude: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angle (rad, -pi..+pi)
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle (rad, -pi..+pi)
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle (rad, -pi..+pi)
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angular speed (rad/s)
        /// </summary>
        public float Rollspeed {
            get { return mRollspeed; }
            set { mRollspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angular speed (rad/s)
        /// </summary>
        public float Pitchspeed {
            get { return mPitchspeed; }
            set { mPitchspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angular speed (rad/s)
        /// </summary>
        public float Yawspeed {
            get { return mYawspeed; }
            set { mYawspeed = value; NotifyUpdated(); }
        }

        public UasAttitude()
        {
            mMessageId = 30;
            CrcExtra = 39;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mRollspeed);
            s.Write(mPitchspeed);
            s.Write(mYawspeed);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mRollspeed = s.ReadSingle();
            this.mPitchspeed = s.ReadSingle();
            this.mYawspeed = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle (rad, -pi..+pi)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle (rad, -pi..+pi)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle (rad, -pi..+pi)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rollspeed",
                Description = "Roll angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitchspeed",
                Description = "Pitch angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yawspeed",
                Description = "Yaw angular speed (rad/s)",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mRollspeed;
        private float mPitchspeed;
        private float mYawspeed;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
    /// </summary>
    public class UasAttitudeQuaternion: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Quaternion component 1, w (1 in null-rotation)
        /// </summary>
        public float Q1 {
            get { return mQ1; }
            set { mQ1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Quaternion component 2, x (0 in null-rotation)
        /// </summary>
        public float Q2 {
            get { return mQ2; }
            set { mQ2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Quaternion component 3, y (0 in null-rotation)
        /// </summary>
        public float Q3 {
            get { return mQ3; }
            set { mQ3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Quaternion component 4, z (0 in null-rotation)
        /// </summary>
        public float Q4 {
            get { return mQ4; }
            set { mQ4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angular speed (rad/s)
        /// </summary>
        public float Rollspeed {
            get { return mRollspeed; }
            set { mRollspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angular speed (rad/s)
        /// </summary>
        public float Pitchspeed {
            get { return mPitchspeed; }
            set { mPitchspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angular speed (rad/s)
        /// </summary>
        public float Yawspeed {
            get { return mYawspeed; }
            set { mYawspeed = value; NotifyUpdated(); }
        }

        public UasAttitudeQuaternion()
        {
            mMessageId = 31;
            CrcExtra = 246;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mQ1);
            s.Write(mQ2);
            s.Write(mQ3);
            s.Write(mQ4);
            s.Write(mRollspeed);
            s.Write(mPitchspeed);
            s.Write(mYawspeed);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mQ1 = s.ReadSingle();
            this.mQ2 = s.ReadSingle();
            this.mQ3 = s.ReadSingle();
            this.mQ4 = s.ReadSingle();
            this.mRollspeed = s.ReadSingle();
            this.mPitchspeed = s.ReadSingle();
            this.mYawspeed = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q1",
                Description = "Quaternion component 1, w (1 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q2",
                Description = "Quaternion component 2, x (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q3",
                Description = "Quaternion component 3, y (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q4",
                Description = "Quaternion component 4, z (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rollspeed",
                Description = "Roll angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitchspeed",
                Description = "Pitch angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yawspeed",
                Description = "Yaw angular speed (rad/s)",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mQ1;
        private float mQ2;
        private float mQ3;
        private float mQ4;
        private float mRollspeed;
        private float mPitchspeed;
        private float mYawspeed;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
    /// </summary>
    public class UasLocalPositionNed: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Speed
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Speed
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Speed
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        public UasLocalPositionNed()
        {
            mMessageId = 32;
            CrcExtra = 185;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X Speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y Speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z Speed",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mX;
        private float mY;
        private float mZ;
        private float mVx;
        private float mVy;
        private float mVz;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It                is designed as scaled integer message since the resolution of float is not sufficient.
    /// </summary>
    public class UasGlobalPositionInt: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude, expressed as degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude, expressed as degrees * 1E7
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude in meters, expressed as * 1000 (millimeters), AMSL (not WGS84 - note that virtually all GPS modules provide the AMSL as well)
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude above ground in meters, expressed as * 1000 (millimeters)
        /// </summary>
        public Int32 RelativeAlt {
            get { return mRelativeAlt; }
            set { mRelativeAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground X Speed (Latitude, positive north), expressed as m/s * 100
        /// </summary>
        public Int16 Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Y Speed (Longitude, positive east), expressed as m/s * 100
        /// </summary>
        public Int16 Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Z Speed (Altitude, positive down), expressed as m/s * 100
        /// </summary>
        public Int16 Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vehicle heading (yaw angle) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Hdg {
            get { return mHdg; }
            set { mHdg = value; NotifyUpdated(); }
        }

        public UasGlobalPositionInt()
        {
            mMessageId = 33;
            CrcExtra = 104;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mRelativeAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mHdg);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mRelativeAlt = s.ReadInt32();
            this.mVx = s.ReadInt16();
            this.mVy = s.ReadInt16();
            this.mVz = s.ReadInt16();
            this.mHdg = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It                is designed as scaled integer message since the resolution of float is not sufficient."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude, expressed as degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude, expressed as degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude in meters, expressed as * 1000 (millimeters), AMSL (not WGS84 - note that virtually all GPS modules provide the AMSL as well)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RelativeAlt",
                Description = "Altitude above ground in meters, expressed as * 1000 (millimeters)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "Ground X Speed (Latitude, positive north), expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Ground Y Speed (Longitude, positive east), expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Ground Z Speed (Altitude, positive down), expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Hdg",
                Description = "Vehicle heading (yaw angle) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private Int32 mRelativeAlt;
        private Int16 mVx;
        private Int16 mVy;
        private Int16 mVz;
        private UInt16 mHdg;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The scaled values of the RC channels received. (-100%) -10000, (0%) 0, (100%) 10000. Channels that are inactive should be set to UINT16_MAX.
    /// </summary>
    public class UasRcChannelsScaled: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
        /// </summary>
        public Int16 Chan1Scaled {
            get { return mChan1Scaled; }
            set { mChan1Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
        /// </summary>
        public Int16 Chan2Scaled {
            get { return mChan2Scaled; }
            set { mChan2Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
        /// </summary>
        public Int16 Chan3Scaled {
            get { return mChan3Scaled; }
            set { mChan3Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
        /// </summary>
        public Int16 Chan4Scaled {
            get { return mChan4Scaled; }
            set { mChan4Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
        /// </summary>
        public Int16 Chan5Scaled {
            get { return mChan5Scaled; }
            set { mChan5Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
        /// </summary>
        public Int16 Chan6Scaled {
            get { return mChan6Scaled; }
            set { mChan6Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
        /// </summary>
        public Int16 Chan7Scaled {
            get { return mChan7Scaled; }
            set { mChan7Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.
        /// </summary>
        public Int16 Chan8Scaled {
            get { return mChan8Scaled; }
            set { mChan8Scaled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
        /// </summary>
        public byte Port {
            get { return mPort; }
            set { mPort = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        public UasRcChannelsScaled()
        {
            mMessageId = 34;
            CrcExtra = 237;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mChan1Scaled);
            s.Write(mChan2Scaled);
            s.Write(mChan3Scaled);
            s.Write(mChan4Scaled);
            s.Write(mChan5Scaled);
            s.Write(mChan6Scaled);
            s.Write(mChan7Scaled);
            s.Write(mChan8Scaled);
            s.Write(mPort);
            s.Write(mRssi);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mChan1Scaled = s.ReadInt16();
            this.mChan2Scaled = s.ReadInt16();
            this.mChan3Scaled = s.ReadInt16();
            this.mChan4Scaled = s.ReadInt16();
            this.mChan5Scaled = s.ReadInt16();
            this.mChan6Scaled = s.ReadInt16();
            this.mChan7Scaled = s.ReadInt16();
            this.mChan8Scaled = s.ReadInt16();
            this.mPort = s.ReadByte();
            this.mRssi = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The scaled values of the RC channels received. (-100%) -10000, (0%) 0, (100%) 10000. Channels that are inactive should be set to UINT16_MAX."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan1Scaled",
                Description = "RC channel 1 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan2Scaled",
                Description = "RC channel 2 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan3Scaled",
                Description = "RC channel 3 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan4Scaled",
                Description = "RC channel 4 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan5Scaled",
                Description = "RC channel 5 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan6Scaled",
                Description = "RC channel 6 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan7Scaled",
                Description = "RC channel 7 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan8Scaled",
                Description = "RC channel 8 value scaled, (-100%) -10000, (0%) 0, (100%) 10000, (invalid) INT16_MAX.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Port",
                Description = "Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private Int16 mChan1Scaled;
        private Int16 mChan2Scaled;
        private Int16 mChan3Scaled;
        private Int16 mChan4Scaled;
        private Int16 mChan5Scaled;
        private Int16 mChan6Scaled;
        private Int16 mChan7Scaled;
        private Int16 mChan8Scaled;
        private byte mPort;
        private byte mRssi;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
    /// </summary>
    public class UasRcChannelsRaw: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan1Raw {
            get { return mChan1Raw; }
            set { mChan1Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan2Raw {
            get { return mChan2Raw; }
            set { mChan2Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan3Raw {
            get { return mChan3Raw; }
            set { mChan3Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan4Raw {
            get { return mChan4Raw; }
            set { mChan4Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan5Raw {
            get { return mChan5Raw; }
            set { mChan5Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan6Raw {
            get { return mChan6Raw; }
            set { mChan6Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan7Raw {
            get { return mChan7Raw; }
            set { mChan7Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan8Raw {
            get { return mChan8Raw; }
            set { mChan8Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.
        /// </summary>
        public byte Port {
            get { return mPort; }
            set { mPort = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        public UasRcChannelsRaw()
        {
            mMessageId = 35;
            CrcExtra = 244;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mChan1Raw);
            s.Write(mChan2Raw);
            s.Write(mChan3Raw);
            s.Write(mChan4Raw);
            s.Write(mChan5Raw);
            s.Write(mChan6Raw);
            s.Write(mChan7Raw);
            s.Write(mChan8Raw);
            s.Write(mPort);
            s.Write(mRssi);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mChan1Raw = s.ReadUInt16();
            this.mChan2Raw = s.ReadUInt16();
            this.mChan3Raw = s.ReadUInt16();
            this.mChan4Raw = s.ReadUInt16();
            this.mChan5Raw = s.ReadUInt16();
            this.mChan6Raw = s.ReadUInt16();
            this.mChan7Raw = s.ReadUInt16();
            this.mChan8Raw = s.ReadUInt16();
            this.mPort = s.ReadByte();
            this.mRssi = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan1Raw",
                Description = "RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan2Raw",
                Description = "RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan3Raw",
                Description = "RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan4Raw",
                Description = "RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan5Raw",
                Description = "RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan6Raw",
                Description = "RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan7Raw",
                Description = "RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan8Raw",
                Description = "RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Port",
                Description = "Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows for more than 8 servos.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private UInt16 mChan1Raw;
        private UInt16 mChan2Raw;
        private UInt16 mChan3Raw;
        private UInt16 mChan4Raw;
        private UInt16 mChan5Raw;
        private UInt16 mChan6Raw;
        private UInt16 mChan7Raw;
        private UInt16 mChan8Raw;
        private byte mPort;
        private byte mRssi;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.
    /// </summary>
    public class UasServoOutputRaw: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since system boot)
        /// </summary>
        public UInt32 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 1 value, in microseconds
        /// </summary>
        public UInt16 Servo1Raw {
            get { return mServo1Raw; }
            set { mServo1Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 2 value, in microseconds
        /// </summary>
        public UInt16 Servo2Raw {
            get { return mServo2Raw; }
            set { mServo2Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 3 value, in microseconds
        /// </summary>
        public UInt16 Servo3Raw {
            get { return mServo3Raw; }
            set { mServo3Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 4 value, in microseconds
        /// </summary>
        public UInt16 Servo4Raw {
            get { return mServo4Raw; }
            set { mServo4Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 5 value, in microseconds
        /// </summary>
        public UInt16 Servo5Raw {
            get { return mServo5Raw; }
            set { mServo5Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 6 value, in microseconds
        /// </summary>
        public UInt16 Servo6Raw {
            get { return mServo6Raw; }
            set { mServo6Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 7 value, in microseconds
        /// </summary>
        public UInt16 Servo7Raw {
            get { return mServo7Raw; }
            set { mServo7Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output 8 value, in microseconds
        /// </summary>
        public UInt16 Servo8Raw {
            get { return mServo8Raw; }
            set { mServo8Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.
        /// </summary>
        public byte Port {
            get { return mPort; }
            set { mPort = value; NotifyUpdated(); }
        }

        public UasServoOutputRaw()
        {
            mMessageId = 36;
            CrcExtra = 222;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mServo1Raw);
            s.Write(mServo2Raw);
            s.Write(mServo3Raw);
            s.Write(mServo4Raw);
            s.Write(mServo5Raw);
            s.Write(mServo6Raw);
            s.Write(mServo7Raw);
            s.Write(mServo8Raw);
            s.Write(mPort);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt32();
            this.mServo1Raw = s.ReadUInt16();
            this.mServo2Raw = s.ReadUInt16();
            this.mServo3Raw = s.ReadUInt16();
            this.mServo4Raw = s.ReadUInt16();
            this.mServo5Raw = s.ReadUInt16();
            this.mServo6Raw = s.ReadUInt16();
            this.mServo7Raw = s.ReadUInt16();
            this.mServo8Raw = s.ReadUInt16();
            this.mPort = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo1Raw",
                Description = "Servo output 1 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo2Raw",
                Description = "Servo output 2 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo3Raw",
                Description = "Servo output 3 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo4Raw",
                Description = "Servo output 4 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo5Raw",
                Description = "Servo output 5 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo6Raw",
                Description = "Servo output 6 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo7Raw",
                Description = "Servo output 7 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Servo8Raw",
                Description = "Servo output 8 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Port",
                Description = "Servo output port (set of 8 outputs = 1 port). Most MAVs will just use one, but this allows to encode more than 8 servos.",
                NumElements = 1,
            });

        }

        private UInt32 mTimeUsec;
        private UInt16 mServo1Raw;
        private UInt16 mServo2Raw;
        private UInt16 mServo3Raw;
        private UInt16 mServo4Raw;
        private UInt16 mServo5Raw;
        private UInt16 mServo6Raw;
        private UInt16 mServo7Raw;
        private UInt16 mServo8Raw;
        private byte mPort;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request a partial list of mission items from the system/component. http://qgroundcontrol.org/mavlink/waypoint_protocol. If start and end index are the same, just send one waypoint.
    /// </summary>
    public class UasMissionRequestPartialList: UasMessage
    {
        /// <summary>
        /// Start index, 0 by default
        /// </summary>
        public Int16 StartIndex {
            get { return mStartIndex; }
            set { mStartIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// End index, -1 by default (-1: send list to end). Else a valid index of the list
        /// </summary>
        public Int16 EndIndex {
            get { return mEndIndex; }
            set { mEndIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionRequestPartialList()
        {
            mMessageId = 37;
            CrcExtra = 212;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mStartIndex);
            s.Write(mEndIndex);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mStartIndex = s.ReadInt16();
            this.mEndIndex = s.ReadInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request a partial list of mission items from the system/component. http://qgroundcontrol.org/mavlink/waypoint_protocol. If start and end index are the same, just send one waypoint."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StartIndex",
                Description = "Start index, 0 by default",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EndIndex",
                Description = "End index, -1 by default (-1: send list to end). Else a valid index of the list",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private Int16 mStartIndex;
        private Int16 mEndIndex;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// This message is sent to the MAV to write a partial list. If start index == end index, only one item will be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should be REJECTED!
    /// </summary>
    public class UasMissionWritePartialList: UasMessage
    {
        /// <summary>
        /// Start index, 0 by default and smaller / equal to the largest index of the current onboard list.
        /// </summary>
        public Int16 StartIndex {
            get { return mStartIndex; }
            set { mStartIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// End index, equal or greater than start index.
        /// </summary>
        public Int16 EndIndex {
            get { return mEndIndex; }
            set { mEndIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionWritePartialList()
        {
            mMessageId = 38;
            CrcExtra = 9;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mStartIndex);
            s.Write(mEndIndex);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mStartIndex = s.ReadInt16();
            this.mEndIndex = s.ReadInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "This message is sent to the MAV to write a partial list. If start index == end index, only one item will be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should be REJECTED!"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StartIndex",
                Description = "Start index, 0 by default and smaller / equal to the largest index of the current onboard list.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EndIndex",
                Description = "End index, equal or greater than start index.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private Int16 mStartIndex;
        private Int16 mEndIndex;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message encoding a mission item. This message is emitted to announce                 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See also http://qgroundcontrol.org/mavlink/waypoint_protocol.
    /// </summary>
    public class UasMissionItem: UasMessage
    {
        /// <summary>
        /// PARAM1, see MAV_CMD enum
        /// </summary>
        public float Param1 {
            get { return mParam1; }
            set { mParam1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM2, see MAV_CMD enum
        /// </summary>
        public float Param2 {
            get { return mParam2; }
            set { mParam2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM3, see MAV_CMD enum
        /// </summary>
        public float Param3 {
            get { return mParam3; }
            set { mParam3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM4, see MAV_CMD enum
        /// </summary>
        public float Param4 {
            get { return mParam4; }
            set { mParam4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM5 / local: x position, global: latitude
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM6 / y position: global: longitude
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM7 / z position: global: altitude (relative or absolute, depending on frame.
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        /// <summary>
        /// false:0, true:1
        /// </summary>
        public byte Current {
            get { return mCurrent; }
            set { mCurrent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// autocontinue to next wp
        /// </summary>
        public byte Autocontinue {
            get { return mAutocontinue; }
            set { mAutocontinue = value; NotifyUpdated(); }
        }

        public UasMissionItem()
        {
            mMessageId = 39;
            CrcExtra = 254;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mParam1);
            s.Write(mParam2);
            s.Write(mParam3);
            s.Write(mParam4);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mSeq);
            s.Write((UInt16)mCommand);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mFrame);
            s.Write(mCurrent);
            s.Write(mAutocontinue);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mParam1 = s.ReadSingle();
            this.mParam2 = s.ReadSingle();
            this.mParam3 = s.ReadSingle();
            this.mParam4 = s.ReadSingle();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mSeq = s.ReadUInt16();
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mFrame = (MavFrame)s.ReadByte();
            this.mCurrent = s.ReadByte();
            this.mAutocontinue = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message encoding a mission item. This message is emitted to announce                 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See also http://qgroundcontrol.org/mavlink/waypoint_protocol."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param1",
                Description = "PARAM1, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param2",
                Description = "PARAM2, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param3",
                Description = "PARAM3, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param4",
                Description = "PARAM4, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "PARAM5 / local: x position, global: latitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "PARAM6 / y position: global: longitude",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "PARAM7 / z position: global: altitude (relative or absolute, depending on frame.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Current",
                Description = "false:0, true:1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autocontinue",
                Description = "autocontinue to next wp",
                NumElements = 1,
            });

        }

        private float mParam1;
        private float mParam2;
        private float mParam3;
        private float mParam4;
        private float mX;
        private float mY;
        private float mZ;
        private UInt16 mSeq;
        private MavCmd mCommand;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mFrame;
        private byte mCurrent;
        private byte mAutocontinue;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM message. http://qgroundcontrol.org/mavlink/waypoint_protocol
    /// </summary>
    public class UasMissionRequest: UasMessage
    {
        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionRequest()
        {
            mMessageId = 40;
            CrcExtra = 230;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mSeq);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSeq = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM message. http://qgroundcontrol.org/mavlink/waypoint_protocol"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mSeq;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set the mission item with sequence number seq as current item. This means that the MAV will continue to this mission item on the shortest path (not following the mission items in-between).
    /// </summary>
    public class UasMissionSetCurrent: UasMessage
    {
        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionSetCurrent()
        {
            mMessageId = 41;
            CrcExtra = 28;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mSeq);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSeq = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set the mission item with sequence number seq as current item. This means that the MAV will continue to this mission item on the shortest path (not following the mission items in-between)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mSeq;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message that announces the sequence number of the current active mission item. The MAV will fly towards this mission item.
    /// </summary>
    public class UasMissionCurrent: UasMessage
    {
        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        public UasMissionCurrent()
        {
            mMessageId = 42;
            CrcExtra = 28;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mSeq);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSeq = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message that announces the sequence number of the current active mission item. The MAV will fly towards this mission item."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

        }

        private UInt16 mSeq;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request the overall list of mission items from the system/component.
    /// </summary>
    public class UasMissionRequestList: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionRequestList()
        {
            mMessageId = 43;
            CrcExtra = 132;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request the overall list of mission items from the system/component."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction. The GCS can then request the individual mission item based on the knowledge of the total number of MISSIONs.
    /// </summary>
    public class UasMissionCount: UasMessage
    {
        /// <summary>
        /// Number of mission items in the sequence
        /// </summary>
        public UInt16 Count {
            get { return mCount; }
            set { mCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionCount()
        {
            mMessageId = 44;
            CrcExtra = 221;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mCount);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mCount = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction. The GCS can then request the individual mission item based on the knowledge of the total number of MISSIONs."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Count",
                Description = "Number of mission items in the sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mCount;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Delete all mission items at once.
    /// </summary>
    public class UasMissionClearAll: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionClearAll()
        {
            mMessageId = 45;
            CrcExtra = 232;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Delete all mission items at once."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// A certain mission item has been reached. The system will either hold this position (or circle on the orbit) or (if the autocontinue on the WP was set) continue to the next MISSION.
    /// </summary>
    public class UasMissionItemReached: UasMessage
    {
        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        public UasMissionItemReached()
        {
            mMessageId = 46;
            CrcExtra = 11;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mSeq);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSeq = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "A certain mission item has been reached. The system will either hold this position (or circle on the orbit) or (if the autocontinue on the WP was set) continue to the next MISSION."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

        }

        private UInt16 mSeq;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Ack message during MISSION handling. The type field states if this message is a positive ack (type=0) or if an error happened (type=non-zero).
    /// </summary>
    public class UasMissionAck: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// See MAV_MISSION_RESULT enum
        /// </summary>
        public MavMissionResult Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        public UasMissionAck()
        {
            mMessageId = 47;
            CrcExtra = 153;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mType);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mType = (MavMissionResult)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Ack message during MISSION handling. The type field states if this message is a positive ack (type=0) or if an error happened (type=non-zero)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "See MAV_MISSION_RESULT enum",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavMissionResult"),
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavMissionResult mType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// As local waypoints exist, the global MISSION reference allows to transform between the local coordinate frame and the global (GPS) coordinate frame. This can be necessary when e.g. in- and outdoor settings are connected and the MAV should move from in- to outdoor.
    /// </summary>
    public class UasSetGpsGlobalOrigin: UasMessage
    {
        /// <summary>
        /// Latitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Latitude {
            get { return mLatitude; }
            set { mLatitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84, in degrees * 1E7
        /// </summary>
        public Int32 Longitude {
            get { return mLongitude; }
            set { mLongitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (AMSL), in meters * 1000 (positive for up)
        /// </summary>
        public Int32 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        public UasSetGpsGlobalOrigin()
        {
            mMessageId = 48;
            CrcExtra = 41;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mLatitude);
            s.Write(mLongitude);
            s.Write(mAltitude);
            s.Write(mTargetSystem);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mLatitude = s.ReadInt32();
            this.mLongitude = s.ReadInt32();
            this.mAltitude = s.ReadInt32();
            this.mTargetSystem = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "As local waypoints exist, the global MISSION reference allows to transform between the local coordinate frame and the global (GPS) coordinate frame. This can be necessary when e.g. in- and outdoor settings are connected and the MAV should move from in- to outdoor."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Latitude",
                Description = "Latitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Longitude",
                Description = "Longitude (WGS84, in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude (AMSL), in meters * 1000 (positive for up)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

        }

        private Int32 mLatitude;
        private Int32 mLongitude;
        private Int32 mAltitude;
        private byte mTargetSystem;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Once the MAV sets a new GPS-Local correspondence, this message announces the origin (0,0,0) position
    /// </summary>
    public class UasGpsGlobalOrigin: UasMessage
    {
        /// <summary>
        /// Latitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Latitude {
            get { return mLatitude; }
            set { mLatitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Longitude {
            get { return mLongitude; }
            set { mLongitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (AMSL), in meters * 1000 (positive for up)
        /// </summary>
        public Int32 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        public UasGpsGlobalOrigin()
        {
            mMessageId = 49;
            CrcExtra = 39;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mLatitude);
            s.Write(mLongitude);
            s.Write(mAltitude);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mLatitude = s.ReadInt32();
            this.mLongitude = s.ReadInt32();
            this.mAltitude = s.ReadInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Once the MAV sets a new GPS-Local correspondence, this message announces the origin (0,0,0) position"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Latitude",
                Description = "Latitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Longitude",
                Description = "Longitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude (AMSL), in meters * 1000 (positive for up)",
                NumElements = 1,
            });

        }

        private Int32 mLatitude;
        private Int32 mLongitude;
        private Int32 mAltitude;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Bind a RC channel to a parameter. The parameter should change accoding to the RC channel value.
    /// </summary>
    public class UasParamMapRc: UasMessage
    {
        /// <summary>
        /// Initial parameter value
        /// </summary>
        public float ParamValue0 {
            get { return mParamValue0; }
            set { mParamValue0 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Scale, maps the RC range [-1, 1] to a parameter value
        /// </summary>
        public float Scale {
            get { return mScale; }
            set { mScale = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)
        /// </summary>
        public float ParamValueMin {
            get { return mParamValueMin; }
            set { mParamValueMin = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)
        /// </summary>
        public float ParamValueMax {
            get { return mParamValueMax; }
            set { mParamValueMax = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
        /// </summary>
        public Int16 ParamIndex {
            get { return mParamIndex; }
            set { mParamIndex = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
        /// </summary>
        public char[] ParamId {
            get { return mParamId; }
            set { mParamId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Index of parameter RC channel. Not equal to the RC channel id. Typically correpsonds to a potentiometer-knob on the RC.
        /// </summary>
        public byte ParameterRcChannelIndex {
            get { return mParameterRcChannelIndex; }
            set { mParameterRcChannelIndex = value; NotifyUpdated(); }
        }

        public UasParamMapRc()
        {
            mMessageId = 50;
            CrcExtra = 78;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mParamValue0);
            s.Write(mScale);
            s.Write(mParamValueMin);
            s.Write(mParamValueMax);
            s.Write(mParamIndex);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mParamId[0]); 
            s.Write(mParamId[1]); 
            s.Write(mParamId[2]); 
            s.Write(mParamId[3]); 
            s.Write(mParamId[4]); 
            s.Write(mParamId[5]); 
            s.Write(mParamId[6]); 
            s.Write(mParamId[7]); 
            s.Write(mParamId[8]); 
            s.Write(mParamId[9]); 
            s.Write(mParamId[10]); 
            s.Write(mParamId[11]); 
            s.Write(mParamId[12]); 
            s.Write(mParamId[13]); 
            s.Write(mParamId[14]); 
            s.Write(mParamId[15]); 
            s.Write(mParameterRcChannelIndex);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mParamValue0 = s.ReadSingle();
            this.mScale = s.ReadSingle();
            this.mParamValueMin = s.ReadSingle();
            this.mParamValueMax = s.ReadSingle();
            this.mParamIndex = s.ReadInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mParamId[0] = s.ReadChar();
            this.mParamId[1] = s.ReadChar();
            this.mParamId[2] = s.ReadChar();
            this.mParamId[3] = s.ReadChar();
            this.mParamId[4] = s.ReadChar();
            this.mParamId[5] = s.ReadChar();
            this.mParamId[6] = s.ReadChar();
            this.mParamId[7] = s.ReadChar();
            this.mParamId[8] = s.ReadChar();
            this.mParamId[9] = s.ReadChar();
            this.mParamId[10] = s.ReadChar();
            this.mParamId[11] = s.ReadChar();
            this.mParamId[12] = s.ReadChar();
            this.mParamId[13] = s.ReadChar();
            this.mParamId[14] = s.ReadChar();
            this.mParamId[15] = s.ReadChar();
            this.mParameterRcChannelIndex = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Bind a RC channel to a parameter. The parameter should change accoding to the RC channel value."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamValue0",
                Description = "Initial parameter value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Scale",
                Description = "Scale, maps the RC range [-1, 1] to a parameter value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamValueMin",
                Description = "Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamValueMax",
                Description = "Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamIndex",
                Description = "Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParamId",
                Description = "Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string",
                NumElements = 16,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ParameterRcChannelIndex",
                Description = "Index of parameter RC channel. Not equal to the RC channel id. Typically correpsonds to a potentiometer-knob on the RC.",
                NumElements = 1,
            });

        }

        private float mParamValue0;
        private float mScale;
        private float mParamValueMin;
        private float mParamValueMax;
        private Int16 mParamIndex;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private char[] mParamId = new char[16];
        private byte mParameterRcChannelIndex;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM_INT message. http://qgroundcontrol.org/mavlink/waypoint_protocol
    /// </summary>
    public class UasMissionRequestInt: UasMessage
    {
        /// <summary>
        /// Sequence
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMissionRequestInt()
        {
            mMessageId = 51;
            CrcExtra = 196;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mSeq);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSeq = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM_INT message. http://qgroundcontrol.org/mavlink/waypoint_protocol"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Sequence",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mSeq;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell the MAV which setpoints/MISSIONs to accept and which to reject. Safety areas are often enforced by national or competition regulations.
    /// </summary>
    public class UasSafetySetAllowedArea: UasMessage
    {
        /// <summary>
        /// x position 1 / Latitude 1
        /// </summary>
        public float P1x {
            get { return mP1x; }
            set { mP1x = value; NotifyUpdated(); }
        }

        /// <summary>
        /// y position 1 / Longitude 1
        /// </summary>
        public float P1y {
            get { return mP1y; }
            set { mP1y = value; NotifyUpdated(); }
        }

        /// <summary>
        /// z position 1 / Altitude 1
        /// </summary>
        public float P1z {
            get { return mP1z; }
            set { mP1z = value; NotifyUpdated(); }
        }

        /// <summary>
        /// x position 2 / Latitude 2
        /// </summary>
        public float P2x {
            get { return mP2x; }
            set { mP2x = value; NotifyUpdated(); }
        }

        /// <summary>
        /// y position 2 / Longitude 2
        /// </summary>
        public float P2y {
            get { return mP2y; }
            set { mP2y = value; NotifyUpdated(); }
        }

        /// <summary>
        /// z position 2 / Altitude 2
        /// </summary>
        public float P2z {
            get { return mP2z; }
            set { mP2z = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        public UasSafetySetAllowedArea()
        {
            mMessageId = 54;
            CrcExtra = 15;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mP1x);
            s.Write(mP1y);
            s.Write(mP1z);
            s.Write(mP2x);
            s.Write(mP2y);
            s.Write(mP2z);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mFrame);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mP1x = s.ReadSingle();
            this.mP1y = s.ReadSingle();
            this.mP1z = s.ReadSingle();
            this.mP2x = s.ReadSingle();
            this.mP2y = s.ReadSingle();
            this.mP2z = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell the MAV which setpoints/MISSIONs to accept and which to reject. Safety areas are often enforced by national or competition regulations."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1x",
                Description = "x position 1 / Latitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1y",
                Description = "y position 1 / Longitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1z",
                Description = "z position 1 / Altitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2x",
                Description = "x position 2 / Latitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2y",
                Description = "y position 2 / Longitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2z",
                Description = "z position 2 / Altitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private float mP1x;
        private float mP1y;
        private float mP1z;
        private float mP2x;
        private float mP2y;
        private float mP2z;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Read out the safety zone the MAV currently assumes.
    /// </summary>
    public class UasSafetyAllowedArea: UasMessage
    {
        /// <summary>
        /// x position 1 / Latitude 1
        /// </summary>
        public float P1x {
            get { return mP1x; }
            set { mP1x = value; NotifyUpdated(); }
        }

        /// <summary>
        /// y position 1 / Longitude 1
        /// </summary>
        public float P1y {
            get { return mP1y; }
            set { mP1y = value; NotifyUpdated(); }
        }

        /// <summary>
        /// z position 1 / Altitude 1
        /// </summary>
        public float P1z {
            get { return mP1z; }
            set { mP1z = value; NotifyUpdated(); }
        }

        /// <summary>
        /// x position 2 / Latitude 2
        /// </summary>
        public float P2x {
            get { return mP2x; }
            set { mP2x = value; NotifyUpdated(); }
        }

        /// <summary>
        /// y position 2 / Longitude 2
        /// </summary>
        public float P2y {
            get { return mP2y; }
            set { mP2y = value; NotifyUpdated(); }
        }

        /// <summary>
        /// z position 2 / Altitude 2
        /// </summary>
        public float P2z {
            get { return mP2z; }
            set { mP2z = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        public UasSafetyAllowedArea()
        {
            mMessageId = 55;
            CrcExtra = 3;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mP1x);
            s.Write(mP1y);
            s.Write(mP1z);
            s.Write(mP2x);
            s.Write(mP2y);
            s.Write(mP2z);
            s.Write((byte)mFrame);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mP1x = s.ReadSingle();
            this.mP1y = s.ReadSingle();
            this.mP1z = s.ReadSingle();
            this.mP2x = s.ReadSingle();
            this.mP2y = s.ReadSingle();
            this.mP2z = s.ReadSingle();
            this.mFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Read out the safety zone the MAV currently assumes."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1x",
                Description = "x position 1 / Latitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1y",
                Description = "y position 1 / Longitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1z",
                Description = "z position 1 / Altitude 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2x",
                Description = "x position 2 / Latitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2y",
                Description = "y position 2 / Longitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2z",
                Description = "z position 2 / Altitude 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "Coordinate frame, as defined by MAV_FRAME enum in mavlink_types.h. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private float mP1x;
        private float mP1y;
        private float mP1z;
        private float mP2x;
        private float mP2y;
        private float mP2z;
        private MavFrame mFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
    /// </summary>
    public class UasAttitudeQuaternionCov: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angular speed (rad/s)
        /// </summary>
        public float Rollspeed {
            get { return mRollspeed; }
            set { mRollspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angular speed (rad/s)
        /// </summary>
        public float Pitchspeed {
            get { return mPitchspeed; }
            set { mPitchspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angular speed (rad/s)
        /// </summary>
        public float Yawspeed {
            get { return mYawspeed; }
            set { mYawspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude covariance
        /// </summary>
        public float[] Covariance {
            get { return mCovariance; }
            set { mCovariance = value; NotifyUpdated(); }
        }

        public UasAttitudeQuaternionCov()
        {
            mMessageId = 61;
            CrcExtra = 153;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mRollspeed);
            s.Write(mPitchspeed);
            s.Write(mYawspeed);
            s.Write(mCovariance[0]); 
            s.Write(mCovariance[1]); 
            s.Write(mCovariance[2]); 
            s.Write(mCovariance[3]); 
            s.Write(mCovariance[4]); 
            s.Write(mCovariance[5]); 
            s.Write(mCovariance[6]); 
            s.Write(mCovariance[7]); 
            s.Write(mCovariance[8]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mRollspeed = s.ReadSingle();
            this.mPitchspeed = s.ReadSingle();
            this.mYawspeed = s.ReadSingle();
            this.mCovariance[0] = s.ReadSingle();
            this.mCovariance[1] = s.ReadSingle();
            this.mCovariance[2] = s.ReadSingle();
            this.mCovariance[3] = s.ReadSingle();
            this.mCovariance[4] = s.ReadSingle();
            this.mCovariance[5] = s.ReadSingle();
            this.mCovariance[6] = s.ReadSingle();
            this.mCovariance[7] = s.ReadSingle();
            this.mCovariance[8] = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rollspeed",
                Description = "Roll angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitchspeed",
                Description = "Pitch angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yawspeed",
                Description = "Yaw angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Covariance",
                Description = "Attitude covariance",
                NumElements = 9,
            });

        }

        private UInt32 mTimeBootMs;
        private float[] mQ = new float[4];
        private float mRollspeed;
        private float mPitchspeed;
        private float mYawspeed;
        private float[] mCovariance = new float[9];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The state of the fixed wing navigation and position controller.
    /// </summary>
    public class UasNavControllerOutput: UasMessage
    {
        /// <summary>
        /// Current desired roll in degrees
        /// </summary>
        public float NavRoll {
            get { return mNavRoll; }
            set { mNavRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current desired pitch in degrees
        /// </summary>
        public float NavPitch {
            get { return mNavPitch; }
            set { mNavPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current altitude error in meters
        /// </summary>
        public float AltError {
            get { return mAltError; }
            set { mAltError = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current airspeed error in meters/second
        /// </summary>
        public float AspdError {
            get { return mAspdError; }
            set { mAspdError = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current crosstrack error on x-y plane in meters
        /// </summary>
        public float XtrackError {
            get { return mXtrackError; }
            set { mXtrackError = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current desired heading in degrees
        /// </summary>
        public Int16 NavBearing {
            get { return mNavBearing; }
            set { mNavBearing = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bearing to current MISSION/target in degrees
        /// </summary>
        public Int16 TargetBearing {
            get { return mTargetBearing; }
            set { mTargetBearing = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Distance to active MISSION in meters
        /// </summary>
        public UInt16 WpDist {
            get { return mWpDist; }
            set { mWpDist = value; NotifyUpdated(); }
        }

        public UasNavControllerOutput()
        {
            mMessageId = 62;
            CrcExtra = 183;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mNavRoll);
            s.Write(mNavPitch);
            s.Write(mAltError);
            s.Write(mAspdError);
            s.Write(mXtrackError);
            s.Write(mNavBearing);
            s.Write(mTargetBearing);
            s.Write(mWpDist);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mNavRoll = s.ReadSingle();
            this.mNavPitch = s.ReadSingle();
            this.mAltError = s.ReadSingle();
            this.mAspdError = s.ReadSingle();
            this.mXtrackError = s.ReadSingle();
            this.mNavBearing = s.ReadInt16();
            this.mTargetBearing = s.ReadInt16();
            this.mWpDist = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The state of the fixed wing navigation and position controller."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "NavRoll",
                Description = "Current desired roll in degrees",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "NavPitch",
                Description = "Current desired pitch in degrees",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltError",
                Description = "Current altitude error in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AspdError",
                Description = "Current airspeed error in meters/second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "XtrackError",
                Description = "Current crosstrack error on x-y plane in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "NavBearing",
                Description = "Current desired heading in degrees",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetBearing",
                Description = "Bearing to current MISSION/target in degrees",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WpDist",
                Description = "Distance to active MISSION in meters",
                NumElements = 1,
            });

        }

        private float mNavRoll;
        private float mNavPitch;
        private float mAltError;
        private float mAspdError;
        private float mXtrackError;
        private Int16 mNavBearing;
        private Int16 mTargetBearing;
        private UInt16 mWpDist;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE: This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset.
    /// </summary>
    public class UasGlobalPositionIntCov: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
        /// </summary>
        public UInt64 TimeUtc {
            get { return mTimeUtc; }
            set { mTimeUtc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude, expressed as degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude, expressed as degrees * 1E7
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude in meters, expressed as * 1000 (millimeters), above MSL
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude above ground in meters, expressed as * 1000 (millimeters)
        /// </summary>
        public Int32 RelativeAlt {
            get { return mRelativeAlt; }
            set { mRelativeAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground X Speed (Latitude), expressed as m/s
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Y Speed (Longitude), expressed as m/s
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Z Speed (Altitude), expressed as m/s
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)
        /// </summary>
        public float[] Covariance {
            get { return mCovariance; }
            set { mCovariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Class id of the estimator this estimate originated from.
        /// </summary>
        public byte EstimatorType {
            get { return mEstimatorType; }
            set { mEstimatorType = value; NotifyUpdated(); }
        }

        public UasGlobalPositionIntCov()
        {
            mMessageId = 63;
            CrcExtra = 51;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUtc);
            s.Write(mTimeBootMs);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mRelativeAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mCovariance[0]); 
            s.Write(mCovariance[1]); 
            s.Write(mCovariance[2]); 
            s.Write(mCovariance[3]); 
            s.Write(mCovariance[4]); 
            s.Write(mCovariance[5]); 
            s.Write(mCovariance[6]); 
            s.Write(mCovariance[7]); 
            s.Write(mCovariance[8]); 
            s.Write(mCovariance[9]); 
            s.Write(mCovariance[10]); 
            s.Write(mCovariance[11]); 
            s.Write(mCovariance[12]); 
            s.Write(mCovariance[13]); 
            s.Write(mCovariance[14]); 
            s.Write(mCovariance[15]); 
            s.Write(mCovariance[16]); 
            s.Write(mCovariance[17]); 
            s.Write(mCovariance[18]); 
            s.Write(mCovariance[19]); 
            s.Write(mCovariance[20]); 
            s.Write(mCovariance[21]); 
            s.Write(mCovariance[22]); 
            s.Write(mCovariance[23]); 
            s.Write(mCovariance[24]); 
            s.Write(mCovariance[25]); 
            s.Write(mCovariance[26]); 
            s.Write(mCovariance[27]); 
            s.Write(mCovariance[28]); 
            s.Write(mCovariance[29]); 
            s.Write(mCovariance[30]); 
            s.Write(mCovariance[31]); 
            s.Write(mCovariance[32]); 
            s.Write(mCovariance[33]); 
            s.Write(mCovariance[34]); 
            s.Write(mCovariance[35]); 
            s.Write(mEstimatorType);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUtc = s.ReadUInt64();
            this.mTimeBootMs = s.ReadUInt32();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mRelativeAlt = s.ReadInt32();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mCovariance[0] = s.ReadSingle();
            this.mCovariance[1] = s.ReadSingle();
            this.mCovariance[2] = s.ReadSingle();
            this.mCovariance[3] = s.ReadSingle();
            this.mCovariance[4] = s.ReadSingle();
            this.mCovariance[5] = s.ReadSingle();
            this.mCovariance[6] = s.ReadSingle();
            this.mCovariance[7] = s.ReadSingle();
            this.mCovariance[8] = s.ReadSingle();
            this.mCovariance[9] = s.ReadSingle();
            this.mCovariance[10] = s.ReadSingle();
            this.mCovariance[11] = s.ReadSingle();
            this.mCovariance[12] = s.ReadSingle();
            this.mCovariance[13] = s.ReadSingle();
            this.mCovariance[14] = s.ReadSingle();
            this.mCovariance[15] = s.ReadSingle();
            this.mCovariance[16] = s.ReadSingle();
            this.mCovariance[17] = s.ReadSingle();
            this.mCovariance[18] = s.ReadSingle();
            this.mCovariance[19] = s.ReadSingle();
            this.mCovariance[20] = s.ReadSingle();
            this.mCovariance[21] = s.ReadSingle();
            this.mCovariance[22] = s.ReadSingle();
            this.mCovariance[23] = s.ReadSingle();
            this.mCovariance[24] = s.ReadSingle();
            this.mCovariance[25] = s.ReadSingle();
            this.mCovariance[26] = s.ReadSingle();
            this.mCovariance[27] = s.ReadSingle();
            this.mCovariance[28] = s.ReadSingle();
            this.mCovariance[29] = s.ReadSingle();
            this.mCovariance[30] = s.ReadSingle();
            this.mCovariance[31] = s.ReadSingle();
            this.mCovariance[32] = s.ReadSingle();
            this.mCovariance[33] = s.ReadSingle();
            this.mCovariance[34] = s.ReadSingle();
            this.mCovariance[35] = s.ReadSingle();
            this.mEstimatorType = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE: This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUtc",
                Description = "Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude, expressed as degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude, expressed as degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude in meters, expressed as * 1000 (millimeters), above MSL",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RelativeAlt",
                Description = "Altitude above ground in meters, expressed as * 1000 (millimeters)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "Ground X Speed (Latitude), expressed as m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Ground Y Speed (Longitude), expressed as m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Ground Z Speed (Altitude), expressed as m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Covariance",
                Description = "Covariance matrix (first six entries are the first ROW, next six entries are the second row, etc.)",
                NumElements = 36,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EstimatorType",
                Description = "Class id of the estimator this estimate originated from.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUtc;
        private UInt32 mTimeBootMs;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private Int32 mRelativeAlt;
        private float mVx;
        private float mVy;
        private float mVz;
        private float[] mCovariance = new float[36];
        private byte mEstimatorType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
    /// </summary>
    public class UasLocalPositionNedCov: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.
        /// </summary>
        public UInt64 TimeUtc {
            get { return mTimeUtc; }
            set { mTimeUtc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Timestamp (milliseconds since system boot). 0 for system without monotonic timestamp
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Speed (m/s)
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Speed (m/s)
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Speed (m/s)
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Acceleration (m/s^2)
        /// </summary>
        public float Ax {
            get { return mAx; }
            set { mAx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Acceleration (m/s^2)
        /// </summary>
        public float Ay {
            get { return mAy; }
            set { mAy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Acceleration (m/s^2)
        /// </summary>
        public float Az {
            get { return mAz; }
            set { mAz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Covariance matrix upper right triangular (first nine entries are the first ROW, next eight entries are the second row, etc.)
        /// </summary>
        public float[] Covariance {
            get { return mCovariance; }
            set { mCovariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Class id of the estimator this estimate originated from.
        /// </summary>
        public byte EstimatorType {
            get { return mEstimatorType; }
            set { mEstimatorType = value; NotifyUpdated(); }
        }

        public UasLocalPositionNedCov()
        {
            mMessageId = 64;
            CrcExtra = 59;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUtc);
            s.Write(mTimeBootMs);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mAx);
            s.Write(mAy);
            s.Write(mAz);
            s.Write(mCovariance[0]); 
            s.Write(mCovariance[1]); 
            s.Write(mCovariance[2]); 
            s.Write(mCovariance[3]); 
            s.Write(mCovariance[4]); 
            s.Write(mCovariance[5]); 
            s.Write(mCovariance[6]); 
            s.Write(mCovariance[7]); 
            s.Write(mCovariance[8]); 
            s.Write(mCovariance[9]); 
            s.Write(mCovariance[10]); 
            s.Write(mCovariance[11]); 
            s.Write(mCovariance[12]); 
            s.Write(mCovariance[13]); 
            s.Write(mCovariance[14]); 
            s.Write(mCovariance[15]); 
            s.Write(mCovariance[16]); 
            s.Write(mCovariance[17]); 
            s.Write(mCovariance[18]); 
            s.Write(mCovariance[19]); 
            s.Write(mCovariance[20]); 
            s.Write(mCovariance[21]); 
            s.Write(mCovariance[22]); 
            s.Write(mCovariance[23]); 
            s.Write(mCovariance[24]); 
            s.Write(mCovariance[25]); 
            s.Write(mCovariance[26]); 
            s.Write(mCovariance[27]); 
            s.Write(mCovariance[28]); 
            s.Write(mCovariance[29]); 
            s.Write(mCovariance[30]); 
            s.Write(mCovariance[31]); 
            s.Write(mCovariance[32]); 
            s.Write(mCovariance[33]); 
            s.Write(mCovariance[34]); 
            s.Write(mCovariance[35]); 
            s.Write(mCovariance[36]); 
            s.Write(mCovariance[37]); 
            s.Write(mCovariance[38]); 
            s.Write(mCovariance[39]); 
            s.Write(mCovariance[40]); 
            s.Write(mCovariance[41]); 
            s.Write(mCovariance[42]); 
            s.Write(mCovariance[43]); 
            s.Write(mCovariance[44]); 
            s.Write(mEstimatorType);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUtc = s.ReadUInt64();
            this.mTimeBootMs = s.ReadUInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mAx = s.ReadSingle();
            this.mAy = s.ReadSingle();
            this.mAz = s.ReadSingle();
            this.mCovariance[0] = s.ReadSingle();
            this.mCovariance[1] = s.ReadSingle();
            this.mCovariance[2] = s.ReadSingle();
            this.mCovariance[3] = s.ReadSingle();
            this.mCovariance[4] = s.ReadSingle();
            this.mCovariance[5] = s.ReadSingle();
            this.mCovariance[6] = s.ReadSingle();
            this.mCovariance[7] = s.ReadSingle();
            this.mCovariance[8] = s.ReadSingle();
            this.mCovariance[9] = s.ReadSingle();
            this.mCovariance[10] = s.ReadSingle();
            this.mCovariance[11] = s.ReadSingle();
            this.mCovariance[12] = s.ReadSingle();
            this.mCovariance[13] = s.ReadSingle();
            this.mCovariance[14] = s.ReadSingle();
            this.mCovariance[15] = s.ReadSingle();
            this.mCovariance[16] = s.ReadSingle();
            this.mCovariance[17] = s.ReadSingle();
            this.mCovariance[18] = s.ReadSingle();
            this.mCovariance[19] = s.ReadSingle();
            this.mCovariance[20] = s.ReadSingle();
            this.mCovariance[21] = s.ReadSingle();
            this.mCovariance[22] = s.ReadSingle();
            this.mCovariance[23] = s.ReadSingle();
            this.mCovariance[24] = s.ReadSingle();
            this.mCovariance[25] = s.ReadSingle();
            this.mCovariance[26] = s.ReadSingle();
            this.mCovariance[27] = s.ReadSingle();
            this.mCovariance[28] = s.ReadSingle();
            this.mCovariance[29] = s.ReadSingle();
            this.mCovariance[30] = s.ReadSingle();
            this.mCovariance[31] = s.ReadSingle();
            this.mCovariance[32] = s.ReadSingle();
            this.mCovariance[33] = s.ReadSingle();
            this.mCovariance[34] = s.ReadSingle();
            this.mCovariance[35] = s.ReadSingle();
            this.mCovariance[36] = s.ReadSingle();
            this.mCovariance[37] = s.ReadSingle();
            this.mCovariance[38] = s.ReadSingle();
            this.mCovariance[39] = s.ReadSingle();
            this.mCovariance[40] = s.ReadSingle();
            this.mCovariance[41] = s.ReadSingle();
            this.mCovariance[42] = s.ReadSingle();
            this.mCovariance[43] = s.ReadSingle();
            this.mCovariance[44] = s.ReadSingle();
            this.mEstimatorType = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUtc",
                Description = "Timestamp (microseconds since UNIX epoch) in UTC. 0 for unknown. Commonly filled by the precision time source of a GPS receiver.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot). 0 for system without monotonic timestamp",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X Speed (m/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y Speed (m/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z Speed (m/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ax",
                Description = "X Acceleration (m/s^2)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ay",
                Description = "Y Acceleration (m/s^2)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Az",
                Description = "Z Acceleration (m/s^2)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Covariance",
                Description = "Covariance matrix upper right triangular (first nine entries are the first ROW, next eight entries are the second row, etc.)",
                NumElements = 45,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EstimatorType",
                Description = "Class id of the estimator this estimate originated from.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUtc;
        private UInt32 mTimeBootMs;
        private float mX;
        private float mY;
        private float mZ;
        private float mVx;
        private float mVy;
        private float mVz;
        private float mAx;
        private float mAy;
        private float mAz;
        private float[] mCovariance = new float[45];
        private byte mEstimatorType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
    /// </summary>
    public class UasRcChannels: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan1Raw {
            get { return mChan1Raw; }
            set { mChan1Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan2Raw {
            get { return mChan2Raw; }
            set { mChan2Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan3Raw {
            get { return mChan3Raw; }
            set { mChan3Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan4Raw {
            get { return mChan4Raw; }
            set { mChan4Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan5Raw {
            get { return mChan5Raw; }
            set { mChan5Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan6Raw {
            get { return mChan6Raw; }
            set { mChan6Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan7Raw {
            get { return mChan7Raw; }
            set { mChan7Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan8Raw {
            get { return mChan8Raw; }
            set { mChan8Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 9 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan9Raw {
            get { return mChan9Raw; }
            set { mChan9Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 10 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan10Raw {
            get { return mChan10Raw; }
            set { mChan10Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 11 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan11Raw {
            get { return mChan11Raw; }
            set { mChan11Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 12 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan12Raw {
            get { return mChan12Raw; }
            set { mChan12Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 13 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan13Raw {
            get { return mChan13Raw; }
            set { mChan13Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 14 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan14Raw {
            get { return mChan14Raw; }
            set { mChan14Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 15 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan15Raw {
            get { return mChan15Raw; }
            set { mChan15Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 16 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan16Raw {
            get { return mChan16Raw; }
            set { mChan16Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 17 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan17Raw {
            get { return mChan17Raw; }
            set { mChan17Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 18 value, in microseconds. A value of UINT16_MAX implies the channel is unused.
        /// </summary>
        public UInt16 Chan18Raw {
            get { return mChan18Raw; }
            set { mChan18Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.
        /// </summary>
        public byte Chancount {
            get { return mChancount; }
            set { mChancount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        public UasRcChannels()
        {
            mMessageId = 65;
            CrcExtra = 118;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mChan1Raw);
            s.Write(mChan2Raw);
            s.Write(mChan3Raw);
            s.Write(mChan4Raw);
            s.Write(mChan5Raw);
            s.Write(mChan6Raw);
            s.Write(mChan7Raw);
            s.Write(mChan8Raw);
            s.Write(mChan9Raw);
            s.Write(mChan10Raw);
            s.Write(mChan11Raw);
            s.Write(mChan12Raw);
            s.Write(mChan13Raw);
            s.Write(mChan14Raw);
            s.Write(mChan15Raw);
            s.Write(mChan16Raw);
            s.Write(mChan17Raw);
            s.Write(mChan18Raw);
            s.Write(mChancount);
            s.Write(mRssi);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mChan1Raw = s.ReadUInt16();
            this.mChan2Raw = s.ReadUInt16();
            this.mChan3Raw = s.ReadUInt16();
            this.mChan4Raw = s.ReadUInt16();
            this.mChan5Raw = s.ReadUInt16();
            this.mChan6Raw = s.ReadUInt16();
            this.mChan7Raw = s.ReadUInt16();
            this.mChan8Raw = s.ReadUInt16();
            this.mChan9Raw = s.ReadUInt16();
            this.mChan10Raw = s.ReadUInt16();
            this.mChan11Raw = s.ReadUInt16();
            this.mChan12Raw = s.ReadUInt16();
            this.mChan13Raw = s.ReadUInt16();
            this.mChan14Raw = s.ReadUInt16();
            this.mChan15Raw = s.ReadUInt16();
            this.mChan16Raw = s.ReadUInt16();
            this.mChan17Raw = s.ReadUInt16();
            this.mChan18Raw = s.ReadUInt16();
            this.mChancount = s.ReadByte();
            this.mRssi = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan1Raw",
                Description = "RC channel 1 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan2Raw",
                Description = "RC channel 2 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan3Raw",
                Description = "RC channel 3 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan4Raw",
                Description = "RC channel 4 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan5Raw",
                Description = "RC channel 5 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan6Raw",
                Description = "RC channel 6 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan7Raw",
                Description = "RC channel 7 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan8Raw",
                Description = "RC channel 8 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan9Raw",
                Description = "RC channel 9 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan10Raw",
                Description = "RC channel 10 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan11Raw",
                Description = "RC channel 11 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan12Raw",
                Description = "RC channel 12 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan13Raw",
                Description = "RC channel 13 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan14Raw",
                Description = "RC channel 14 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan15Raw",
                Description = "RC channel 15 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan16Raw",
                Description = "RC channel 16 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan17Raw",
                Description = "RC channel 17 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan18Raw",
                Description = "RC channel 18 value, in microseconds. A value of UINT16_MAX implies the channel is unused.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chancount",
                Description = "Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "Receive signal strength indicator, 0: 0%, 100: 100%, 255: invalid/unknown.",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private UInt16 mChan1Raw;
        private UInt16 mChan2Raw;
        private UInt16 mChan3Raw;
        private UInt16 mChan4Raw;
        private UInt16 mChan5Raw;
        private UInt16 mChan6Raw;
        private UInt16 mChan7Raw;
        private UInt16 mChan8Raw;
        private UInt16 mChan9Raw;
        private UInt16 mChan10Raw;
        private UInt16 mChan11Raw;
        private UInt16 mChan12Raw;
        private UInt16 mChan13Raw;
        private UInt16 mChan14Raw;
        private UInt16 mChan15Raw;
        private UInt16 mChan16Raw;
        private UInt16 mChan17Raw;
        private UInt16 mChan18Raw;
        private byte mChancount;
        private byte mRssi;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// THIS INTERFACE IS DEPRECATED. USE SET_MESSAGE_INTERVAL INSTEAD.
    /// </summary>
    public class UasRequestDataStream: UasMessage
    {
        /// <summary>
        /// The requested message rate
        /// </summary>
        public UInt16 ReqMessageRate {
            get { return mReqMessageRate; }
            set { mReqMessageRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The target requested to send the message stream.
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The target requested to send the message stream.
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The ID of the requested data stream
        /// </summary>
        public byte ReqStreamId {
            get { return mReqStreamId; }
            set { mReqStreamId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 1 to start sending, 0 to stop sending.
        /// </summary>
        public byte StartStop {
            get { return mStartStop; }
            set { mStartStop = value; NotifyUpdated(); }
        }

        public UasRequestDataStream()
        {
            mMessageId = 66;
            CrcExtra = 148;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mReqMessageRate);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mReqStreamId);
            s.Write(mStartStop);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mReqMessageRate = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mReqStreamId = s.ReadByte();
            this.mStartStop = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "THIS INTERFACE IS DEPRECATED. USE SET_MESSAGE_INTERVAL INSTEAD."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ReqMessageRate",
                Description = "The requested message rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "The target requested to send the message stream.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "The target requested to send the message stream.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ReqStreamId",
                Description = "The ID of the requested data stream",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StartStop",
                Description = "1 to start sending, 0 to stop sending.",
                NumElements = 1,
            });

        }

        private UInt16 mReqMessageRate;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mReqStreamId;
        private byte mStartStop;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// THIS INTERFACE IS DEPRECATED. USE MESSAGE_INTERVAL INSTEAD.
    /// </summary>
    public class UasDataStream: UasMessage
    {
        /// <summary>
        /// The message rate
        /// </summary>
        public UInt16 MessageRate {
            get { return mMessageRate; }
            set { mMessageRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The ID of the requested data stream
        /// </summary>
        public byte StreamId {
            get { return mStreamId; }
            set { mStreamId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 1 stream is enabled, 0 stream is stopped.
        /// </summary>
        public byte OnOff {
            get { return mOnOff; }
            set { mOnOff = value; NotifyUpdated(); }
        }

        public UasDataStream()
        {
            mMessageId = 67;
            CrcExtra = 21;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mMessageRate);
            s.Write(mStreamId);
            s.Write(mOnOff);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mMessageRate = s.ReadUInt16();
            this.mStreamId = s.ReadByte();
            this.mOnOff = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "THIS INTERFACE IS DEPRECATED. USE MESSAGE_INTERVAL INSTEAD."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MessageRate",
                Description = "The message rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StreamId",
                Description = "The ID of the requested data stream",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OnOff",
                Description = "1 stream is enabled, 0 stream is stopped.",
                NumElements = 1,
            });

        }

        private UInt16 mMessageRate;
        private byte mStreamId;
        private byte mOnOff;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature, along with a joystick-like input device. Unused axes can be disabled an buttons are also transmit as boolean values of their 
    /// </summary>
    public class UasManualControl: UasMessage
    {
        /// <summary>
        /// X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.
        /// </summary>
        public Int16 X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.
        /// </summary>
        public Int16 Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle. Positive values are positive thrust, negative values are negative thrust.
        /// </summary>
        public Int16 Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.
        /// </summary>
        public Int16 R {
            get { return mR; }
            set { mR = value; NotifyUpdated(); }
        }

        /// <summary>
        /// A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
        /// </summary>
        public UInt16 Buttons {
            get { return mButtons; }
            set { mButtons = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The system to be controlled.
        /// </summary>
        public byte Target {
            get { return mTarget; }
            set { mTarget = value; NotifyUpdated(); }
        }

        public UasManualControl()
        {
            mMessageId = 69;
            CrcExtra = 243;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mR);
            s.Write(mButtons);
            s.Write(mTarget);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mX = s.ReadInt16();
            this.mY = s.ReadInt16();
            this.mZ = s.ReadInt16();
            this.mR = s.ReadInt16();
            this.mButtons = s.ReadUInt16();
            this.mTarget = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature, along with a joystick-like input device. Unused axes can be disabled an buttons are also transmit as boolean values of their "
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle. Positive values are positive thrust, negative values are negative thrust.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "R",
                Description = "R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Buttons",
                Description = "A bitfield corresponding to the joystick buttons' current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Target",
                Description = "The system to be controlled.",
                NumElements = 1,
            });

        }

        private Int16 mX;
        private Int16 mY;
        private Int16 mZ;
        private Int16 mR;
        private UInt16 mButtons;
        private byte mTarget;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW values of the RC channels sent to the MAV to override info received from the RC radio. A value of UINT16_MAX means no change to that channel. A value of 0 means control of that channel should be released back to the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
    /// </summary>
    public class UasRcChannelsOverride: UasMessage
    {
        /// <summary>
        /// RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.
        /// </summary>
        public UInt16 Chan1Raw {
            get { return mChan1Raw; }
            set { mChan1Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 2 value, in microseconds. A value of UINT16_MAX means to ignore this field.
        /// </summary>
        public UInt16 Chan2Raw {
            get { return mChan2Raw; }
            set { mChan2Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 3 value, in microseconds. A value of UINT16_MAX means to ignore this field.
        /// </summary>
        public UInt16 Chan3Raw {
            get { return mChan3Raw; }
            set { mChan3Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 4 value, in microseconds. A value of UINT16_MAX means to ignore this field.
        /// </summary>
        public UInt16 Chan4Raw {
            get { return mChan4Raw; }
            set { mChan4Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 5 value, in microseconds. A value of UINT16_MAX means to ignore this field.
        /// </summary>
        public UInt16 Chan5Raw {
            get { return mChan5Raw; }
            set { mChan5Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 6 value, in microseconds. A value of UINT16_MAX means to ignore this field.
        /// </summary>
        public UInt16 Chan6Raw {
            get { return mChan6Raw; }
            set { mChan6Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 7 value, in microseconds. A value of UINT16_MAX means to ignore this field.
        /// </summary>
        public UInt16 Chan7Raw {
            get { return mChan7Raw; }
            set { mChan7Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 8 value, in microseconds. A value of UINT16_MAX means to ignore this field.
        /// </summary>
        public UInt16 Chan8Raw {
            get { return mChan8Raw; }
            set { mChan8Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasRcChannelsOverride()
        {
            mMessageId = 70;
            CrcExtra = 124;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mChan1Raw);
            s.Write(mChan2Raw);
            s.Write(mChan3Raw);
            s.Write(mChan4Raw);
            s.Write(mChan5Raw);
            s.Write(mChan6Raw);
            s.Write(mChan7Raw);
            s.Write(mChan8Raw);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mChan1Raw = s.ReadUInt16();
            this.mChan2Raw = s.ReadUInt16();
            this.mChan3Raw = s.ReadUInt16();
            this.mChan4Raw = s.ReadUInt16();
            this.mChan5Raw = s.ReadUInt16();
            this.mChan6Raw = s.ReadUInt16();
            this.mChan7Raw = s.ReadUInt16();
            this.mChan8Raw = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW values of the RC channels sent to the MAV to override info received from the RC radio. A value of UINT16_MAX means no change to that channel. A value of 0 means control of that channel should be released back to the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan1Raw",
                Description = "RC channel 1 value, in microseconds. A value of UINT16_MAX means to ignore this field.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan2Raw",
                Description = "RC channel 2 value, in microseconds. A value of UINT16_MAX means to ignore this field.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan3Raw",
                Description = "RC channel 3 value, in microseconds. A value of UINT16_MAX means to ignore this field.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan4Raw",
                Description = "RC channel 4 value, in microseconds. A value of UINT16_MAX means to ignore this field.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan5Raw",
                Description = "RC channel 5 value, in microseconds. A value of UINT16_MAX means to ignore this field.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan6Raw",
                Description = "RC channel 6 value, in microseconds. A value of UINT16_MAX means to ignore this field.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan7Raw",
                Description = "RC channel 7 value, in microseconds. A value of UINT16_MAX means to ignore this field.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan8Raw",
                Description = "RC channel 8 value, in microseconds. A value of UINT16_MAX means to ignore this field.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mChan1Raw;
        private UInt16 mChan2Raw;
        private UInt16 mChan3Raw;
        private UInt16 mChan4Raw;
        private UInt16 mChan5Raw;
        private UInt16 mChan6Raw;
        private UInt16 mChan7Raw;
        private UInt16 mChan8Raw;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message encoding a mission item. This message is emitted to announce                 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See alsohttp://qgroundcontrol.org/mavlink/waypoint_protocol.
    /// </summary>
    public class UasMissionItemInt: UasMessage
    {
        /// <summary>
        /// PARAM1, see MAV_CMD enum
        /// </summary>
        public float Param1 {
            get { return mParam1; }
            set { mParam1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM2, see MAV_CMD enum
        /// </summary>
        public float Param2 {
            get { return mParam2; }
            set { mParam2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM3, see MAV_CMD enum
        /// </summary>
        public float Param3 {
            get { return mParam3; }
            set { mParam3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM4, see MAV_CMD enum
        /// </summary>
        public float Param4 {
            get { return mParam4; }
            set { mParam4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
        /// </summary>
        public Int32 X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7
        /// </summary>
        public Int32 Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
        /// </summary>
        public UInt16 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        /// <summary>
        /// false:0, true:1
        /// </summary>
        public byte Current {
            get { return mCurrent; }
            set { mCurrent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// autocontinue to next wp
        /// </summary>
        public byte Autocontinue {
            get { return mAutocontinue; }
            set { mAutocontinue = value; NotifyUpdated(); }
        }

        public UasMissionItemInt()
        {
            mMessageId = 73;
            CrcExtra = 38;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mParam1);
            s.Write(mParam2);
            s.Write(mParam3);
            s.Write(mParam4);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mSeq);
            s.Write((UInt16)mCommand);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mFrame);
            s.Write(mCurrent);
            s.Write(mAutocontinue);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mParam1 = s.ReadSingle();
            this.mParam2 = s.ReadSingle();
            this.mParam3 = s.ReadSingle();
            this.mParam4 = s.ReadSingle();
            this.mX = s.ReadInt32();
            this.mY = s.ReadInt32();
            this.mZ = s.ReadSingle();
            this.mSeq = s.ReadUInt16();
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mFrame = (MavFrame)s.ReadByte();
            this.mCurrent = s.ReadByte();
            this.mAutocontinue = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message encoding a mission item. This message is emitted to announce                 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See alsohttp://qgroundcontrol.org/mavlink/waypoint_protocol."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param1",
                Description = "PARAM1, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param2",
                Description = "PARAM2, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param3",
                Description = "PARAM3, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param4",
                Description = "PARAM4, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "The scheduled action for the MISSION. see MAV_CMD in common.xml MAVLink specs",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "The coordinate system of the MISSION. see MAV_FRAME in mavlink_types.h",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Current",
                Description = "false:0, true:1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autocontinue",
                Description = "autocontinue to next wp",
                NumElements = 1,
            });

        }

        private float mParam1;
        private float mParam2;
        private float mParam3;
        private float mParam4;
        private Int32 mX;
        private Int32 mY;
        private float mZ;
        private UInt16 mSeq;
        private MavCmd mCommand;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mFrame;
        private byte mCurrent;
        private byte mAutocontinue;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Metrics typically displayed on a HUD for fixed wing aircraft
    /// </summary>
    public class UasVfrHud: UasMessage
    {
        /// <summary>
        /// Current airspeed in m/s
        /// </summary>
        public float Airspeed {
            get { return mAirspeed; }
            set { mAirspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current ground speed in m/s
        /// </summary>
        public float Groundspeed {
            get { return mGroundspeed; }
            set { mGroundspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current altitude (MSL), in meters
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current climb rate in meters/second
        /// </summary>
        public float Climb {
            get { return mClimb; }
            set { mClimb = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current heading in degrees, in compass units (0..360, 0=north)
        /// </summary>
        public Int16 Heading {
            get { return mHeading; }
            set { mHeading = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current throttle setting in integer percent, 0 to 100
        /// </summary>
        public UInt16 Throttle {
            get { return mThrottle; }
            set { mThrottle = value; NotifyUpdated(); }
        }

        public UasVfrHud()
        {
            mMessageId = 74;
            CrcExtra = 20;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mAirspeed);
            s.Write(mGroundspeed);
            s.Write(mAlt);
            s.Write(mClimb);
            s.Write(mHeading);
            s.Write(mThrottle);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mAirspeed = s.ReadSingle();
            this.mGroundspeed = s.ReadSingle();
            this.mAlt = s.ReadSingle();
            this.mClimb = s.ReadSingle();
            this.mHeading = s.ReadInt16();
            this.mThrottle = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Metrics typically displayed on a HUD for fixed wing aircraft"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Airspeed",
                Description = "Current airspeed in m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Groundspeed",
                Description = "Current ground speed in m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Current altitude (MSL), in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Climb",
                Description = "Current climb rate in meters/second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Heading",
                Description = "Current heading in degrees, in compass units (0..360, 0=north)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Throttle",
                Description = "Current throttle setting in integer percent, 0 to 100",
                NumElements = 1,
            });

        }

        private float mAirspeed;
        private float mGroundspeed;
        private float mAlt;
        private float mClimb;
        private Int16 mHeading;
        private UInt16 mThrottle;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message encoding a command with parameters as scaled integers. Scaling depends on the actual command value.
    /// </summary>
    public class UasCommandInt: UasMessage
    {
        /// <summary>
        /// PARAM1, see MAV_CMD enum
        /// </summary>
        public float Param1 {
            get { return mParam1; }
            set { mParam1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM2, see MAV_CMD enum
        /// </summary>
        public float Param2 {
            get { return mParam2; }
            set { mParam2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM3, see MAV_CMD enum
        /// </summary>
        public float Param3 {
            get { return mParam3; }
            set { mParam3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM4, see MAV_CMD enum
        /// </summary>
        public float Param4 {
            get { return mParam4; }
            set { mParam4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
        /// </summary>
        public Int32 X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7
        /// </summary>
        public Int32 Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The scheduled action for the mission item. see MAV_CMD in common.xml MAVLink specs
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The coordinate system of the COMMAND. see MAV_FRAME in mavlink_types.h
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        /// <summary>
        /// false:0, true:1
        /// </summary>
        public byte Current {
            get { return mCurrent; }
            set { mCurrent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// autocontinue to next wp
        /// </summary>
        public byte Autocontinue {
            get { return mAutocontinue; }
            set { mAutocontinue = value; NotifyUpdated(); }
        }

        public UasCommandInt()
        {
            mMessageId = 75;
            CrcExtra = 158;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mParam1);
            s.Write(mParam2);
            s.Write(mParam3);
            s.Write(mParam4);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write((UInt16)mCommand);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mFrame);
            s.Write(mCurrent);
            s.Write(mAutocontinue);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mParam1 = s.ReadSingle();
            this.mParam2 = s.ReadSingle();
            this.mParam3 = s.ReadSingle();
            this.mParam4 = s.ReadSingle();
            this.mX = s.ReadInt32();
            this.mY = s.ReadInt32();
            this.mZ = s.ReadSingle();
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mFrame = (MavFrame)s.ReadByte();
            this.mCurrent = s.ReadByte();
            this.mAutocontinue = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message encoding a command with parameters as scaled integers. Scaling depends on the actual command value."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param1",
                Description = "PARAM1, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param2",
                Description = "PARAM2, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param3",
                Description = "PARAM3, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param4",
                Description = "PARAM4, see MAV_CMD enum",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "The scheduled action for the mission item. see MAV_CMD in common.xml MAVLink specs",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "The coordinate system of the COMMAND. see MAV_FRAME in mavlink_types.h",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Current",
                Description = "false:0, true:1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autocontinue",
                Description = "autocontinue to next wp",
                NumElements = 1,
            });

        }

        private float mParam1;
        private float mParam2;
        private float mParam3;
        private float mParam4;
        private Int32 mX;
        private Int32 mY;
        private float mZ;
        private MavCmd mCommand;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mFrame;
        private byte mCurrent;
        private byte mAutocontinue;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send a command with up to seven parameters to the MAV
    /// </summary>
    public class UasCommandLong: UasMessage
    {
        /// <summary>
        /// Parameter 1, as defined by MAV_CMD enum.
        /// </summary>
        public float Param1 {
            get { return mParam1; }
            set { mParam1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 2, as defined by MAV_CMD enum.
        /// </summary>
        public float Param2 {
            get { return mParam2; }
            set { mParam2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 3, as defined by MAV_CMD enum.
        /// </summary>
        public float Param3 {
            get { return mParam3; }
            set { mParam3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 4, as defined by MAV_CMD enum.
        /// </summary>
        public float Param4 {
            get { return mParam4; }
            set { mParam4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 5, as defined by MAV_CMD enum.
        /// </summary>
        public float Param5 {
            get { return mParam5; }
            set { mParam5 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 6, as defined by MAV_CMD enum.
        /// </summary>
        public float Param6 {
            get { return mParam6; }
            set { mParam6 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 7, as defined by MAV_CMD enum.
        /// </summary>
        public float Param7 {
            get { return mParam7; }
            set { mParam7 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Command ID, as defined by MAV_CMD enum.
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System which should execute the command
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component which should execute the command, 0 for all components
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
        /// </summary>
        public byte Confirmation {
            get { return mConfirmation; }
            set { mConfirmation = value; NotifyUpdated(); }
        }

        public UasCommandLong()
        {
            mMessageId = 76;
            CrcExtra = 152;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mParam1);
            s.Write(mParam2);
            s.Write(mParam3);
            s.Write(mParam4);
            s.Write(mParam5);
            s.Write(mParam6);
            s.Write(mParam7);
            s.Write((UInt16)mCommand);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mConfirmation);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mParam1 = s.ReadSingle();
            this.mParam2 = s.ReadSingle();
            this.mParam3 = s.ReadSingle();
            this.mParam4 = s.ReadSingle();
            this.mParam5 = s.ReadSingle();
            this.mParam6 = s.ReadSingle();
            this.mParam7 = s.ReadSingle();
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mConfirmation = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send a command with up to seven parameters to the MAV"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param1",
                Description = "Parameter 1, as defined by MAV_CMD enum.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param2",
                Description = "Parameter 2, as defined by MAV_CMD enum.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param3",
                Description = "Parameter 3, as defined by MAV_CMD enum.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param4",
                Description = "Parameter 4, as defined by MAV_CMD enum.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param5",
                Description = "Parameter 5, as defined by MAV_CMD enum.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param6",
                Description = "Parameter 6, as defined by MAV_CMD enum.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Param7",
                Description = "Parameter 7, as defined by MAV_CMD enum.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "Command ID, as defined by MAV_CMD enum.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System which should execute the command",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component which should execute the command, 0 for all components",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Confirmation",
                Description = "0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)",
                NumElements = 1,
            });

        }

        private float mParam1;
        private float mParam2;
        private float mParam3;
        private float mParam4;
        private float mParam5;
        private float mParam6;
        private float mParam7;
        private MavCmd mCommand;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mConfirmation;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Report status of a command. Includes feedback wether the command was executed.
    /// </summary>
    public class UasCommandAck: UasMessage
    {
        /// <summary>
        /// Command ID, as defined by MAV_CMD enum.
        /// </summary>
        public MavCmd Command {
            get { return mCommand; }
            set { mCommand = value; NotifyUpdated(); }
        }

        /// <summary>
        /// See MAV_RESULT enum
        /// </summary>
        public MavResult Result {
            get { return mResult; }
            set { mResult = value; NotifyUpdated(); }
        }

        public UasCommandAck()
        {
            mMessageId = 77;
            CrcExtra = 143;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write((UInt16)mCommand);
            s.Write((byte)mResult);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mCommand = (MavCmd)s.ReadUInt16();
            this.mResult = (MavResult)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Report status of a command. Includes feedback wether the command was executed."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Command",
                Description = "Command ID, as defined by MAV_CMD enum.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Result",
                Description = "See MAV_RESULT enum",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavResult"),
            });

        }

        private MavCmd mCommand;
        private MavResult mResult;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Setpoint in roll, pitch, yaw and thrust from the operator
    /// </summary>
    public class UasManualSetpoint: UasMessage
    {
        /// <summary>
        /// Timestamp in milliseconds since system boot
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Desired roll rate in radians per second
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Desired pitch rate in radians per second
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Desired yaw rate in radians per second
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Collective thrust, normalized to 0 .. 1
        /// </summary>
        public float Thrust {
            get { return mThrust; }
            set { mThrust = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flight mode switch position, 0.. 255
        /// </summary>
        public byte ModeSwitch {
            get { return mModeSwitch; }
            set { mModeSwitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Override mode switch position, 0.. 255
        /// </summary>
        public byte ManualOverrideSwitch {
            get { return mManualOverrideSwitch; }
            set { mManualOverrideSwitch = value; NotifyUpdated(); }
        }

        public UasManualSetpoint()
        {
            mMessageId = 81;
            CrcExtra = 106;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mThrust);
            s.Write(mModeSwitch);
            s.Write(mManualOverrideSwitch);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mThrust = s.ReadSingle();
            this.mModeSwitch = s.ReadByte();
            this.mManualOverrideSwitch = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Setpoint in roll, pitch, yaw and thrust from the operator"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp in milliseconds since system boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Desired roll rate in radians per second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Desired pitch rate in radians per second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Desired yaw rate in radians per second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Thrust",
                Description = "Collective thrust, normalized to 0 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ModeSwitch",
                Description = "Flight mode switch position, 0.. 255",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ManualOverrideSwitch",
                Description = "Override mode switch position, 0.. 255",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mThrust;
        private byte mModeSwitch;
        private byte mManualOverrideSwitch;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sets a desired vehicle attitude. Used by an external controller to command the vehicle (manual controller or other system).
    /// </summary>
    public class UasSetAttitudeTarget: UasMessage
    {
        /// <summary>
        /// Timestamp in milliseconds since system boot
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body roll rate in radians per second
        /// </summary>
        public float BodyRollRate {
            get { return mBodyRollRate; }
            set { mBodyRollRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body roll rate in radians per second
        /// </summary>
        public float BodyPitchRate {
            get { return mBodyPitchRate; }
            set { mBodyPitchRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body roll rate in radians per second
        /// </summary>
        public float BodyYawRate {
            get { return mBodyYawRate; }
            set { mBodyYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
        /// </summary>
        public float Thrust {
            get { return mThrust; }
            set { mThrust = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude
        /// </summary>
        public byte TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        public UasSetAttitudeTarget()
        {
            mMessageId = 82;
            CrcExtra = 49;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mBodyRollRate);
            s.Write(mBodyPitchRate);
            s.Write(mBodyYawRate);
            s.Write(mThrust);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mTypeMask);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mBodyRollRate = s.ReadSingle();
            this.mBodyPitchRate = s.ReadSingle();
            this.mBodyYawRate = s.ReadSingle();
            this.mThrust = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mTypeMask = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sets a desired vehicle attitude. Used by an external controller to command the vehicle (manual controller or other system)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp in milliseconds since system boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyRollRate",
                Description = "Body roll rate in radians per second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyPitchRate",
                Description = "Body roll rate in radians per second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyYawRate",
                Description = "Body roll rate in radians per second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Thrust",
                Description = "Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 6: reserved, bit 7: throttle, bit 8: attitude",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float[] mQ = new float[4];
        private float mBodyRollRate;
        private float mBodyPitchRate;
        private float mBodyYawRate;
        private float mThrust;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mTypeMask;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reports the current commanded attitude of the vehicle as specified by the autopilot. This should match the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way.
    /// </summary>
    public class UasAttitudeTarget: UasMessage
    {
        /// <summary>
        /// Timestamp in milliseconds since system boot
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body roll rate in radians per second
        /// </summary>
        public float BodyRollRate {
            get { return mBodyRollRate; }
            set { mBodyRollRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body roll rate in radians per second
        /// </summary>
        public float BodyPitchRate {
            get { return mBodyPitchRate; }
            set { mBodyPitchRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body roll rate in radians per second
        /// </summary>
        public float BodyYawRate {
            get { return mBodyYawRate; }
            set { mBodyYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
        /// </summary>
        public float Thrust {
            get { return mThrust; }
            set { mThrust = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude
        /// </summary>
        public byte TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        public UasAttitudeTarget()
        {
            mMessageId = 83;
            CrcExtra = 22;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mBodyRollRate);
            s.Write(mBodyPitchRate);
            s.Write(mBodyYawRate);
            s.Write(mThrust);
            s.Write(mTypeMask);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mBodyRollRate = s.ReadSingle();
            this.mBodyPitchRate = s.ReadSingle();
            this.mBodyYawRate = s.ReadSingle();
            this.mThrust = s.ReadSingle();
            this.mTypeMask = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reports the current commanded attitude of the vehicle as specified by the autopilot. This should match the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp in milliseconds since system boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyRollRate",
                Description = "Body roll rate in radians per second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyPitchRate",
                Description = "Body roll rate in radians per second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BodyYawRate",
                Description = "Body roll rate in radians per second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Thrust",
                Description = "Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Mappings: If any of these bits are set, the corresponding input should be ignored: bit 1: body roll rate, bit 2: body pitch rate, bit 3: body yaw rate. bit 4-bit 7: reserved, bit 8: attitude",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float[] mQ = new float[4];
        private float mBodyRollRate;
        private float mBodyPitchRate;
        private float mBodyYawRate;
        private float mThrust;
        private byte mTypeMask;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sets a desired vehicle position in a local north-east-down coordinate frame. Used by an external controller to command the vehicle (manual controller or other system).
    /// </summary>
    public class UasSetPositionTargetLocalNed: UasMessage
    {
        /// <summary>
        /// Timestamp in milliseconds since system boot
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position in NED frame in meters
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position in NED frame in meters
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Position in NED frame in meters (note, altitude is negative in NED)
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X velocity in NED frame in meter / s
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y velocity in NED frame in meter / s
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z velocity in NED frame in meter / s
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afx {
            get { return mAfx; }
            set { mAfx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afy {
            get { return mAfy; }
            set { mAfy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afz {
            get { return mAfz; }
            set { mAfz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw setpoint in rad
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw rate setpoint in rad/s
        /// </summary>
        public float YawRate {
            get { return mYawRate; }
            set { mYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
        /// </summary>
        public UInt16 TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
        /// </summary>
        public MavFrame CoordinateFrame {
            get { return mCoordinateFrame; }
            set { mCoordinateFrame = value; NotifyUpdated(); }
        }

        public UasSetPositionTargetLocalNed()
        {
            mMessageId = 84;
            CrcExtra = 143;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mAfx);
            s.Write(mAfy);
            s.Write(mAfz);
            s.Write(mYaw);
            s.Write(mYawRate);
            s.Write(mTypeMask);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mCoordinateFrame);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mAfx = s.ReadSingle();
            this.mAfy = s.ReadSingle();
            this.mAfz = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mYawRate = s.ReadSingle();
            this.mTypeMask = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mCoordinateFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sets a desired vehicle position in a local north-east-down coordinate frame. Used by an external controller to command the vehicle (manual controller or other system)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp in milliseconds since system boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X Position in NED frame in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y Position in NED frame in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z Position in NED frame in meters (note, altitude is negative in NED)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afx",
                Description = "X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afy",
                Description = "Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afz",
                Description = "Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "yaw setpoint in rad",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRate",
                Description = "yaw rate setpoint in rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CoordinateFrame",
                Description = "Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private UInt32 mTimeBootMs;
        private float mX;
        private float mY;
        private float mZ;
        private float mVx;
        private float mVy;
        private float mVz;
        private float mAfx;
        private float mAfy;
        private float mAfz;
        private float mYaw;
        private float mYawRate;
        private UInt16 mTypeMask;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mCoordinateFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_LOCAL_NED if the vehicle is being controlled this way.
    /// </summary>
    public class UasPositionTargetLocalNed: UasMessage
    {
        /// <summary>
        /// Timestamp in milliseconds since system boot
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position in NED frame in meters
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position in NED frame in meters
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Position in NED frame in meters (note, altitude is negative in NED)
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X velocity in NED frame in meter / s
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y velocity in NED frame in meter / s
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z velocity in NED frame in meter / s
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afx {
            get { return mAfx; }
            set { mAfx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afy {
            get { return mAfy; }
            set { mAfy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afz {
            get { return mAfz; }
            set { mAfz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw setpoint in rad
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw rate setpoint in rad/s
        /// </summary>
        public float YawRate {
            get { return mYawRate; }
            set { mYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
        /// </summary>
        public UInt16 TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
        /// </summary>
        public MavFrame CoordinateFrame {
            get { return mCoordinateFrame; }
            set { mCoordinateFrame = value; NotifyUpdated(); }
        }

        public UasPositionTargetLocalNed()
        {
            mMessageId = 85;
            CrcExtra = 140;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mAfx);
            s.Write(mAfy);
            s.Write(mAfz);
            s.Write(mYaw);
            s.Write(mYawRate);
            s.Write(mTypeMask);
            s.Write((byte)mCoordinateFrame);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mAfx = s.ReadSingle();
            this.mAfy = s.ReadSingle();
            this.mAfz = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mYawRate = s.ReadSingle();
            this.mTypeMask = s.ReadUInt16();
            this.mCoordinateFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_LOCAL_NED if the vehicle is being controlled this way."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp in milliseconds since system boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X Position in NED frame in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y Position in NED frame in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z Position in NED frame in meters (note, altitude is negative in NED)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afx",
                Description = "X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afy",
                Description = "Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afz",
                Description = "Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "yaw setpoint in rad",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRate",
                Description = "yaw rate setpoint in rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CoordinateFrame",
                Description = "Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private UInt32 mTimeBootMs;
        private float mX;
        private float mY;
        private float mZ;
        private float mVx;
        private float mVy;
        private float mVz;
        private float mAfx;
        private float mAfy;
        private float mAfz;
        private float mYaw;
        private float mYawRate;
        private UInt16 mTypeMask;
        private MavFrame mCoordinateFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sets a desired vehicle position, velocity, and/or acceleration in a global coordinate system (WGS84). Used by an external controller to command the vehicle (manual controller or other system).
    /// </summary>
    public class UasSetPositionTargetGlobalInt: UasMessage
    {
        /// <summary>
        /// Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position in WGS84 frame in 1e7 * meters
        /// </summary>
        public Int32 LatInt {
            get { return mLatInt; }
            set { mLatInt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position in WGS84 frame in 1e7 * meters
        /// </summary>
        public Int32 LonInt {
            get { return mLonInt; }
            set { mLonInt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X velocity in NED frame in meter / s
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y velocity in NED frame in meter / s
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z velocity in NED frame in meter / s
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afx {
            get { return mAfx; }
            set { mAfx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afy {
            get { return mAfy; }
            set { mAfy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afz {
            get { return mAfz; }
            set { mAfz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw setpoint in rad
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw rate setpoint in rad/s
        /// </summary>
        public float YawRate {
            get { return mYawRate; }
            set { mYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
        /// </summary>
        public UInt16 TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
        /// </summary>
        public MavFrame CoordinateFrame {
            get { return mCoordinateFrame; }
            set { mCoordinateFrame = value; NotifyUpdated(); }
        }

        public UasSetPositionTargetGlobalInt()
        {
            mMessageId = 86;
            CrcExtra = 5;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mLatInt);
            s.Write(mLonInt);
            s.Write(mAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mAfx);
            s.Write(mAfy);
            s.Write(mAfz);
            s.Write(mYaw);
            s.Write(mYawRate);
            s.Write(mTypeMask);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mCoordinateFrame);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mLatInt = s.ReadInt32();
            this.mLonInt = s.ReadInt32();
            this.mAlt = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mAfx = s.ReadSingle();
            this.mAfy = s.ReadSingle();
            this.mAfz = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mYawRate = s.ReadSingle();
            this.mTypeMask = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mCoordinateFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sets a desired vehicle position, velocity, and/or acceleration in a global coordinate system (WGS84). Used by an external controller to command the vehicle (manual controller or other system)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LatInt",
                Description = "X Position in WGS84 frame in 1e7 * meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LonInt",
                Description = "Y Position in WGS84 frame in 1e7 * meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afx",
                Description = "X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afy",
                Description = "Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afz",
                Description = "Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "yaw setpoint in rad",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRate",
                Description = "yaw rate setpoint in rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CoordinateFrame",
                Description = "Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private UInt32 mTimeBootMs;
        private Int32 mLatInt;
        private Int32 mLonInt;
        private float mAlt;
        private float mVx;
        private float mVy;
        private float mVz;
        private float mAfx;
        private float mAfy;
        private float mAfz;
        private float mYaw;
        private float mYawRate;
        private UInt16 mTypeMask;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavFrame mCoordinateFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled this way.
    /// </summary>
    public class UasPositionTargetGlobalInt: UasMessage
    {
        /// <summary>
        /// Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position in WGS84 frame in 1e7 * meters
        /// </summary>
        public Int32 LatInt {
            get { return mLatInt; }
            set { mLatInt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position in WGS84 frame in 1e7 * meters
        /// </summary>
        public Int32 LonInt {
            get { return mLonInt; }
            set { mLonInt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X velocity in NED frame in meter / s
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y velocity in NED frame in meter / s
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z velocity in NED frame in meter / s
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afx {
            get { return mAfx; }
            set { mAfx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afy {
            get { return mAfy; }
            set { mAfy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
        /// </summary>
        public float Afz {
            get { return mAfz; }
            set { mAfz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw setpoint in rad
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw rate setpoint in rad/s
        /// </summary>
        public float YawRate {
            get { return mYawRate; }
            set { mYawRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate
        /// </summary>
        public UInt16 TypeMask {
            get { return mTypeMask; }
            set { mTypeMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
        /// </summary>
        public MavFrame CoordinateFrame {
            get { return mCoordinateFrame; }
            set { mCoordinateFrame = value; NotifyUpdated(); }
        }

        public UasPositionTargetGlobalInt()
        {
            mMessageId = 87;
            CrcExtra = 150;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mLatInt);
            s.Write(mLonInt);
            s.Write(mAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mAfx);
            s.Write(mAfy);
            s.Write(mAfz);
            s.Write(mYaw);
            s.Write(mYawRate);
            s.Write(mTypeMask);
            s.Write((byte)mCoordinateFrame);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mLatInt = s.ReadInt32();
            this.mLonInt = s.ReadInt32();
            this.mAlt = s.ReadSingle();
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mAfx = s.ReadSingle();
            this.mAfy = s.ReadSingle();
            this.mAfz = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mYawRate = s.ReadSingle();
            this.mTypeMask = s.ReadUInt16();
            this.mCoordinateFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled this way."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp in milliseconds since system boot. The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LatInt",
                Description = "X Position in WGS84 frame in 1e7 * meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LonInt",
                Description = "Y Position in WGS84 frame in 1e7 * meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude in meters in AMSL altitude, not WGS84 if absolute or relative, above terrain if GLOBAL_TERRAIN_ALT_INT",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "X velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Y velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Z velocity in NED frame in meter / s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afx",
                Description = "X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afy",
                Description = "Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Afz",
                Description = "Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "yaw setpoint in rad",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRate",
                Description = "yaw rate setpoint in rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TypeMask",
                Description = "Bitmask to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 10 is set the floats afx afy afz should be interpreted as force instead of acceleration. Mapping: bit 1: x, bit 2: y, bit 3: z, bit 4: vx, bit 5: vy, bit 6: vz, bit 7: ax, bit 8: ay, bit 9: az, bit 10: is force setpoint, bit 11: yaw, bit 12: yaw rate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CoordinateFrame",
                Description = "Valid options are: MAV_FRAME_GLOBAL_INT = 5, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private UInt32 mTimeBootMs;
        private Int32 mLatInt;
        private Int32 mLonInt;
        private float mAlt;
        private float mVx;
        private float mVy;
        private float mVz;
        private float mAfx;
        private float mAfy;
        private float mAfz;
        private float mYaw;
        private float mYawRate;
        private UInt16 mTypeMask;
        private MavFrame mCoordinateFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
    /// </summary>
    public class UasLocalPositionNedSystemGlobalOffset: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        public UasLocalPositionNedSystemGlobalOffset()
        {
            mMessageId = 89;
            CrcExtra = 231;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z Position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mX;
        private float mY;
        private float mZ;
        private float mRoll;
        private float mPitch;
        private float mYaw;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// DEPRECATED PACKET! Suffers from missing airspeed fields and singularities due to Euler angles. Please use HIL_STATE_QUATERNION instead. Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations.
    /// </summary>
    public class UasHilState: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch or microseconds since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angle (rad)
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle (rad)
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle (rad)
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame roll / phi angular speed (rad/s)
        /// </summary>
        public float Rollspeed {
            get { return mRollspeed; }
            set { mRollspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame pitch / theta angular speed (rad/s)
        /// </summary>
        public float Pitchspeed {
            get { return mPitchspeed; }
            set { mPitchspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame yaw / psi angular speed (rad/s)
        /// </summary>
        public float Yawspeed {
            get { return mYawspeed; }
            set { mYawspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude, expressed as * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude, expressed as * 1E7
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude in meters, expressed as * 1000 (millimeters)
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground X Speed (Latitude), expressed as m/s * 100
        /// </summary>
        public Int16 Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Y Speed (Longitude), expressed as m/s * 100
        /// </summary>
        public Int16 Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Z Speed (Altitude), expressed as m/s * 100
        /// </summary>
        public Int16 Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration (mg)
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration (mg)
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration (mg)
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        public UasHilState()
        {
            mMessageId = 90;
            CrcExtra = 183;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mRollspeed);
            s.Write(mPitchspeed);
            s.Write(mYawspeed);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mRollspeed = s.ReadSingle();
            this.mPitchspeed = s.ReadSingle();
            this.mYawspeed = s.ReadSingle();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mVx = s.ReadInt16();
            this.mVy = s.ReadInt16();
            this.mVz = s.ReadInt16();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "DEPRECATED PACKET! Suffers from missing airspeed fields and singularities due to Euler angles. Please use HIL_STATE_QUATERNION instead. Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds since UNIX epoch or microseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rollspeed",
                Description = "Body frame roll / phi angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitchspeed",
                Description = "Body frame pitch / theta angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yawspeed",
                Description = "Body frame yaw / psi angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude, expressed as * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude, expressed as * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude in meters, expressed as * 1000 (millimeters)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "Ground X Speed (Latitude), expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Ground Y Speed (Longitude), expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Ground Z Speed (Altitude), expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration (mg)",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mRollspeed;
        private float mPitchspeed;
        private float mYawspeed;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private Int16 mVx;
        private Int16 mVy;
        private Int16 mVz;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sent from autopilot to simulation. Hardware in the loop control outputs
    /// </summary>
    public class UasHilControls: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch or microseconds since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Control output -1 .. 1
        /// </summary>
        public float RollAilerons {
            get { return mRollAilerons; }
            set { mRollAilerons = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Control output -1 .. 1
        /// </summary>
        public float PitchElevator {
            get { return mPitchElevator; }
            set { mPitchElevator = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Control output -1 .. 1
        /// </summary>
        public float YawRudder {
            get { return mYawRudder; }
            set { mYawRudder = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Throttle 0 .. 1
        /// </summary>
        public float Throttle {
            get { return mThrottle; }
            set { mThrottle = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Aux 1, -1 .. 1
        /// </summary>
        public float Aux1 {
            get { return mAux1; }
            set { mAux1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Aux 2, -1 .. 1
        /// </summary>
        public float Aux2 {
            get { return mAux2; }
            set { mAux2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Aux 3, -1 .. 1
        /// </summary>
        public float Aux3 {
            get { return mAux3; }
            set { mAux3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Aux 4, -1 .. 1
        /// </summary>
        public float Aux4 {
            get { return mAux4; }
            set { mAux4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System mode (MAV_MODE)
        /// </summary>
        public MavMode Mode {
            get { return mMode; }
            set { mMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Navigation mode (MAV_NAV_MODE)
        /// </summary>
        public byte NavMode {
            get { return mNavMode; }
            set { mNavMode = value; NotifyUpdated(); }
        }

        public UasHilControls()
        {
            mMessageId = 91;
            CrcExtra = 63;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mRollAilerons);
            s.Write(mPitchElevator);
            s.Write(mYawRudder);
            s.Write(mThrottle);
            s.Write(mAux1);
            s.Write(mAux2);
            s.Write(mAux3);
            s.Write(mAux4);
            s.Write((byte)mMode);
            s.Write(mNavMode);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mRollAilerons = s.ReadSingle();
            this.mPitchElevator = s.ReadSingle();
            this.mYawRudder = s.ReadSingle();
            this.mThrottle = s.ReadSingle();
            this.mAux1 = s.ReadSingle();
            this.mAux2 = s.ReadSingle();
            this.mAux3 = s.ReadSingle();
            this.mAux4 = s.ReadSingle();
            this.mMode = (MavMode)s.ReadByte();
            this.mNavMode = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sent from autopilot to simulation. Hardware in the loop control outputs"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds since UNIX epoch or microseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RollAilerons",
                Description = "Control output -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PitchElevator",
                Description = "Control output -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRudder",
                Description = "Control output -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Throttle",
                Description = "Throttle 0 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Aux1",
                Description = "Aux 1, -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Aux2",
                Description = "Aux 2, -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Aux3",
                Description = "Aux 3, -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Aux4",
                Description = "Aux 4, -1 .. 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Mode",
                Description = "System mode (MAV_MODE)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavMode"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "NavMode",
                Description = "Navigation mode (MAV_NAV_MODE)",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mRollAilerons;
        private float mPitchElevator;
        private float mYawRudder;
        private float mThrottle;
        private float mAux1;
        private float mAux2;
        private float mAux3;
        private float mAux4;
        private MavMode mMode;
        private byte mNavMode;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
    /// </summary>
    public class UasHilRcInputsRaw: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch or microseconds since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 1 value, in microseconds
        /// </summary>
        public UInt16 Chan1Raw {
            get { return mChan1Raw; }
            set { mChan1Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 2 value, in microseconds
        /// </summary>
        public UInt16 Chan2Raw {
            get { return mChan2Raw; }
            set { mChan2Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 3 value, in microseconds
        /// </summary>
        public UInt16 Chan3Raw {
            get { return mChan3Raw; }
            set { mChan3Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 4 value, in microseconds
        /// </summary>
        public UInt16 Chan4Raw {
            get { return mChan4Raw; }
            set { mChan4Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 5 value, in microseconds
        /// </summary>
        public UInt16 Chan5Raw {
            get { return mChan5Raw; }
            set { mChan5Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 6 value, in microseconds
        /// </summary>
        public UInt16 Chan6Raw {
            get { return mChan6Raw; }
            set { mChan6Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 7 value, in microseconds
        /// </summary>
        public UInt16 Chan7Raw {
            get { return mChan7Raw; }
            set { mChan7Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 8 value, in microseconds
        /// </summary>
        public UInt16 Chan8Raw {
            get { return mChan8Raw; }
            set { mChan8Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 9 value, in microseconds
        /// </summary>
        public UInt16 Chan9Raw {
            get { return mChan9Raw; }
            set { mChan9Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 10 value, in microseconds
        /// </summary>
        public UInt16 Chan10Raw {
            get { return mChan10Raw; }
            set { mChan10Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 11 value, in microseconds
        /// </summary>
        public UInt16 Chan11Raw {
            get { return mChan11Raw; }
            set { mChan11Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RC channel 12 value, in microseconds
        /// </summary>
        public UInt16 Chan12Raw {
            get { return mChan12Raw; }
            set { mChan12Raw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Receive signal strength indicator, 0: 0%, 255: 100%
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        public UasHilRcInputsRaw()
        {
            mMessageId = 92;
            CrcExtra = 54;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mChan1Raw);
            s.Write(mChan2Raw);
            s.Write(mChan3Raw);
            s.Write(mChan4Raw);
            s.Write(mChan5Raw);
            s.Write(mChan6Raw);
            s.Write(mChan7Raw);
            s.Write(mChan8Raw);
            s.Write(mChan9Raw);
            s.Write(mChan10Raw);
            s.Write(mChan11Raw);
            s.Write(mChan12Raw);
            s.Write(mRssi);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mChan1Raw = s.ReadUInt16();
            this.mChan2Raw = s.ReadUInt16();
            this.mChan3Raw = s.ReadUInt16();
            this.mChan4Raw = s.ReadUInt16();
            this.mChan5Raw = s.ReadUInt16();
            this.mChan6Raw = s.ReadUInt16();
            this.mChan7Raw = s.ReadUInt16();
            this.mChan8Raw = s.ReadUInt16();
            this.mChan9Raw = s.ReadUInt16();
            this.mChan10Raw = s.ReadUInt16();
            this.mChan11Raw = s.ReadUInt16();
            this.mChan12Raw = s.ReadUInt16();
            this.mRssi = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds since UNIX epoch or microseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan1Raw",
                Description = "RC channel 1 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan2Raw",
                Description = "RC channel 2 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan3Raw",
                Description = "RC channel 3 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan4Raw",
                Description = "RC channel 4 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan5Raw",
                Description = "RC channel 5 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan6Raw",
                Description = "RC channel 6 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan7Raw",
                Description = "RC channel 7 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan8Raw",
                Description = "RC channel 8 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan9Raw",
                Description = "RC channel 9 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan10Raw",
                Description = "RC channel 10 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan11Raw",
                Description = "RC channel 11 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Chan12Raw",
                Description = "RC channel 12 value, in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "Receive signal strength indicator, 0: 0%, 255: 100%",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt16 mChan1Raw;
        private UInt16 mChan2Raw;
        private UInt16 mChan3Raw;
        private UInt16 mChan4Raw;
        private UInt16 mChan5Raw;
        private UInt16 mChan6Raw;
        private UInt16 mChan7Raw;
        private UInt16 mChan8Raw;
        private UInt16 mChan9Raw;
        private UInt16 mChan10Raw;
        private UInt16 mChan11Raw;
        private UInt16 mChan12Raw;
        private byte mRssi;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Optical flow from a flow sensor (e.g. optical mouse sensor)
    /// </summary>
    public class UasOpticalFlow: UasMessage
    {
        /// <summary>
        /// Timestamp (UNIX)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in meters in x-sensor direction, angular-speed compensated
        /// </summary>
        public float FlowCompMX {
            get { return mFlowCompMX; }
            set { mFlowCompMX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in meters in y-sensor direction, angular-speed compensated
        /// </summary>
        public float FlowCompMY {
            get { return mFlowCompMY; }
            set { mFlowCompMY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground distance in meters. Positive value: distance known. Negative value: Unknown distance
        /// </summary>
        public float GroundDistance {
            get { return mGroundDistance; }
            set { mGroundDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in pixels * 10 in x-sensor direction (dezi-pixels)
        /// </summary>
        public Int16 FlowX {
            get { return mFlowX; }
            set { mFlowX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in pixels * 10 in y-sensor direction (dezi-pixels)
        /// </summary>
        public Int16 FlowY {
            get { return mFlowY; }
            set { mFlowY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Sensor ID
        /// </summary>
        public byte SensorId {
            get { return mSensorId; }
            set { mSensorId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Optical flow quality / confidence. 0: bad, 255: maximum quality
        /// </summary>
        public byte Quality {
            get { return mQuality; }
            set { mQuality = value; NotifyUpdated(); }
        }

        public UasOpticalFlow()
        {
            mMessageId = 100;
            CrcExtra = 175;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mFlowCompMX);
            s.Write(mFlowCompMY);
            s.Write(mGroundDistance);
            s.Write(mFlowX);
            s.Write(mFlowY);
            s.Write(mSensorId);
            s.Write(mQuality);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mFlowCompMX = s.ReadSingle();
            this.mFlowCompMY = s.ReadSingle();
            this.mGroundDistance = s.ReadSingle();
            this.mFlowX = s.ReadInt16();
            this.mFlowY = s.ReadInt16();
            this.mSensorId = s.ReadByte();
            this.mQuality = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Optical flow from a flow sensor (e.g. optical mouse sensor)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (UNIX)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlowCompMX",
                Description = "Flow in meters in x-sensor direction, angular-speed compensated",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlowCompMY",
                Description = "Flow in meters in y-sensor direction, angular-speed compensated",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GroundDistance",
                Description = "Ground distance in meters. Positive value: distance known. Negative value: Unknown distance",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlowX",
                Description = "Flow in pixels * 10 in x-sensor direction (dezi-pixels)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlowY",
                Description = "Flow in pixels * 10 in y-sensor direction (dezi-pixels)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SensorId",
                Description = "Sensor ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Quality",
                Description = "Optical flow quality / confidence. 0: bad, 255: maximum quality",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mFlowCompMX;
        private float mFlowCompMY;
        private float mGroundDistance;
        private Int16 mFlowX;
        private Int16 mFlowY;
        private byte mSensorId;
        private byte mQuality;
    }


    // ___________________________________________________________________________________


    public class UasGlobalVisionPositionEstimate: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds, synced to UNIX time or since system boot)
        /// </summary>
        public UInt64 Usec {
            get { return mUsec; }
            set { mUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global X position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Y position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Z position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angle in rad
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle in rad
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle in rad
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        public UasGlobalVisionPositionEstimate()
        {
            mMessageId = 101;
            CrcExtra = 102;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = ""
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Usec",
                Description = "Timestamp (microseconds, synced to UNIX time or since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Global X position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Global Y position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Global Z position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle in rad",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle in rad",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle in rad",
                NumElements = 1,
            });

        }

        private UInt64 mUsec;
        private float mX;
        private float mY;
        private float mZ;
        private float mRoll;
        private float mPitch;
        private float mYaw;
    }


    // ___________________________________________________________________________________


    public class UasVisionPositionEstimate: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds, synced to UNIX time or since system boot)
        /// </summary>
        public UInt64 Usec {
            get { return mUsec; }
            set { mUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global X position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Y position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Z position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angle in rad
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle in rad
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle in rad
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        public UasVisionPositionEstimate()
        {
            mMessageId = 102;
            CrcExtra = 158;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = ""
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Usec",
                Description = "Timestamp (microseconds, synced to UNIX time or since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Global X position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Global Y position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Global Z position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle in rad",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle in rad",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle in rad",
                NumElements = 1,
            });

        }

        private UInt64 mUsec;
        private float mX;
        private float mY;
        private float mZ;
        private float mRoll;
        private float mPitch;
        private float mYaw;
    }


    // ___________________________________________________________________________________


    public class UasVisionSpeedEstimate: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds, synced to UNIX time or since system boot)
        /// </summary>
        public UInt64 Usec {
            get { return mUsec; }
            set { mUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global X speed
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Y speed
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Z speed
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        public UasVisionSpeedEstimate()
        {
            mMessageId = 103;
            CrcExtra = 208;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = ""
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Usec",
                Description = "Timestamp (microseconds, synced to UNIX time or since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Global X speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Global Y speed",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Global Z speed",
                NumElements = 1,
            });

        }

        private UInt64 mUsec;
        private float mX;
        private float mY;
        private float mZ;
    }


    // ___________________________________________________________________________________


    public class UasViconPositionEstimate: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds, synced to UNIX time or since system boot)
        /// </summary>
        public UInt64 Usec {
            get { return mUsec; }
            set { mUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global X position
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Y position
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Global Z position
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Roll angle in rad
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle in rad
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle in rad
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        public UasViconPositionEstimate()
        {
            mMessageId = 104;
            CrcExtra = 56;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = ""
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Usec",
                Description = "Timestamp (microseconds, synced to UNIX time or since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Global X position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Global Y position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Global Z position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle in rad",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle in rad",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle in rad",
                NumElements = 1,
            });

        }

        private UInt64 mUsec;
        private float mX;
        private float mY;
        private float mZ;
        private float mRoll;
        private float mPitch;
        private float mYaw;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The IMU readings in SI units in NED body frame
    /// </summary>
    public class UasHighresImu: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds, synced to UNIX time or since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration (m/s^2)
        /// </summary>
        public float Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration (m/s^2)
        /// </summary>
        public float Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration (m/s^2)
        /// </summary>
        public float Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis (rad / sec)
        /// </summary>
        public float Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis (rad / sec)
        /// </summary>
        public float Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis (rad / sec)
        /// </summary>
        public float Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field (Gauss)
        /// </summary>
        public float Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field (Gauss)
        /// </summary>
        public float Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field (Gauss)
        /// </summary>
        public float Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure in millibar
        /// </summary>
        public float AbsPressure {
            get { return mAbsPressure; }
            set { mAbsPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure in millibar
        /// </summary>
        public float DiffPressure {
            get { return mDiffPressure; }
            set { mDiffPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude calculated from pressure
        /// </summary>
        public float PressureAlt {
            get { return mPressureAlt; }
            set { mPressureAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature in degrees celsius
        /// </summary>
        public float Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature
        /// </summary>
        public UInt16 FieldsUpdated {
            get { return mFieldsUpdated; }
            set { mFieldsUpdated = value; NotifyUpdated(); }
        }

        public UasHighresImu()
        {
            mMessageId = 105;
            CrcExtra = 93;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
            s.Write(mAbsPressure);
            s.Write(mDiffPressure);
            s.Write(mPressureAlt);
            s.Write(mTemperature);
            s.Write(mFieldsUpdated);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mXacc = s.ReadSingle();
            this.mYacc = s.ReadSingle();
            this.mZacc = s.ReadSingle();
            this.mXgyro = s.ReadSingle();
            this.mYgyro = s.ReadSingle();
            this.mZgyro = s.ReadSingle();
            this.mXmag = s.ReadSingle();
            this.mYmag = s.ReadSingle();
            this.mZmag = s.ReadSingle();
            this.mAbsPressure = s.ReadSingle();
            this.mDiffPressure = s.ReadSingle();
            this.mPressureAlt = s.ReadSingle();
            this.mTemperature = s.ReadSingle();
            this.mFieldsUpdated = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The IMU readings in SI units in NED body frame"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds, synced to UNIX time or since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration (m/s^2)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration (m/s^2)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration (m/s^2)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis (rad / sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis (rad / sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis (rad / sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field (Gauss)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field (Gauss)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field (Gauss)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AbsPressure",
                Description = "Absolute pressure in millibar",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiffPressure",
                Description = "Differential pressure in millibar",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressureAlt",
                Description = "Altitude calculated from pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature in degrees celsius",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FieldsUpdated",
                Description = "Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mXacc;
        private float mYacc;
        private float mZacc;
        private float mXgyro;
        private float mYgyro;
        private float mZgyro;
        private float mXmag;
        private float mYmag;
        private float mZmag;
        private float mAbsPressure;
        private float mDiffPressure;
        private float mPressureAlt;
        private float mTemperature;
        private UInt16 mFieldsUpdated;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor)
    /// </summary>
    public class UasOpticalFlowRad: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds, synced to UNIX time or since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
        /// </summary>
        public UInt32 IntegrationTimeUs {
            get { return mIntegrationTimeUs; }
            set { mIntegrationTimeUs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
        /// </summary>
        public float IntegratedX {
            get { return mIntegratedX; }
            set { mIntegratedX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
        /// </summary>
        public float IntegratedY {
            get { return mIntegratedY; }
            set { mIntegratedY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around X axis (rad)
        /// </summary>
        public float IntegratedXgyro {
            get { return mIntegratedXgyro; }
            set { mIntegratedXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around Y axis (rad)
        /// </summary>
        public float IntegratedYgyro {
            get { return mIntegratedYgyro; }
            set { mIntegratedYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around Z axis (rad)
        /// </summary>
        public float IntegratedZgyro {
            get { return mIntegratedZgyro; }
            set { mIntegratedZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Time in microseconds since the distance was sampled.
        /// </summary>
        public UInt32 TimeDeltaDistanceUs {
            get { return mTimeDeltaDistanceUs; }
            set { mTimeDeltaDistanceUs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
        /// </summary>
        public float Distance {
            get { return mDistance; }
            set { mDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature * 100 in centi-degrees Celsius
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Sensor ID
        /// </summary>
        public byte SensorId {
            get { return mSensorId; }
            set { mSensorId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
        /// </summary>
        public byte Quality {
            get { return mQuality; }
            set { mQuality = value; NotifyUpdated(); }
        }

        public UasOpticalFlowRad()
        {
            mMessageId = 106;
            CrcExtra = 138;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mIntegrationTimeUs);
            s.Write(mIntegratedX);
            s.Write(mIntegratedY);
            s.Write(mIntegratedXgyro);
            s.Write(mIntegratedYgyro);
            s.Write(mIntegratedZgyro);
            s.Write(mTimeDeltaDistanceUs);
            s.Write(mDistance);
            s.Write(mTemperature);
            s.Write(mSensorId);
            s.Write(mQuality);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mIntegrationTimeUs = s.ReadUInt32();
            this.mIntegratedX = s.ReadSingle();
            this.mIntegratedY = s.ReadSingle();
            this.mIntegratedXgyro = s.ReadSingle();
            this.mIntegratedYgyro = s.ReadSingle();
            this.mIntegratedZgyro = s.ReadSingle();
            this.mTimeDeltaDistanceUs = s.ReadUInt32();
            this.mDistance = s.ReadSingle();
            this.mTemperature = s.ReadInt16();
            this.mSensorId = s.ReadByte();
            this.mQuality = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds, synced to UNIX time or since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegrationTimeUs",
                Description = "Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedX",
                Description = "Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedY",
                Description = "Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedXgyro",
                Description = "RH rotation around X axis (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedYgyro",
                Description = "RH rotation around Y axis (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedZgyro",
                Description = "RH rotation around Z axis (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeDeltaDistanceUs",
                Description = "Time in microseconds since the distance was sampled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Distance",
                Description = "Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature * 100 in centi-degrees Celsius",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SensorId",
                Description = "Sensor ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Quality",
                Description = "Optical flow quality / confidence. 0: no valid flow, 255: maximum quality",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt32 mIntegrationTimeUs;
        private float mIntegratedX;
        private float mIntegratedY;
        private float mIntegratedXgyro;
        private float mIntegratedYgyro;
        private float mIntegratedZgyro;
        private UInt32 mTimeDeltaDistanceUs;
        private float mDistance;
        private Int16 mTemperature;
        private byte mSensorId;
        private byte mQuality;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The IMU readings in SI units in NED body frame
    /// </summary>
    public class UasHilSensor: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds, synced to UNIX time or since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration (m/s^2)
        /// </summary>
        public float Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration (m/s^2)
        /// </summary>
        public float Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration (m/s^2)
        /// </summary>
        public float Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis in body frame (rad / sec)
        /// </summary>
        public float Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis in body frame (rad / sec)
        /// </summary>
        public float Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis in body frame (rad / sec)
        /// </summary>
        public float Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field (Gauss)
        /// </summary>
        public float Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field (Gauss)
        /// </summary>
        public float Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field (Gauss)
        /// </summary>
        public float Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure in millibar
        /// </summary>
        public float AbsPressure {
            get { return mAbsPressure; }
            set { mAbsPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure (airspeed) in millibar
        /// </summary>
        public float DiffPressure {
            get { return mDiffPressure; }
            set { mDiffPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude calculated from pressure
        /// </summary>
        public float PressureAlt {
            get { return mPressureAlt; }
            set { mPressureAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature in degrees celsius
        /// </summary>
        public float Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature, bit 31: full reset of attitude/position/velocities/etc was performed in sim.
        /// </summary>
        public UInt32 FieldsUpdated {
            get { return mFieldsUpdated; }
            set { mFieldsUpdated = value; NotifyUpdated(); }
        }

        public UasHilSensor()
        {
            mMessageId = 107;
            CrcExtra = 108;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
            s.Write(mAbsPressure);
            s.Write(mDiffPressure);
            s.Write(mPressureAlt);
            s.Write(mTemperature);
            s.Write(mFieldsUpdated);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mXacc = s.ReadSingle();
            this.mYacc = s.ReadSingle();
            this.mZacc = s.ReadSingle();
            this.mXgyro = s.ReadSingle();
            this.mYgyro = s.ReadSingle();
            this.mZgyro = s.ReadSingle();
            this.mXmag = s.ReadSingle();
            this.mYmag = s.ReadSingle();
            this.mZmag = s.ReadSingle();
            this.mAbsPressure = s.ReadSingle();
            this.mDiffPressure = s.ReadSingle();
            this.mPressureAlt = s.ReadSingle();
            this.mTemperature = s.ReadSingle();
            this.mFieldsUpdated = s.ReadUInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The IMU readings in SI units in NED body frame"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds, synced to UNIX time or since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration (m/s^2)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration (m/s^2)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration (m/s^2)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis in body frame (rad / sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis in body frame (rad / sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis in body frame (rad / sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field (Gauss)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field (Gauss)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field (Gauss)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AbsPressure",
                Description = "Absolute pressure in millibar",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiffPressure",
                Description = "Differential pressure (airspeed) in millibar",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressureAlt",
                Description = "Altitude calculated from pressure",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature in degrees celsius",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FieldsUpdated",
                Description = "Bitmask for fields that have updated since last message, bit 0 = xacc, bit 12: temperature, bit 31: full reset of attitude/position/velocities/etc was performed in sim.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mXacc;
        private float mYacc;
        private float mZacc;
        private float mXgyro;
        private float mYgyro;
        private float mZgyro;
        private float mXmag;
        private float mYmag;
        private float mZmag;
        private float mAbsPressure;
        private float mDiffPressure;
        private float mPressureAlt;
        private float mTemperature;
        private UInt32 mFieldsUpdated;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of simulation environment, if used
    /// </summary>
    public class UasSimState: UasMessage
    {
        /// <summary>
        /// True attitude quaternion component 1, w (1 in null-rotation)
        /// </summary>
        public float Q1 {
            get { return mQ1; }
            set { mQ1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True attitude quaternion component 2, x (0 in null-rotation)
        /// </summary>
        public float Q2 {
            get { return mQ2; }
            set { mQ2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True attitude quaternion component 3, y (0 in null-rotation)
        /// </summary>
        public float Q3 {
            get { return mQ3; }
            set { mQ3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True attitude quaternion component 4, z (0 in null-rotation)
        /// </summary>
        public float Q4 {
            get { return mQ4; }
            set { mQ4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude roll expressed as Euler angles, not recommended except for human-readable outputs
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration m/s/s
        /// </summary>
        public float Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration m/s/s
        /// </summary>
        public float Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration m/s/s
        /// </summary>
        public float Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis rad/s
        /// </summary>
        public float Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis rad/s
        /// </summary>
        public float Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis rad/s
        /// </summary>
        public float Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude in degrees
        /// </summary>
        public float Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude in degrees
        /// </summary>
        public float Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude in meters
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Horizontal position standard deviation
        /// </summary>
        public float StdDevHorz {
            get { return mStdDevHorz; }
            set { mStdDevHorz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vertical position standard deviation
        /// </summary>
        public float StdDevVert {
            get { return mStdDevVert; }
            set { mStdDevVert = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True velocity in m/s in NORTH direction in earth-fixed NED frame
        /// </summary>
        public float Vn {
            get { return mVn; }
            set { mVn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True velocity in m/s in EAST direction in earth-fixed NED frame
        /// </summary>
        public float Ve {
            get { return mVe; }
            set { mVe = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True velocity in m/s in DOWN direction in earth-fixed NED frame
        /// </summary>
        public float Vd {
            get { return mVd; }
            set { mVd = value; NotifyUpdated(); }
        }

        public UasSimState()
        {
            mMessageId = 108;
            CrcExtra = 32;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mQ1);
            s.Write(mQ2);
            s.Write(mQ3);
            s.Write(mQ4);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mStdDevHorz);
            s.Write(mStdDevVert);
            s.Write(mVn);
            s.Write(mVe);
            s.Write(mVd);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mQ1 = s.ReadSingle();
            this.mQ2 = s.ReadSingle();
            this.mQ3 = s.ReadSingle();
            this.mQ4 = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mXacc = s.ReadSingle();
            this.mYacc = s.ReadSingle();
            this.mZacc = s.ReadSingle();
            this.mXgyro = s.ReadSingle();
            this.mYgyro = s.ReadSingle();
            this.mZgyro = s.ReadSingle();
            this.mLat = s.ReadSingle();
            this.mLon = s.ReadSingle();
            this.mAlt = s.ReadSingle();
            this.mStdDevHorz = s.ReadSingle();
            this.mStdDevVert = s.ReadSingle();
            this.mVn = s.ReadSingle();
            this.mVe = s.ReadSingle();
            this.mVd = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of simulation environment, if used"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q1",
                Description = "True attitude quaternion component 1, w (1 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q2",
                Description = "True attitude quaternion component 2, x (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q3",
                Description = "True attitude quaternion component 3, y (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q4",
                Description = "True attitude quaternion component 4, z (0 in null-rotation)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Attitude roll expressed as Euler angles, not recommended except for human-readable outputs",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration m/s/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration m/s/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration m/s/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude in degrees",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude in degrees",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StdDevHorz",
                Description = "Horizontal position standard deviation",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StdDevVert",
                Description = "Vertical position standard deviation",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vn",
                Description = "True velocity in m/s in NORTH direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ve",
                Description = "True velocity in m/s in EAST direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vd",
                Description = "True velocity in m/s in DOWN direction in earth-fixed NED frame",
                NumElements = 1,
            });

        }

        private float mQ1;
        private float mQ2;
        private float mQ3;
        private float mQ4;
        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mXacc;
        private float mYacc;
        private float mZacc;
        private float mXgyro;
        private float mYgyro;
        private float mZgyro;
        private float mLat;
        private float mLon;
        private float mAlt;
        private float mStdDevHorz;
        private float mStdDevVert;
        private float mVn;
        private float mVe;
        private float mVd;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status generated by radio and injected into MAVLink stream.
    /// </summary>
    public class UasRadioStatus: UasMessage
    {
        /// <summary>
        /// Receive errors
        /// </summary>
        public UInt16 Rxerrors {
            get { return mRxerrors; }
            set { mRxerrors = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Count of error corrected packets
        /// </summary>
        public UInt16 Fixed {
            get { return mFixed; }
            set { mFixed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local signal strength
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remote signal strength
        /// </summary>
        public byte Remrssi {
            get { return mRemrssi; }
            set { mRemrssi = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remaining free buffer space in percent.
        /// </summary>
        public byte Txbuf {
            get { return mTxbuf; }
            set { mTxbuf = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Background noise level
        /// </summary>
        public byte Noise {
            get { return mNoise; }
            set { mNoise = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remote background noise level
        /// </summary>
        public byte Remnoise {
            get { return mRemnoise; }
            set { mRemnoise = value; NotifyUpdated(); }
        }

        public UasRadioStatus()
        {
            mMessageId = 109;
            CrcExtra = 185;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mRxerrors);
            s.Write(mFixed);
            s.Write(mRssi);
            s.Write(mRemrssi);
            s.Write(mTxbuf);
            s.Write(mNoise);
            s.Write(mRemnoise);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mRxerrors = s.ReadUInt16();
            this.mFixed = s.ReadUInt16();
            this.mRssi = s.ReadByte();
            this.mRemrssi = s.ReadByte();
            this.mTxbuf = s.ReadByte();
            this.mNoise = s.ReadByte();
            this.mRemnoise = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status generated by radio and injected into MAVLink stream."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rxerrors",
                Description = "Receive errors",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Fixed",
                Description = "Count of error corrected packets",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "Local signal strength",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Remrssi",
                Description = "Remote signal strength",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Txbuf",
                Description = "Remaining free buffer space in percent.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Noise",
                Description = "Background noise level",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Remnoise",
                Description = "Remote background noise level",
                NumElements = 1,
            });

        }

        private UInt16 mRxerrors;
        private UInt16 mFixed;
        private byte mRssi;
        private byte mRemrssi;
        private byte mTxbuf;
        private byte mNoise;
        private byte mRemnoise;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// File transfer message
    /// </summary>
    public class UasFileTransferProtocol: UasMessage
    {
        /// <summary>
        /// Network ID (0 for broadcast)
        /// </summary>
        public byte TargetNetwork {
            get { return mTargetNetwork; }
            set { mTargetNetwork = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID (0 for broadcast)
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID (0 for broadcast)
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
        /// </summary>
        public byte[] Payload {
            get { return mPayload; }
            set { mPayload = value; NotifyUpdated(); }
        }

        public UasFileTransferProtocol()
        {
            mMessageId = 110;
            CrcExtra = 84;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetNetwork);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mPayload[0]); 
            s.Write(mPayload[1]); 
            s.Write(mPayload[2]); 
            s.Write(mPayload[3]); 
            s.Write(mPayload[4]); 
            s.Write(mPayload[5]); 
            s.Write(mPayload[6]); 
            s.Write(mPayload[7]); 
            s.Write(mPayload[8]); 
            s.Write(mPayload[9]); 
            s.Write(mPayload[10]); 
            s.Write(mPayload[11]); 
            s.Write(mPayload[12]); 
            s.Write(mPayload[13]); 
            s.Write(mPayload[14]); 
            s.Write(mPayload[15]); 
            s.Write(mPayload[16]); 
            s.Write(mPayload[17]); 
            s.Write(mPayload[18]); 
            s.Write(mPayload[19]); 
            s.Write(mPayload[20]); 
            s.Write(mPayload[21]); 
            s.Write(mPayload[22]); 
            s.Write(mPayload[23]); 
            s.Write(mPayload[24]); 
            s.Write(mPayload[25]); 
            s.Write(mPayload[26]); 
            s.Write(mPayload[27]); 
            s.Write(mPayload[28]); 
            s.Write(mPayload[29]); 
            s.Write(mPayload[30]); 
            s.Write(mPayload[31]); 
            s.Write(mPayload[32]); 
            s.Write(mPayload[33]); 
            s.Write(mPayload[34]); 
            s.Write(mPayload[35]); 
            s.Write(mPayload[36]); 
            s.Write(mPayload[37]); 
            s.Write(mPayload[38]); 
            s.Write(mPayload[39]); 
            s.Write(mPayload[40]); 
            s.Write(mPayload[41]); 
            s.Write(mPayload[42]); 
            s.Write(mPayload[43]); 
            s.Write(mPayload[44]); 
            s.Write(mPayload[45]); 
            s.Write(mPayload[46]); 
            s.Write(mPayload[47]); 
            s.Write(mPayload[48]); 
            s.Write(mPayload[49]); 
            s.Write(mPayload[50]); 
            s.Write(mPayload[51]); 
            s.Write(mPayload[52]); 
            s.Write(mPayload[53]); 
            s.Write(mPayload[54]); 
            s.Write(mPayload[55]); 
            s.Write(mPayload[56]); 
            s.Write(mPayload[57]); 
            s.Write(mPayload[58]); 
            s.Write(mPayload[59]); 
            s.Write(mPayload[60]); 
            s.Write(mPayload[61]); 
            s.Write(mPayload[62]); 
            s.Write(mPayload[63]); 
            s.Write(mPayload[64]); 
            s.Write(mPayload[65]); 
            s.Write(mPayload[66]); 
            s.Write(mPayload[67]); 
            s.Write(mPayload[68]); 
            s.Write(mPayload[69]); 
            s.Write(mPayload[70]); 
            s.Write(mPayload[71]); 
            s.Write(mPayload[72]); 
            s.Write(mPayload[73]); 
            s.Write(mPayload[74]); 
            s.Write(mPayload[75]); 
            s.Write(mPayload[76]); 
            s.Write(mPayload[77]); 
            s.Write(mPayload[78]); 
            s.Write(mPayload[79]); 
            s.Write(mPayload[80]); 
            s.Write(mPayload[81]); 
            s.Write(mPayload[82]); 
            s.Write(mPayload[83]); 
            s.Write(mPayload[84]); 
            s.Write(mPayload[85]); 
            s.Write(mPayload[86]); 
            s.Write(mPayload[87]); 
            s.Write(mPayload[88]); 
            s.Write(mPayload[89]); 
            s.Write(mPayload[90]); 
            s.Write(mPayload[91]); 
            s.Write(mPayload[92]); 
            s.Write(mPayload[93]); 
            s.Write(mPayload[94]); 
            s.Write(mPayload[95]); 
            s.Write(mPayload[96]); 
            s.Write(mPayload[97]); 
            s.Write(mPayload[98]); 
            s.Write(mPayload[99]); 
            s.Write(mPayload[100]); 
            s.Write(mPayload[101]); 
            s.Write(mPayload[102]); 
            s.Write(mPayload[103]); 
            s.Write(mPayload[104]); 
            s.Write(mPayload[105]); 
            s.Write(mPayload[106]); 
            s.Write(mPayload[107]); 
            s.Write(mPayload[108]); 
            s.Write(mPayload[109]); 
            s.Write(mPayload[110]); 
            s.Write(mPayload[111]); 
            s.Write(mPayload[112]); 
            s.Write(mPayload[113]); 
            s.Write(mPayload[114]); 
            s.Write(mPayload[115]); 
            s.Write(mPayload[116]); 
            s.Write(mPayload[117]); 
            s.Write(mPayload[118]); 
            s.Write(mPayload[119]); 
            s.Write(mPayload[120]); 
            s.Write(mPayload[121]); 
            s.Write(mPayload[122]); 
            s.Write(mPayload[123]); 
            s.Write(mPayload[124]); 
            s.Write(mPayload[125]); 
            s.Write(mPayload[126]); 
            s.Write(mPayload[127]); 
            s.Write(mPayload[128]); 
            s.Write(mPayload[129]); 
            s.Write(mPayload[130]); 
            s.Write(mPayload[131]); 
            s.Write(mPayload[132]); 
            s.Write(mPayload[133]); 
            s.Write(mPayload[134]); 
            s.Write(mPayload[135]); 
            s.Write(mPayload[136]); 
            s.Write(mPayload[137]); 
            s.Write(mPayload[138]); 
            s.Write(mPayload[139]); 
            s.Write(mPayload[140]); 
            s.Write(mPayload[141]); 
            s.Write(mPayload[142]); 
            s.Write(mPayload[143]); 
            s.Write(mPayload[144]); 
            s.Write(mPayload[145]); 
            s.Write(mPayload[146]); 
            s.Write(mPayload[147]); 
            s.Write(mPayload[148]); 
            s.Write(mPayload[149]); 
            s.Write(mPayload[150]); 
            s.Write(mPayload[151]); 
            s.Write(mPayload[152]); 
            s.Write(mPayload[153]); 
            s.Write(mPayload[154]); 
            s.Write(mPayload[155]); 
            s.Write(mPayload[156]); 
            s.Write(mPayload[157]); 
            s.Write(mPayload[158]); 
            s.Write(mPayload[159]); 
            s.Write(mPayload[160]); 
            s.Write(mPayload[161]); 
            s.Write(mPayload[162]); 
            s.Write(mPayload[163]); 
            s.Write(mPayload[164]); 
            s.Write(mPayload[165]); 
            s.Write(mPayload[166]); 
            s.Write(mPayload[167]); 
            s.Write(mPayload[168]); 
            s.Write(mPayload[169]); 
            s.Write(mPayload[170]); 
            s.Write(mPayload[171]); 
            s.Write(mPayload[172]); 
            s.Write(mPayload[173]); 
            s.Write(mPayload[174]); 
            s.Write(mPayload[175]); 
            s.Write(mPayload[176]); 
            s.Write(mPayload[177]); 
            s.Write(mPayload[178]); 
            s.Write(mPayload[179]); 
            s.Write(mPayload[180]); 
            s.Write(mPayload[181]); 
            s.Write(mPayload[182]); 
            s.Write(mPayload[183]); 
            s.Write(mPayload[184]); 
            s.Write(mPayload[185]); 
            s.Write(mPayload[186]); 
            s.Write(mPayload[187]); 
            s.Write(mPayload[188]); 
            s.Write(mPayload[189]); 
            s.Write(mPayload[190]); 
            s.Write(mPayload[191]); 
            s.Write(mPayload[192]); 
            s.Write(mPayload[193]); 
            s.Write(mPayload[194]); 
            s.Write(mPayload[195]); 
            s.Write(mPayload[196]); 
            s.Write(mPayload[197]); 
            s.Write(mPayload[198]); 
            s.Write(mPayload[199]); 
            s.Write(mPayload[200]); 
            s.Write(mPayload[201]); 
            s.Write(mPayload[202]); 
            s.Write(mPayload[203]); 
            s.Write(mPayload[204]); 
            s.Write(mPayload[205]); 
            s.Write(mPayload[206]); 
            s.Write(mPayload[207]); 
            s.Write(mPayload[208]); 
            s.Write(mPayload[209]); 
            s.Write(mPayload[210]); 
            s.Write(mPayload[211]); 
            s.Write(mPayload[212]); 
            s.Write(mPayload[213]); 
            s.Write(mPayload[214]); 
            s.Write(mPayload[215]); 
            s.Write(mPayload[216]); 
            s.Write(mPayload[217]); 
            s.Write(mPayload[218]); 
            s.Write(mPayload[219]); 
            s.Write(mPayload[220]); 
            s.Write(mPayload[221]); 
            s.Write(mPayload[222]); 
            s.Write(mPayload[223]); 
            s.Write(mPayload[224]); 
            s.Write(mPayload[225]); 
            s.Write(mPayload[226]); 
            s.Write(mPayload[227]); 
            s.Write(mPayload[228]); 
            s.Write(mPayload[229]); 
            s.Write(mPayload[230]); 
            s.Write(mPayload[231]); 
            s.Write(mPayload[232]); 
            s.Write(mPayload[233]); 
            s.Write(mPayload[234]); 
            s.Write(mPayload[235]); 
            s.Write(mPayload[236]); 
            s.Write(mPayload[237]); 
            s.Write(mPayload[238]); 
            s.Write(mPayload[239]); 
            s.Write(mPayload[240]); 
            s.Write(mPayload[241]); 
            s.Write(mPayload[242]); 
            s.Write(mPayload[243]); 
            s.Write(mPayload[244]); 
            s.Write(mPayload[245]); 
            s.Write(mPayload[246]); 
            s.Write(mPayload[247]); 
            s.Write(mPayload[248]); 
            s.Write(mPayload[249]); 
            s.Write(mPayload[250]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetNetwork = s.ReadByte();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mPayload[0] = s.ReadByte();
            this.mPayload[1] = s.ReadByte();
            this.mPayload[2] = s.ReadByte();
            this.mPayload[3] = s.ReadByte();
            this.mPayload[4] = s.ReadByte();
            this.mPayload[5] = s.ReadByte();
            this.mPayload[6] = s.ReadByte();
            this.mPayload[7] = s.ReadByte();
            this.mPayload[8] = s.ReadByte();
            this.mPayload[9] = s.ReadByte();
            this.mPayload[10] = s.ReadByte();
            this.mPayload[11] = s.ReadByte();
            this.mPayload[12] = s.ReadByte();
            this.mPayload[13] = s.ReadByte();
            this.mPayload[14] = s.ReadByte();
            this.mPayload[15] = s.ReadByte();
            this.mPayload[16] = s.ReadByte();
            this.mPayload[17] = s.ReadByte();
            this.mPayload[18] = s.ReadByte();
            this.mPayload[19] = s.ReadByte();
            this.mPayload[20] = s.ReadByte();
            this.mPayload[21] = s.ReadByte();
            this.mPayload[22] = s.ReadByte();
            this.mPayload[23] = s.ReadByte();
            this.mPayload[24] = s.ReadByte();
            this.mPayload[25] = s.ReadByte();
            this.mPayload[26] = s.ReadByte();
            this.mPayload[27] = s.ReadByte();
            this.mPayload[28] = s.ReadByte();
            this.mPayload[29] = s.ReadByte();
            this.mPayload[30] = s.ReadByte();
            this.mPayload[31] = s.ReadByte();
            this.mPayload[32] = s.ReadByte();
            this.mPayload[33] = s.ReadByte();
            this.mPayload[34] = s.ReadByte();
            this.mPayload[35] = s.ReadByte();
            this.mPayload[36] = s.ReadByte();
            this.mPayload[37] = s.ReadByte();
            this.mPayload[38] = s.ReadByte();
            this.mPayload[39] = s.ReadByte();
            this.mPayload[40] = s.ReadByte();
            this.mPayload[41] = s.ReadByte();
            this.mPayload[42] = s.ReadByte();
            this.mPayload[43] = s.ReadByte();
            this.mPayload[44] = s.ReadByte();
            this.mPayload[45] = s.ReadByte();
            this.mPayload[46] = s.ReadByte();
            this.mPayload[47] = s.ReadByte();
            this.mPayload[48] = s.ReadByte();
            this.mPayload[49] = s.ReadByte();
            this.mPayload[50] = s.ReadByte();
            this.mPayload[51] = s.ReadByte();
            this.mPayload[52] = s.ReadByte();
            this.mPayload[53] = s.ReadByte();
            this.mPayload[54] = s.ReadByte();
            this.mPayload[55] = s.ReadByte();
            this.mPayload[56] = s.ReadByte();
            this.mPayload[57] = s.ReadByte();
            this.mPayload[58] = s.ReadByte();
            this.mPayload[59] = s.ReadByte();
            this.mPayload[60] = s.ReadByte();
            this.mPayload[61] = s.ReadByte();
            this.mPayload[62] = s.ReadByte();
            this.mPayload[63] = s.ReadByte();
            this.mPayload[64] = s.ReadByte();
            this.mPayload[65] = s.ReadByte();
            this.mPayload[66] = s.ReadByte();
            this.mPayload[67] = s.ReadByte();
            this.mPayload[68] = s.ReadByte();
            this.mPayload[69] = s.ReadByte();
            this.mPayload[70] = s.ReadByte();
            this.mPayload[71] = s.ReadByte();
            this.mPayload[72] = s.ReadByte();
            this.mPayload[73] = s.ReadByte();
            this.mPayload[74] = s.ReadByte();
            this.mPayload[75] = s.ReadByte();
            this.mPayload[76] = s.ReadByte();
            this.mPayload[77] = s.ReadByte();
            this.mPayload[78] = s.ReadByte();
            this.mPayload[79] = s.ReadByte();
            this.mPayload[80] = s.ReadByte();
            this.mPayload[81] = s.ReadByte();
            this.mPayload[82] = s.ReadByte();
            this.mPayload[83] = s.ReadByte();
            this.mPayload[84] = s.ReadByte();
            this.mPayload[85] = s.ReadByte();
            this.mPayload[86] = s.ReadByte();
            this.mPayload[87] = s.ReadByte();
            this.mPayload[88] = s.ReadByte();
            this.mPayload[89] = s.ReadByte();
            this.mPayload[90] = s.ReadByte();
            this.mPayload[91] = s.ReadByte();
            this.mPayload[92] = s.ReadByte();
            this.mPayload[93] = s.ReadByte();
            this.mPayload[94] = s.ReadByte();
            this.mPayload[95] = s.ReadByte();
            this.mPayload[96] = s.ReadByte();
            this.mPayload[97] = s.ReadByte();
            this.mPayload[98] = s.ReadByte();
            this.mPayload[99] = s.ReadByte();
            this.mPayload[100] = s.ReadByte();
            this.mPayload[101] = s.ReadByte();
            this.mPayload[102] = s.ReadByte();
            this.mPayload[103] = s.ReadByte();
            this.mPayload[104] = s.ReadByte();
            this.mPayload[105] = s.ReadByte();
            this.mPayload[106] = s.ReadByte();
            this.mPayload[107] = s.ReadByte();
            this.mPayload[108] = s.ReadByte();
            this.mPayload[109] = s.ReadByte();
            this.mPayload[110] = s.ReadByte();
            this.mPayload[111] = s.ReadByte();
            this.mPayload[112] = s.ReadByte();
            this.mPayload[113] = s.ReadByte();
            this.mPayload[114] = s.ReadByte();
            this.mPayload[115] = s.ReadByte();
            this.mPayload[116] = s.ReadByte();
            this.mPayload[117] = s.ReadByte();
            this.mPayload[118] = s.ReadByte();
            this.mPayload[119] = s.ReadByte();
            this.mPayload[120] = s.ReadByte();
            this.mPayload[121] = s.ReadByte();
            this.mPayload[122] = s.ReadByte();
            this.mPayload[123] = s.ReadByte();
            this.mPayload[124] = s.ReadByte();
            this.mPayload[125] = s.ReadByte();
            this.mPayload[126] = s.ReadByte();
            this.mPayload[127] = s.ReadByte();
            this.mPayload[128] = s.ReadByte();
            this.mPayload[129] = s.ReadByte();
            this.mPayload[130] = s.ReadByte();
            this.mPayload[131] = s.ReadByte();
            this.mPayload[132] = s.ReadByte();
            this.mPayload[133] = s.ReadByte();
            this.mPayload[134] = s.ReadByte();
            this.mPayload[135] = s.ReadByte();
            this.mPayload[136] = s.ReadByte();
            this.mPayload[137] = s.ReadByte();
            this.mPayload[138] = s.ReadByte();
            this.mPayload[139] = s.ReadByte();
            this.mPayload[140] = s.ReadByte();
            this.mPayload[141] = s.ReadByte();
            this.mPayload[142] = s.ReadByte();
            this.mPayload[143] = s.ReadByte();
            this.mPayload[144] = s.ReadByte();
            this.mPayload[145] = s.ReadByte();
            this.mPayload[146] = s.ReadByte();
            this.mPayload[147] = s.ReadByte();
            this.mPayload[148] = s.ReadByte();
            this.mPayload[149] = s.ReadByte();
            this.mPayload[150] = s.ReadByte();
            this.mPayload[151] = s.ReadByte();
            this.mPayload[152] = s.ReadByte();
            this.mPayload[153] = s.ReadByte();
            this.mPayload[154] = s.ReadByte();
            this.mPayload[155] = s.ReadByte();
            this.mPayload[156] = s.ReadByte();
            this.mPayload[157] = s.ReadByte();
            this.mPayload[158] = s.ReadByte();
            this.mPayload[159] = s.ReadByte();
            this.mPayload[160] = s.ReadByte();
            this.mPayload[161] = s.ReadByte();
            this.mPayload[162] = s.ReadByte();
            this.mPayload[163] = s.ReadByte();
            this.mPayload[164] = s.ReadByte();
            this.mPayload[165] = s.ReadByte();
            this.mPayload[166] = s.ReadByte();
            this.mPayload[167] = s.ReadByte();
            this.mPayload[168] = s.ReadByte();
            this.mPayload[169] = s.ReadByte();
            this.mPayload[170] = s.ReadByte();
            this.mPayload[171] = s.ReadByte();
            this.mPayload[172] = s.ReadByte();
            this.mPayload[173] = s.ReadByte();
            this.mPayload[174] = s.ReadByte();
            this.mPayload[175] = s.ReadByte();
            this.mPayload[176] = s.ReadByte();
            this.mPayload[177] = s.ReadByte();
            this.mPayload[178] = s.ReadByte();
            this.mPayload[179] = s.ReadByte();
            this.mPayload[180] = s.ReadByte();
            this.mPayload[181] = s.ReadByte();
            this.mPayload[182] = s.ReadByte();
            this.mPayload[183] = s.ReadByte();
            this.mPayload[184] = s.ReadByte();
            this.mPayload[185] = s.ReadByte();
            this.mPayload[186] = s.ReadByte();
            this.mPayload[187] = s.ReadByte();
            this.mPayload[188] = s.ReadByte();
            this.mPayload[189] = s.ReadByte();
            this.mPayload[190] = s.ReadByte();
            this.mPayload[191] = s.ReadByte();
            this.mPayload[192] = s.ReadByte();
            this.mPayload[193] = s.ReadByte();
            this.mPayload[194] = s.ReadByte();
            this.mPayload[195] = s.ReadByte();
            this.mPayload[196] = s.ReadByte();
            this.mPayload[197] = s.ReadByte();
            this.mPayload[198] = s.ReadByte();
            this.mPayload[199] = s.ReadByte();
            this.mPayload[200] = s.ReadByte();
            this.mPayload[201] = s.ReadByte();
            this.mPayload[202] = s.ReadByte();
            this.mPayload[203] = s.ReadByte();
            this.mPayload[204] = s.ReadByte();
            this.mPayload[205] = s.ReadByte();
            this.mPayload[206] = s.ReadByte();
            this.mPayload[207] = s.ReadByte();
            this.mPayload[208] = s.ReadByte();
            this.mPayload[209] = s.ReadByte();
            this.mPayload[210] = s.ReadByte();
            this.mPayload[211] = s.ReadByte();
            this.mPayload[212] = s.ReadByte();
            this.mPayload[213] = s.ReadByte();
            this.mPayload[214] = s.ReadByte();
            this.mPayload[215] = s.ReadByte();
            this.mPayload[216] = s.ReadByte();
            this.mPayload[217] = s.ReadByte();
            this.mPayload[218] = s.ReadByte();
            this.mPayload[219] = s.ReadByte();
            this.mPayload[220] = s.ReadByte();
            this.mPayload[221] = s.ReadByte();
            this.mPayload[222] = s.ReadByte();
            this.mPayload[223] = s.ReadByte();
            this.mPayload[224] = s.ReadByte();
            this.mPayload[225] = s.ReadByte();
            this.mPayload[226] = s.ReadByte();
            this.mPayload[227] = s.ReadByte();
            this.mPayload[228] = s.ReadByte();
            this.mPayload[229] = s.ReadByte();
            this.mPayload[230] = s.ReadByte();
            this.mPayload[231] = s.ReadByte();
            this.mPayload[232] = s.ReadByte();
            this.mPayload[233] = s.ReadByte();
            this.mPayload[234] = s.ReadByte();
            this.mPayload[235] = s.ReadByte();
            this.mPayload[236] = s.ReadByte();
            this.mPayload[237] = s.ReadByte();
            this.mPayload[238] = s.ReadByte();
            this.mPayload[239] = s.ReadByte();
            this.mPayload[240] = s.ReadByte();
            this.mPayload[241] = s.ReadByte();
            this.mPayload[242] = s.ReadByte();
            this.mPayload[243] = s.ReadByte();
            this.mPayload[244] = s.ReadByte();
            this.mPayload[245] = s.ReadByte();
            this.mPayload[246] = s.ReadByte();
            this.mPayload[247] = s.ReadByte();
            this.mPayload[248] = s.ReadByte();
            this.mPayload[249] = s.ReadByte();
            this.mPayload[250] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "File transfer message"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetNetwork",
                Description = "Network ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Payload",
                Description = "Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.",
                NumElements = 251,
            });

        }

        private byte mTargetNetwork;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte[] mPayload = new byte[251];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Time synchronization message.
    /// </summary>
    public class UasTimesync: UasMessage
    {
        /// <summary>
        /// Time sync timestamp 1
        /// </summary>
        public Int64 Tc1 {
            get { return mTc1; }
            set { mTc1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Time sync timestamp 2
        /// </summary>
        public Int64 Ts1 {
            get { return mTs1; }
            set { mTs1 = value; NotifyUpdated(); }
        }

        public UasTimesync()
        {
            mMessageId = 111;
            CrcExtra = 34;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTc1);
            s.Write(mTs1);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTc1 = s.ReadInt64();
            this.mTs1 = s.ReadInt64();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Time synchronization message."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Tc1",
                Description = "Time sync timestamp 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ts1",
                Description = "Time sync timestamp 2",
                NumElements = 1,
            });

        }

        private Int64 mTc1;
        private Int64 mTs1;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Camera-IMU triggering and synchronisation message.
    /// </summary>
    public class UasCameraTrigger: UasMessage
    {
        /// <summary>
        /// Timestamp for the image frame in microseconds
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Image frame sequence
        /// </summary>
        public UInt32 Seq {
            get { return mSeq; }
            set { mSeq = value; NotifyUpdated(); }
        }

        public UasCameraTrigger()
        {
            mMessageId = 112;
            CrcExtra = 174;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mSeq);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mSeq = s.ReadUInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Camera-IMU triggering and synchronisation message."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp for the image frame in microseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seq",
                Description = "Image frame sequence",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt32 mSeq;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The global position, as returned by the Global Positioning System (GPS). This is                  NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame).
    /// </summary>
    public class UasHilGps: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch or microseconds since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535
        /// </summary>
        public UInt16 Eph {
            get { return mEph; }
            set { mEph = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: 65535
        /// </summary>
        public UInt16 Epv {
            get { return mEpv; }
            set { mEpv = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS ground speed (m/s * 100). If unknown, set to: 65535
        /// </summary>
        public UInt16 Vel {
            get { return mVel; }
            set { mVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity in cm/s in NORTH direction in earth-fixed NED frame
        /// </summary>
        public Int16 Vn {
            get { return mVn; }
            set { mVn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity in cm/s in EAST direction in earth-fixed NED frame
        /// </summary>
        public Int16 Ve {
            get { return mVe; }
            set { mVe = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity in cm/s in DOWN direction in earth-fixed NED frame
        /// </summary>
        public Int16 Vd {
            get { return mVd; }
            set { mVd = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535
        /// </summary>
        public UInt16 Cog {
            get { return mCog; }
            set { mCog = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
        /// </summary>
        public byte FixType {
            get { return mFixType; }
            set { mFixType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of satellites visible. If unknown, set to 255
        /// </summary>
        public byte SatellitesVisible {
            get { return mSatellitesVisible; }
            set { mSatellitesVisible = value; NotifyUpdated(); }
        }

        public UasHilGps()
        {
            mMessageId = 113;
            CrcExtra = 124;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mEph);
            s.Write(mEpv);
            s.Write(mVel);
            s.Write(mVn);
            s.Write(mVe);
            s.Write(mVd);
            s.Write(mCog);
            s.Write(mFixType);
            s.Write(mSatellitesVisible);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mEph = s.ReadUInt16();
            this.mEpv = s.ReadUInt16();
            this.mVel = s.ReadUInt16();
            this.mVn = s.ReadInt16();
            this.mVe = s.ReadInt16();
            this.mVd = s.ReadInt16();
            this.mCog = s.ReadUInt16();
            this.mFixType = s.ReadByte();
            this.mSatellitesVisible = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The global position, as returned by the Global Positioning System (GPS). This is                  NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds since UNIX epoch or microseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Eph",
                Description = "GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: 65535",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Epv",
                Description = "GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: 65535",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vel",
                Description = "GPS ground speed (m/s * 100). If unknown, set to: 65535",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vn",
                Description = "GPS velocity in cm/s in NORTH direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ve",
                Description = "GPS velocity in cm/s in EAST direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vd",
                Description = "GPS velocity in cm/s in DOWN direction in earth-fixed NED frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Cog",
                Description = "Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: 65535",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FixType",
                Description = "0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitesVisible",
                Description = "Number of satellites visible. If unknown, set to 255",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private UInt16 mEph;
        private UInt16 mEpv;
        private UInt16 mVel;
        private Int16 mVn;
        private Int16 mVe;
        private Int16 mVd;
        private UInt16 mCog;
        private byte mFixType;
        private byte mSatellitesVisible;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor)
    /// </summary>
    public class UasHilOpticalFlow: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds, synced to UNIX time or since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
        /// </summary>
        public UInt32 IntegrationTimeUs {
            get { return mIntegrationTimeUs; }
            set { mIntegrationTimeUs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
        /// </summary>
        public float IntegratedX {
            get { return mIntegratedX; }
            set { mIntegratedX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
        /// </summary>
        public float IntegratedY {
            get { return mIntegratedY; }
            set { mIntegratedY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around X axis (rad)
        /// </summary>
        public float IntegratedXgyro {
            get { return mIntegratedXgyro; }
            set { mIntegratedXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around Y axis (rad)
        /// </summary>
        public float IntegratedYgyro {
            get { return mIntegratedYgyro; }
            set { mIntegratedYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RH rotation around Z axis (rad)
        /// </summary>
        public float IntegratedZgyro {
            get { return mIntegratedZgyro; }
            set { mIntegratedZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Time in microseconds since the distance was sampled.
        /// </summary>
        public UInt32 TimeDeltaDistanceUs {
            get { return mTimeDeltaDistanceUs; }
            set { mTimeDeltaDistanceUs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.
        /// </summary>
        public float Distance {
            get { return mDistance; }
            set { mDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature * 100 in centi-degrees Celsius
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Sensor ID
        /// </summary>
        public byte SensorId {
            get { return mSensorId; }
            set { mSensorId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
        /// </summary>
        public byte Quality {
            get { return mQuality; }
            set { mQuality = value; NotifyUpdated(); }
        }

        public UasHilOpticalFlow()
        {
            mMessageId = 114;
            CrcExtra = 237;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mIntegrationTimeUs);
            s.Write(mIntegratedX);
            s.Write(mIntegratedY);
            s.Write(mIntegratedXgyro);
            s.Write(mIntegratedYgyro);
            s.Write(mIntegratedZgyro);
            s.Write(mTimeDeltaDistanceUs);
            s.Write(mDistance);
            s.Write(mTemperature);
            s.Write(mSensorId);
            s.Write(mQuality);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mIntegrationTimeUs = s.ReadUInt32();
            this.mIntegratedX = s.ReadSingle();
            this.mIntegratedY = s.ReadSingle();
            this.mIntegratedXgyro = s.ReadSingle();
            this.mIntegratedYgyro = s.ReadSingle();
            this.mIntegratedZgyro = s.ReadSingle();
            this.mTimeDeltaDistanceUs = s.ReadUInt32();
            this.mDistance = s.ReadSingle();
            this.mTemperature = s.ReadInt16();
            this.mSensorId = s.ReadByte();
            this.mQuality = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds, synced to UNIX time or since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegrationTimeUs",
                Description = "Integration time in microseconds. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedX",
                Description = "Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedY",
                Description = "Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedXgyro",
                Description = "RH rotation around X axis (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedYgyro",
                Description = "RH rotation around Y axis (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntegratedZgyro",
                Description = "RH rotation around Z axis (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeDeltaDistanceUs",
                Description = "Time in microseconds since the distance was sampled.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Distance",
                Description = "Distance to the center of the flow field in meters. Positive value (including zero): distance known. Negative value: Unknown distance.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature * 100 in centi-degrees Celsius",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SensorId",
                Description = "Sensor ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Quality",
                Description = "Optical flow quality / confidence. 0: no valid flow, 255: maximum quality",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private UInt32 mIntegrationTimeUs;
        private float mIntegratedX;
        private float mIntegratedY;
        private float mIntegratedXgyro;
        private float mIntegratedYgyro;
        private float mIntegratedZgyro;
        private UInt32 mTimeDeltaDistanceUs;
        private float mDistance;
        private Int16 mTemperature;
        private byte mSensorId;
        private byte mQuality;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful for high throughput applications such as hardware in the loop simulations.
    /// </summary>
    public class UasHilStateQuaternion: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch or microseconds since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
        /// </summary>
        public float[] AttitudeQuaternion {
            get { return mAttitudeQuaternion; }
            set { mAttitudeQuaternion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame roll / phi angular speed (rad/s)
        /// </summary>
        public float Rollspeed {
            get { return mRollspeed; }
            set { mRollspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame pitch / theta angular speed (rad/s)
        /// </summary>
        public float Pitchspeed {
            get { return mPitchspeed; }
            set { mPitchspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame yaw / psi angular speed (rad/s)
        /// </summary>
        public float Yawspeed {
            get { return mYawspeed; }
            set { mYawspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude, expressed as * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude, expressed as * 1E7
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude in meters, expressed as * 1000 (millimeters)
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground X Speed (Latitude), expressed as m/s * 100
        /// </summary>
        public Int16 Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Y Speed (Longitude), expressed as m/s * 100
        /// </summary>
        public Int16 Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Ground Z Speed (Altitude), expressed as m/s * 100
        /// </summary>
        public Int16 Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Indicated airspeed, expressed as m/s * 100
        /// </summary>
        public UInt16 IndAirspeed {
            get { return mIndAirspeed; }
            set { mIndAirspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True airspeed, expressed as m/s * 100
        /// </summary>
        public UInt16 TrueAirspeed {
            get { return mTrueAirspeed; }
            set { mTrueAirspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration (mg)
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration (mg)
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration (mg)
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        public UasHilStateQuaternion()
        {
            mMessageId = 115;
            CrcExtra = 4;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mAttitudeQuaternion[0]); 
            s.Write(mAttitudeQuaternion[1]); 
            s.Write(mAttitudeQuaternion[2]); 
            s.Write(mAttitudeQuaternion[3]); 
            s.Write(mRollspeed);
            s.Write(mPitchspeed);
            s.Write(mYawspeed);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mIndAirspeed);
            s.Write(mTrueAirspeed);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mAttitudeQuaternion[0] = s.ReadSingle();
            this.mAttitudeQuaternion[1] = s.ReadSingle();
            this.mAttitudeQuaternion[2] = s.ReadSingle();
            this.mAttitudeQuaternion[3] = s.ReadSingle();
            this.mRollspeed = s.ReadSingle();
            this.mPitchspeed = s.ReadSingle();
            this.mYawspeed = s.ReadSingle();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mVx = s.ReadInt16();
            this.mVy = s.ReadInt16();
            this.mVz = s.ReadInt16();
            this.mIndAirspeed = s.ReadUInt16();
            this.mTrueAirspeed = s.ReadUInt16();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful for high throughput applications such as hardware in the loop simulations."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds since UNIX epoch or microseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AttitudeQuaternion",
                Description = "Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rollspeed",
                Description = "Body frame roll / phi angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitchspeed",
                Description = "Body frame pitch / theta angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yawspeed",
                Description = "Body frame yaw / psi angular speed (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude, expressed as * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude, expressed as * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude in meters, expressed as * 1000 (millimeters)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "Ground X Speed (Latitude), expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "Ground Y Speed (Longitude), expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "Ground Z Speed (Altitude), expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IndAirspeed",
                Description = "Indicated airspeed, expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TrueAirspeed",
                Description = "True airspeed, expressed as m/s * 100",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration (mg)",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float[] mAttitudeQuaternion = new float[4];
        private float mRollspeed;
        private float mPitchspeed;
        private float mYawspeed;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private Int16 mVx;
        private Int16 mVy;
        private Int16 mVz;
        private UInt16 mIndAirspeed;
        private UInt16 mTrueAirspeed;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to the described units
    /// </summary>
    public class UasScaledImu2: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration (mg)
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration (mg)
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration (mg)
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis (millirad /sec)
        /// </summary>
        public Int16 Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis (millirad /sec)
        /// </summary>
        public Int16 Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis (millirad /sec)
        /// </summary>
        public Int16 Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field (milli tesla)
        /// </summary>
        public Int16 Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field (milli tesla)
        /// </summary>
        public Int16 Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field (milli tesla)
        /// </summary>
        public Int16 Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        public UasScaledImu2()
        {
            mMessageId = 116;
            CrcExtra = 76;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
            this.mXgyro = s.ReadInt16();
            this.mYgyro = s.ReadInt16();
            this.mZgyro = s.ReadInt16();
            this.mXmag = s.ReadInt16();
            this.mYmag = s.ReadInt16();
            this.mZmag = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to the described units"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis (millirad /sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis (millirad /sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis (millirad /sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field (milli tesla)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field (milli tesla)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field (milli tesla)",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
        private Int16 mXgyro;
        private Int16 mYgyro;
        private Int16 mZgyro;
        private Int16 mXmag;
        private Int16 mYmag;
        private Int16 mZmag;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END is called.
    /// </summary>
    public class UasLogRequestList: UasMessage
    {
        /// <summary>
        /// First log id (0 for first available)
        /// </summary>
        public UInt16 Start {
            get { return mStart; }
            set { mStart = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Last log id (0xffff for last available)
        /// </summary>
        public UInt16 End {
            get { return mEnd; }
            set { mEnd = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasLogRequestList()
        {
            mMessageId = 117;
            CrcExtra = 128;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mStart);
            s.Write(mEnd);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mStart = s.ReadUInt16();
            this.mEnd = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END is called."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Start",
                Description = "First log id (0 for first available)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "End",
                Description = "Last log id (0xffff for last available)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt16 mStart;
        private UInt16 mEnd;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reply to LOG_REQUEST_LIST
    /// </summary>
    public class UasLogEntry: UasMessage
    {
        /// <summary>
        /// UTC timestamp of log in seconds since 1970, or 0 if not available
        /// </summary>
        public UInt32 TimeUtc {
            get { return mTimeUtc; }
            set { mTimeUtc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Size of the log (may be approximate) in bytes
        /// </summary>
        public UInt32 Size {
            get { return mSize; }
            set { mSize = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Log id
        /// </summary>
        public UInt16 Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Total number of logs
        /// </summary>
        public UInt16 NumLogs {
            get { return mNumLogs; }
            set { mNumLogs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// High log number
        /// </summary>
        public UInt16 LastLogNum {
            get { return mLastLogNum; }
            set { mLastLogNum = value; NotifyUpdated(); }
        }

        public UasLogEntry()
        {
            mMessageId = 118;
            CrcExtra = 56;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUtc);
            s.Write(mSize);
            s.Write(mId);
            s.Write(mNumLogs);
            s.Write(mLastLogNum);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUtc = s.ReadUInt32();
            this.mSize = s.ReadUInt32();
            this.mId = s.ReadUInt16();
            this.mNumLogs = s.ReadUInt16();
            this.mLastLogNum = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reply to LOG_REQUEST_LIST"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUtc",
                Description = "UTC timestamp of log in seconds since 1970, or 0 if not available",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Size",
                Description = "Size of the log (may be approximate) in bytes",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Log id",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "NumLogs",
                Description = "Total number of logs",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LastLogNum",
                Description = "High log number",
                NumElements = 1,
            });

        }

        private UInt32 mTimeUtc;
        private UInt32 mSize;
        private UInt16 mId;
        private UInt16 mNumLogs;
        private UInt16 mLastLogNum;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request a chunk of a log
    /// </summary>
    public class UasLogRequestData: UasMessage
    {
        /// <summary>
        /// Offset into the log
        /// </summary>
        public UInt32 Ofs {
            get { return mOfs; }
            set { mOfs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of bytes
        /// </summary>
        public UInt32 Count {
            get { return mCount; }
            set { mCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Log id (from LOG_ENTRY reply)
        /// </summary>
        public UInt16 Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasLogRequestData()
        {
            mMessageId = 119;
            CrcExtra = 116;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mOfs);
            s.Write(mCount);
            s.Write(mId);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mOfs = s.ReadUInt32();
            this.mCount = s.ReadUInt32();
            this.mId = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request a chunk of a log"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ofs",
                Description = "Offset into the log",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Count",
                Description = "Number of bytes",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Log id (from LOG_ENTRY reply)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt32 mOfs;
        private UInt32 mCount;
        private UInt16 mId;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reply to LOG_REQUEST_DATA
    /// </summary>
    public class UasLogData: UasMessage
    {
        /// <summary>
        /// Offset into the log
        /// </summary>
        public UInt32 Ofs {
            get { return mOfs; }
            set { mOfs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Log id (from LOG_ENTRY reply)
        /// </summary>
        public UInt16 Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of bytes (zero for end of log)
        /// </summary>
        public byte Count {
            get { return mCount; }
            set { mCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// log data
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasLogData()
        {
            mMessageId = 120;
            CrcExtra = 134;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mOfs);
            s.Write(mId);
            s.Write(mCount);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
            s.Write(mData[70]); 
            s.Write(mData[71]); 
            s.Write(mData[72]); 
            s.Write(mData[73]); 
            s.Write(mData[74]); 
            s.Write(mData[75]); 
            s.Write(mData[76]); 
            s.Write(mData[77]); 
            s.Write(mData[78]); 
            s.Write(mData[79]); 
            s.Write(mData[80]); 
            s.Write(mData[81]); 
            s.Write(mData[82]); 
            s.Write(mData[83]); 
            s.Write(mData[84]); 
            s.Write(mData[85]); 
            s.Write(mData[86]); 
            s.Write(mData[87]); 
            s.Write(mData[88]); 
            s.Write(mData[89]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mOfs = s.ReadUInt32();
            this.mId = s.ReadUInt16();
            this.mCount = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
            this.mData[70] = s.ReadByte();
            this.mData[71] = s.ReadByte();
            this.mData[72] = s.ReadByte();
            this.mData[73] = s.ReadByte();
            this.mData[74] = s.ReadByte();
            this.mData[75] = s.ReadByte();
            this.mData[76] = s.ReadByte();
            this.mData[77] = s.ReadByte();
            this.mData[78] = s.ReadByte();
            this.mData[79] = s.ReadByte();
            this.mData[80] = s.ReadByte();
            this.mData[81] = s.ReadByte();
            this.mData[82] = s.ReadByte();
            this.mData[83] = s.ReadByte();
            this.mData[84] = s.ReadByte();
            this.mData[85] = s.ReadByte();
            this.mData[86] = s.ReadByte();
            this.mData[87] = s.ReadByte();
            this.mData[88] = s.ReadByte();
            this.mData[89] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reply to LOG_REQUEST_DATA"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ofs",
                Description = "Offset into the log",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Log id (from LOG_ENTRY reply)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Count",
                Description = "Number of bytes (zero for end of log)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "log data",
                NumElements = 90,
            });

        }

        private UInt32 mOfs;
        private UInt16 mId;
        private byte mCount;
        private byte[] mData = new byte[90];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Erase all logs
    /// </summary>
    public class UasLogErase: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasLogErase()
        {
            mMessageId = 121;
            CrcExtra = 237;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Erase all logs"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Stop log transfer and resume normal logging
    /// </summary>
    public class UasLogRequestEnd: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasLogRequestEnd()
        {
            mMessageId = 122;
            CrcExtra = 203;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Stop log transfer and resume normal logging"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// data for injecting into the onboard GPS (used for DGPS)
    /// </summary>
    public class UasGpsInjectData: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// data length
        /// </summary>
        public byte Len {
            get { return mLen; }
            set { mLen = value; NotifyUpdated(); }
        }

        /// <summary>
        /// raw data (110 is enough for 12 satellites of RTCMv2)
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasGpsInjectData()
        {
            mMessageId = 123;
            CrcExtra = 250;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mLen);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
            s.Write(mData[70]); 
            s.Write(mData[71]); 
            s.Write(mData[72]); 
            s.Write(mData[73]); 
            s.Write(mData[74]); 
            s.Write(mData[75]); 
            s.Write(mData[76]); 
            s.Write(mData[77]); 
            s.Write(mData[78]); 
            s.Write(mData[79]); 
            s.Write(mData[80]); 
            s.Write(mData[81]); 
            s.Write(mData[82]); 
            s.Write(mData[83]); 
            s.Write(mData[84]); 
            s.Write(mData[85]); 
            s.Write(mData[86]); 
            s.Write(mData[87]); 
            s.Write(mData[88]); 
            s.Write(mData[89]); 
            s.Write(mData[90]); 
            s.Write(mData[91]); 
            s.Write(mData[92]); 
            s.Write(mData[93]); 
            s.Write(mData[94]); 
            s.Write(mData[95]); 
            s.Write(mData[96]); 
            s.Write(mData[97]); 
            s.Write(mData[98]); 
            s.Write(mData[99]); 
            s.Write(mData[100]); 
            s.Write(mData[101]); 
            s.Write(mData[102]); 
            s.Write(mData[103]); 
            s.Write(mData[104]); 
            s.Write(mData[105]); 
            s.Write(mData[106]); 
            s.Write(mData[107]); 
            s.Write(mData[108]); 
            s.Write(mData[109]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mLen = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
            this.mData[70] = s.ReadByte();
            this.mData[71] = s.ReadByte();
            this.mData[72] = s.ReadByte();
            this.mData[73] = s.ReadByte();
            this.mData[74] = s.ReadByte();
            this.mData[75] = s.ReadByte();
            this.mData[76] = s.ReadByte();
            this.mData[77] = s.ReadByte();
            this.mData[78] = s.ReadByte();
            this.mData[79] = s.ReadByte();
            this.mData[80] = s.ReadByte();
            this.mData[81] = s.ReadByte();
            this.mData[82] = s.ReadByte();
            this.mData[83] = s.ReadByte();
            this.mData[84] = s.ReadByte();
            this.mData[85] = s.ReadByte();
            this.mData[86] = s.ReadByte();
            this.mData[87] = s.ReadByte();
            this.mData[88] = s.ReadByte();
            this.mData[89] = s.ReadByte();
            this.mData[90] = s.ReadByte();
            this.mData[91] = s.ReadByte();
            this.mData[92] = s.ReadByte();
            this.mData[93] = s.ReadByte();
            this.mData[94] = s.ReadByte();
            this.mData[95] = s.ReadByte();
            this.mData[96] = s.ReadByte();
            this.mData[97] = s.ReadByte();
            this.mData[98] = s.ReadByte();
            this.mData[99] = s.ReadByte();
            this.mData[100] = s.ReadByte();
            this.mData[101] = s.ReadByte();
            this.mData[102] = s.ReadByte();
            this.mData[103] = s.ReadByte();
            this.mData[104] = s.ReadByte();
            this.mData[105] = s.ReadByte();
            this.mData[106] = s.ReadByte();
            this.mData[107] = s.ReadByte();
            this.mData[108] = s.ReadByte();
            this.mData[109] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "data for injecting into the onboard GPS (used for DGPS)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Len",
                Description = "data length",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "raw data (110 is enough for 12 satellites of RTCMv2)",
                NumElements = 110,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mLen;
        private byte[] mData = new byte[110];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame).
    /// </summary>
    public class UasGps2Raw: UasMessage
    {
        /// <summary>
        /// Timestamp (microseconds since UNIX epoch or microseconds since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)
        /// </summary>
        public Int32 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Age of DGPS info
        /// </summary>
        public UInt32 DgpsAge {
            get { return mDgpsAge; }
            set { mDgpsAge = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Eph {
            get { return mEph; }
            set { mEph = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Epv {
            get { return mEpv; }
            set { mEpv = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Vel {
            get { return mVel; }
            set { mVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
        /// </summary>
        public UInt16 Cog {
            get { return mCog; }
            set { mCog = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS fix, 5: RTK Fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
        /// </summary>
        public byte FixType {
            get { return mFixType; }
            set { mFixType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of satellites visible. If unknown, set to 255
        /// </summary>
        public byte SatellitesVisible {
            get { return mSatellitesVisible; }
            set { mSatellitesVisible = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of DGPS satellites
        /// </summary>
        public byte DgpsNumch {
            get { return mDgpsNumch; }
            set { mDgpsNumch = value; NotifyUpdated(); }
        }

        public UasGps2Raw()
        {
            mMessageId = 124;
            CrcExtra = 87;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mDgpsAge);
            s.Write(mEph);
            s.Write(mEpv);
            s.Write(mVel);
            s.Write(mCog);
            s.Write(mFixType);
            s.Write(mSatellitesVisible);
            s.Write(mDgpsNumch);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadInt32();
            this.mDgpsAge = s.ReadUInt32();
            this.mEph = s.ReadUInt16();
            this.mEpv = s.ReadUInt16();
            this.mVel = s.ReadUInt16();
            this.mCog = s.ReadUInt16();
            this.mFixType = s.ReadByte();
            this.mSatellitesVisible = s.ReadByte();
            this.mDgpsNumch = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (microseconds since UNIX epoch or microseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Altitude (AMSL, not WGS84), in meters * 1000 (positive for up)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DgpsAge",
                Description = "Age of DGPS info",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Eph",
                Description = "GPS HDOP horizontal dilution of position in cm (m*100). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Epv",
                Description = "GPS VDOP vertical dilution of position in cm (m*100). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vel",
                Description = "GPS ground speed (m/s * 100). If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Cog",
                Description = "Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FixType",
                Description = "0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS fix, 5: RTK Fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SatellitesVisible",
                Description = "Number of satellites visible. If unknown, set to 255",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DgpsNumch",
                Description = "Number of DGPS satellites",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAlt;
        private UInt32 mDgpsAge;
        private UInt16 mEph;
        private UInt16 mEpv;
        private UInt16 mVel;
        private UInt16 mCog;
        private byte mFixType;
        private byte mSatellitesVisible;
        private byte mDgpsNumch;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Power supply status
    /// </summary>
    public class UasPowerStatus: UasMessage
    {
        /// <summary>
        /// 5V rail voltage in millivolts
        /// </summary>
        public UInt16 Vcc {
            get { return mVcc; }
            set { mVcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// servo rail voltage in millivolts
        /// </summary>
        public UInt16 Vservo {
            get { return mVservo; }
            set { mVservo = value; NotifyUpdated(); }
        }

        /// <summary>
        /// power supply status flags (see MAV_POWER_STATUS enum)
        /// </summary>
        public MavPowerStatus Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        public UasPowerStatus()
        {
            mMessageId = 125;
            CrcExtra = 203;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mVcc);
            s.Write(mVservo);
            s.Write((UInt16)mFlags);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mVcc = s.ReadUInt16();
            this.mVservo = s.ReadUInt16();
            this.mFlags = (MavPowerStatus)s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Power supply status"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vcc",
                Description = "5V rail voltage in millivolts",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vservo",
                Description = "servo rail voltage in millivolts",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "power supply status flags (see MAV_POWER_STATUS enum)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavPowerStatus"),
            });

        }

        private UInt16 mVcc;
        private UInt16 mVservo;
        private MavPowerStatus mFlags;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages or change the devices settings. A message with zero bytes can be used to change just the baudrate.
    /// </summary>
    public class UasSerialControl: UasMessage
    {
        /// <summary>
        /// Baudrate of transfer. Zero means no change.
        /// </summary>
        public UInt32 Baudrate {
            get { return mBaudrate; }
            set { mBaudrate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Timeout for reply data in milliseconds
        /// </summary>
        public UInt16 Timeout {
            get { return mTimeout; }
            set { mTimeout = value; NotifyUpdated(); }
        }

        /// <summary>
        /// See SERIAL_CONTROL_DEV enum
        /// </summary>
        public SerialControlDev Device {
            get { return mDevice; }
            set { mDevice = value; NotifyUpdated(); }
        }

        /// <summary>
        /// See SERIAL_CONTROL_FLAG enum
        /// </summary>
        public SerialControlFlag Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        /// <summary>
        /// how many bytes in this transfer
        /// </summary>
        public byte Count {
            get { return mCount; }
            set { mCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// serial data
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasSerialControl()
        {
            mMessageId = 126;
            CrcExtra = 220;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mBaudrate);
            s.Write(mTimeout);
            s.Write((byte)mDevice);
            s.Write((byte)mFlags);
            s.Write(mCount);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mBaudrate = s.ReadUInt32();
            this.mTimeout = s.ReadUInt16();
            this.mDevice = (SerialControlDev)s.ReadByte();
            this.mFlags = (SerialControlFlag)s.ReadByte();
            this.mCount = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages or change the devices settings. A message with zero bytes can be used to change just the baudrate."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Baudrate",
                Description = "Baudrate of transfer. Zero means no change.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Timeout",
                Description = "Timeout for reply data in milliseconds",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Device",
                Description = "See SERIAL_CONTROL_DEV enum",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("SerialControlDev"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "See SERIAL_CONTROL_FLAG enum",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("SerialControlFlag"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Count",
                Description = "how many bytes in this transfer",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "serial data",
                NumElements = 70,
            });

        }

        private UInt32 mBaudrate;
        private UInt16 mTimeout;
        private SerialControlDev mDevice;
        private SerialControlFlag mFlags;
        private byte mCount;
        private byte[] mData = new byte[70];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
    /// </summary>
    public class UasGpsRtk: UasMessage
    {
        /// <summary>
        /// Time since boot of last baseline message received in ms.
        /// </summary>
        public UInt32 TimeLastBaselineMs {
            get { return mTimeLastBaselineMs; }
            set { mTimeLastBaselineMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS Time of Week of last baseline
        /// </summary>
        public UInt32 Tow {
            get { return mTow; }
            set { mTow = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF x or NED north component in mm.
        /// </summary>
        public Int32 BaselineAMm {
            get { return mBaselineAMm; }
            set { mBaselineAMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF y or NED east component in mm.
        /// </summary>
        public Int32 BaselineBMm {
            get { return mBaselineBMm; }
            set { mBaselineBMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF z or NED down component in mm.
        /// </summary>
        public Int32 BaselineCMm {
            get { return mBaselineCMm; }
            set { mBaselineCMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current estimate of baseline accuracy.
        /// </summary>
        public UInt32 Accuracy {
            get { return mAccuracy; }
            set { mAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current number of integer ambiguity hypotheses.
        /// </summary>
        public Int32 IarNumHypotheses {
            get { return mIarNumHypotheses; }
            set { mIarNumHypotheses = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS Week Number of last baseline
        /// </summary>
        public UInt16 Wn {
            get { return mWn; }
            set { mWn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Identification of connected RTK receiver.
        /// </summary>
        public byte RtkReceiverId {
            get { return mRtkReceiverId; }
            set { mRtkReceiverId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS-specific health report for RTK data.
        /// </summary>
        public byte RtkHealth {
            get { return mRtkHealth; }
            set { mRtkHealth = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Rate of baseline messages being received by GPS, in HZ
        /// </summary>
        public byte RtkRate {
            get { return mRtkRate; }
            set { mRtkRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current number of sats used for RTK calculation.
        /// </summary>
        public byte Nsats {
            get { return mNsats; }
            set { mNsats = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Coordinate system of baseline. 0 == ECEF, 1 == NED
        /// </summary>
        public byte BaselineCoordsType {
            get { return mBaselineCoordsType; }
            set { mBaselineCoordsType = value; NotifyUpdated(); }
        }

        public UasGpsRtk()
        {
            mMessageId = 127;
            CrcExtra = 25;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeLastBaselineMs);
            s.Write(mTow);
            s.Write(mBaselineAMm);
            s.Write(mBaselineBMm);
            s.Write(mBaselineCMm);
            s.Write(mAccuracy);
            s.Write(mIarNumHypotheses);
            s.Write(mWn);
            s.Write(mRtkReceiverId);
            s.Write(mRtkHealth);
            s.Write(mRtkRate);
            s.Write(mNsats);
            s.Write(mBaselineCoordsType);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeLastBaselineMs = s.ReadUInt32();
            this.mTow = s.ReadUInt32();
            this.mBaselineAMm = s.ReadInt32();
            this.mBaselineBMm = s.ReadInt32();
            this.mBaselineCMm = s.ReadInt32();
            this.mAccuracy = s.ReadUInt32();
            this.mIarNumHypotheses = s.ReadInt32();
            this.mWn = s.ReadUInt16();
            this.mRtkReceiverId = s.ReadByte();
            this.mRtkHealth = s.ReadByte();
            this.mRtkRate = s.ReadByte();
            this.mNsats = s.ReadByte();
            this.mBaselineCoordsType = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeLastBaselineMs",
                Description = "Time since boot of last baseline message received in ms.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Tow",
                Description = "GPS Time of Week of last baseline",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineAMm",
                Description = "Current baseline in ECEF x or NED north component in mm.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineBMm",
                Description = "Current baseline in ECEF y or NED east component in mm.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineCMm",
                Description = "Current baseline in ECEF z or NED down component in mm.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Accuracy",
                Description = "Current estimate of baseline accuracy.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IarNumHypotheses",
                Description = "Current number of integer ambiguity hypotheses.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Wn",
                Description = "GPS Week Number of last baseline",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkReceiverId",
                Description = "Identification of connected RTK receiver.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkHealth",
                Description = "GPS-specific health report for RTK data.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkRate",
                Description = "Rate of baseline messages being received by GPS, in HZ",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Nsats",
                Description = "Current number of sats used for RTK calculation.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineCoordsType",
                Description = "Coordinate system of baseline. 0 == ECEF, 1 == NED",
                NumElements = 1,
            });

        }

        private UInt32 mTimeLastBaselineMs;
        private UInt32 mTow;
        private Int32 mBaselineAMm;
        private Int32 mBaselineBMm;
        private Int32 mBaselineCMm;
        private UInt32 mAccuracy;
        private Int32 mIarNumHypotheses;
        private UInt16 mWn;
        private byte mRtkReceiverId;
        private byte mRtkHealth;
        private byte mRtkRate;
        private byte mNsats;
        private byte mBaselineCoordsType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
    /// </summary>
    public class UasGps2Rtk: UasMessage
    {
        /// <summary>
        /// Time since boot of last baseline message received in ms.
        /// </summary>
        public UInt32 TimeLastBaselineMs {
            get { return mTimeLastBaselineMs; }
            set { mTimeLastBaselineMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS Time of Week of last baseline
        /// </summary>
        public UInt32 Tow {
            get { return mTow; }
            set { mTow = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF x or NED north component in mm.
        /// </summary>
        public Int32 BaselineAMm {
            get { return mBaselineAMm; }
            set { mBaselineAMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF y or NED east component in mm.
        /// </summary>
        public Int32 BaselineBMm {
            get { return mBaselineBMm; }
            set { mBaselineBMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current baseline in ECEF z or NED down component in mm.
        /// </summary>
        public Int32 BaselineCMm {
            get { return mBaselineCMm; }
            set { mBaselineCMm = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current estimate of baseline accuracy.
        /// </summary>
        public UInt32 Accuracy {
            get { return mAccuracy; }
            set { mAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current number of integer ambiguity hypotheses.
        /// </summary>
        public Int32 IarNumHypotheses {
            get { return mIarNumHypotheses; }
            set { mIarNumHypotheses = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS Week Number of last baseline
        /// </summary>
        public UInt16 Wn {
            get { return mWn; }
            set { mWn = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Identification of connected RTK receiver.
        /// </summary>
        public byte RtkReceiverId {
            get { return mRtkReceiverId; }
            set { mRtkReceiverId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS-specific health report for RTK data.
        /// </summary>
        public byte RtkHealth {
            get { return mRtkHealth; }
            set { mRtkHealth = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Rate of baseline messages being received by GPS, in HZ
        /// </summary>
        public byte RtkRate {
            get { return mRtkRate; }
            set { mRtkRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current number of sats used for RTK calculation.
        /// </summary>
        public byte Nsats {
            get { return mNsats; }
            set { mNsats = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Coordinate system of baseline. 0 == ECEF, 1 == NED
        /// </summary>
        public byte BaselineCoordsType {
            get { return mBaselineCoordsType; }
            set { mBaselineCoordsType = value; NotifyUpdated(); }
        }

        public UasGps2Rtk()
        {
            mMessageId = 128;
            CrcExtra = 226;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeLastBaselineMs);
            s.Write(mTow);
            s.Write(mBaselineAMm);
            s.Write(mBaselineBMm);
            s.Write(mBaselineCMm);
            s.Write(mAccuracy);
            s.Write(mIarNumHypotheses);
            s.Write(mWn);
            s.Write(mRtkReceiverId);
            s.Write(mRtkHealth);
            s.Write(mRtkRate);
            s.Write(mNsats);
            s.Write(mBaselineCoordsType);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeLastBaselineMs = s.ReadUInt32();
            this.mTow = s.ReadUInt32();
            this.mBaselineAMm = s.ReadInt32();
            this.mBaselineBMm = s.ReadInt32();
            this.mBaselineCMm = s.ReadInt32();
            this.mAccuracy = s.ReadUInt32();
            this.mIarNumHypotheses = s.ReadInt32();
            this.mWn = s.ReadUInt16();
            this.mRtkReceiverId = s.ReadByte();
            this.mRtkHealth = s.ReadByte();
            this.mRtkRate = s.ReadByte();
            this.mNsats = s.ReadByte();
            this.mBaselineCoordsType = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeLastBaselineMs",
                Description = "Time since boot of last baseline message received in ms.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Tow",
                Description = "GPS Time of Week of last baseline",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineAMm",
                Description = "Current baseline in ECEF x or NED north component in mm.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineBMm",
                Description = "Current baseline in ECEF y or NED east component in mm.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineCMm",
                Description = "Current baseline in ECEF z or NED down component in mm.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Accuracy",
                Description = "Current estimate of baseline accuracy.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IarNumHypotheses",
                Description = "Current number of integer ambiguity hypotheses.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Wn",
                Description = "GPS Week Number of last baseline",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkReceiverId",
                Description = "Identification of connected RTK receiver.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkHealth",
                Description = "GPS-specific health report for RTK data.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RtkRate",
                Description = "Rate of baseline messages being received by GPS, in HZ",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Nsats",
                Description = "Current number of sats used for RTK calculation.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BaselineCoordsType",
                Description = "Coordinate system of baseline. 0 == ECEF, 1 == NED",
                NumElements = 1,
            });

        }

        private UInt32 mTimeLastBaselineMs;
        private UInt32 mTow;
        private Int32 mBaselineAMm;
        private Int32 mBaselineBMm;
        private Int32 mBaselineCMm;
        private UInt32 mAccuracy;
        private Int32 mIarNumHypotheses;
        private UInt16 mWn;
        private byte mRtkReceiverId;
        private byte mRtkHealth;
        private byte mRtkRate;
        private byte mNsats;
        private byte mBaselineCoordsType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described units
    /// </summary>
    public class UasScaledImu3: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration (mg)
        /// </summary>
        public Int16 Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration (mg)
        /// </summary>
        public Int16 Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration (mg)
        /// </summary>
        public Int16 Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis (millirad /sec)
        /// </summary>
        public Int16 Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis (millirad /sec)
        /// </summary>
        public Int16 Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis (millirad /sec)
        /// </summary>
        public Int16 Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X Magnetic field (milli tesla)
        /// </summary>
        public Int16 Xmag {
            get { return mXmag; }
            set { mXmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y Magnetic field (milli tesla)
        /// </summary>
        public Int16 Ymag {
            get { return mYmag; }
            set { mYmag = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z Magnetic field (milli tesla)
        /// </summary>
        public Int16 Zmag {
            get { return mZmag; }
            set { mZmag = value; NotifyUpdated(); }
        }

        public UasScaledImu3()
        {
            mMessageId = 129;
            CrcExtra = 46;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mXmag);
            s.Write(mYmag);
            s.Write(mZmag);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mXacc = s.ReadInt16();
            this.mYacc = s.ReadInt16();
            this.mZacc = s.ReadInt16();
            this.mXgyro = s.ReadInt16();
            this.mYgyro = s.ReadInt16();
            this.mZgyro = s.ReadInt16();
            this.mXmag = s.ReadInt16();
            this.mYmag = s.ReadInt16();
            this.mZmag = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described units"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration (mg)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis (millirad /sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis (millirad /sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis (millirad /sec)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xmag",
                Description = "X Magnetic field (milli tesla)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ymag",
                Description = "Y Magnetic field (milli tesla)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zmag",
                Description = "Z Magnetic field (milli tesla)",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private Int16 mXacc;
        private Int16 mYacc;
        private Int16 mZacc;
        private Int16 mXgyro;
        private Int16 mYgyro;
        private Int16 mZgyro;
        private Int16 mXmag;
        private Int16 mYmag;
        private Int16 mZmag;
    }


    // ___________________________________________________________________________________


    public class UasDataTransmissionHandshake: UasMessage
    {
        /// <summary>
        /// total data size in bytes (set on ACK only)
        /// </summary>
        public UInt32 Size {
            get { return mSize; }
            set { mSize = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Width of a matrix or image
        /// </summary>
        public UInt16 Width {
            get { return mWidth; }
            set { mWidth = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Height of a matrix or image
        /// </summary>
        public UInt16 Height {
            get { return mHeight; }
            set { mHeight = value; NotifyUpdated(); }
        }

        /// <summary>
        /// number of packets beeing sent (set on ACK only)
        /// </summary>
        public UInt16 Packets {
            get { return mPackets; }
            set { mPackets = value; NotifyUpdated(); }
        }

        /// <summary>
        /// type of requested/acknowledged data (as defined in ENUM DATA_TYPES in mavlink/include/mavlink_types.h)
        /// </summary>
        public byte Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only)
        /// </summary>
        public byte Payload {
            get { return mPayload; }
            set { mPayload = value; NotifyUpdated(); }
        }

        /// <summary>
        /// JPEG quality out of [1,100]
        /// </summary>
        public byte JpgQuality {
            get { return mJpgQuality; }
            set { mJpgQuality = value; NotifyUpdated(); }
        }

        public UasDataTransmissionHandshake()
        {
            mMessageId = 130;
            CrcExtra = 29;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mSize);
            s.Write(mWidth);
            s.Write(mHeight);
            s.Write(mPackets);
            s.Write(mType);
            s.Write(mPayload);
            s.Write(mJpgQuality);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSize = s.ReadUInt32();
            this.mWidth = s.ReadUInt16();
            this.mHeight = s.ReadUInt16();
            this.mPackets = s.ReadUInt16();
            this.mType = s.ReadByte();
            this.mPayload = s.ReadByte();
            this.mJpgQuality = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = ""
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Size",
                Description = "total data size in bytes (set on ACK only)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Width",
                Description = "Width of a matrix or image",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Height",
                Description = "Height of a matrix or image",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Packets",
                Description = "number of packets beeing sent (set on ACK only)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "type of requested/acknowledged data (as defined in ENUM DATA_TYPES in mavlink/include/mavlink_types.h)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Payload",
                Description = "payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "JpgQuality",
                Description = "JPEG quality out of [1,100]",
                NumElements = 1,
            });

        }

        private UInt32 mSize;
        private UInt16 mWidth;
        private UInt16 mHeight;
        private UInt16 mPackets;
        private byte mType;
        private byte mPayload;
        private byte mJpgQuality;
    }


    // ___________________________________________________________________________________


    public class UasEncapsulatedData: UasMessage
    {
        /// <summary>
        /// sequence number (starting with 0 on every transmission)
        /// </summary>
        public UInt16 Seqnr {
            get { return mSeqnr; }
            set { mSeqnr = value; NotifyUpdated(); }
        }

        /// <summary>
        /// image data bytes
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasEncapsulatedData()
        {
            mMessageId = 131;
            CrcExtra = 223;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mSeqnr);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
            s.Write(mData[70]); 
            s.Write(mData[71]); 
            s.Write(mData[72]); 
            s.Write(mData[73]); 
            s.Write(mData[74]); 
            s.Write(mData[75]); 
            s.Write(mData[76]); 
            s.Write(mData[77]); 
            s.Write(mData[78]); 
            s.Write(mData[79]); 
            s.Write(mData[80]); 
            s.Write(mData[81]); 
            s.Write(mData[82]); 
            s.Write(mData[83]); 
            s.Write(mData[84]); 
            s.Write(mData[85]); 
            s.Write(mData[86]); 
            s.Write(mData[87]); 
            s.Write(mData[88]); 
            s.Write(mData[89]); 
            s.Write(mData[90]); 
            s.Write(mData[91]); 
            s.Write(mData[92]); 
            s.Write(mData[93]); 
            s.Write(mData[94]); 
            s.Write(mData[95]); 
            s.Write(mData[96]); 
            s.Write(mData[97]); 
            s.Write(mData[98]); 
            s.Write(mData[99]); 
            s.Write(mData[100]); 
            s.Write(mData[101]); 
            s.Write(mData[102]); 
            s.Write(mData[103]); 
            s.Write(mData[104]); 
            s.Write(mData[105]); 
            s.Write(mData[106]); 
            s.Write(mData[107]); 
            s.Write(mData[108]); 
            s.Write(mData[109]); 
            s.Write(mData[110]); 
            s.Write(mData[111]); 
            s.Write(mData[112]); 
            s.Write(mData[113]); 
            s.Write(mData[114]); 
            s.Write(mData[115]); 
            s.Write(mData[116]); 
            s.Write(mData[117]); 
            s.Write(mData[118]); 
            s.Write(mData[119]); 
            s.Write(mData[120]); 
            s.Write(mData[121]); 
            s.Write(mData[122]); 
            s.Write(mData[123]); 
            s.Write(mData[124]); 
            s.Write(mData[125]); 
            s.Write(mData[126]); 
            s.Write(mData[127]); 
            s.Write(mData[128]); 
            s.Write(mData[129]); 
            s.Write(mData[130]); 
            s.Write(mData[131]); 
            s.Write(mData[132]); 
            s.Write(mData[133]); 
            s.Write(mData[134]); 
            s.Write(mData[135]); 
            s.Write(mData[136]); 
            s.Write(mData[137]); 
            s.Write(mData[138]); 
            s.Write(mData[139]); 
            s.Write(mData[140]); 
            s.Write(mData[141]); 
            s.Write(mData[142]); 
            s.Write(mData[143]); 
            s.Write(mData[144]); 
            s.Write(mData[145]); 
            s.Write(mData[146]); 
            s.Write(mData[147]); 
            s.Write(mData[148]); 
            s.Write(mData[149]); 
            s.Write(mData[150]); 
            s.Write(mData[151]); 
            s.Write(mData[152]); 
            s.Write(mData[153]); 
            s.Write(mData[154]); 
            s.Write(mData[155]); 
            s.Write(mData[156]); 
            s.Write(mData[157]); 
            s.Write(mData[158]); 
            s.Write(mData[159]); 
            s.Write(mData[160]); 
            s.Write(mData[161]); 
            s.Write(mData[162]); 
            s.Write(mData[163]); 
            s.Write(mData[164]); 
            s.Write(mData[165]); 
            s.Write(mData[166]); 
            s.Write(mData[167]); 
            s.Write(mData[168]); 
            s.Write(mData[169]); 
            s.Write(mData[170]); 
            s.Write(mData[171]); 
            s.Write(mData[172]); 
            s.Write(mData[173]); 
            s.Write(mData[174]); 
            s.Write(mData[175]); 
            s.Write(mData[176]); 
            s.Write(mData[177]); 
            s.Write(mData[178]); 
            s.Write(mData[179]); 
            s.Write(mData[180]); 
            s.Write(mData[181]); 
            s.Write(mData[182]); 
            s.Write(mData[183]); 
            s.Write(mData[184]); 
            s.Write(mData[185]); 
            s.Write(mData[186]); 
            s.Write(mData[187]); 
            s.Write(mData[188]); 
            s.Write(mData[189]); 
            s.Write(mData[190]); 
            s.Write(mData[191]); 
            s.Write(mData[192]); 
            s.Write(mData[193]); 
            s.Write(mData[194]); 
            s.Write(mData[195]); 
            s.Write(mData[196]); 
            s.Write(mData[197]); 
            s.Write(mData[198]); 
            s.Write(mData[199]); 
            s.Write(mData[200]); 
            s.Write(mData[201]); 
            s.Write(mData[202]); 
            s.Write(mData[203]); 
            s.Write(mData[204]); 
            s.Write(mData[205]); 
            s.Write(mData[206]); 
            s.Write(mData[207]); 
            s.Write(mData[208]); 
            s.Write(mData[209]); 
            s.Write(mData[210]); 
            s.Write(mData[211]); 
            s.Write(mData[212]); 
            s.Write(mData[213]); 
            s.Write(mData[214]); 
            s.Write(mData[215]); 
            s.Write(mData[216]); 
            s.Write(mData[217]); 
            s.Write(mData[218]); 
            s.Write(mData[219]); 
            s.Write(mData[220]); 
            s.Write(mData[221]); 
            s.Write(mData[222]); 
            s.Write(mData[223]); 
            s.Write(mData[224]); 
            s.Write(mData[225]); 
            s.Write(mData[226]); 
            s.Write(mData[227]); 
            s.Write(mData[228]); 
            s.Write(mData[229]); 
            s.Write(mData[230]); 
            s.Write(mData[231]); 
            s.Write(mData[232]); 
            s.Write(mData[233]); 
            s.Write(mData[234]); 
            s.Write(mData[235]); 
            s.Write(mData[236]); 
            s.Write(mData[237]); 
            s.Write(mData[238]); 
            s.Write(mData[239]); 
            s.Write(mData[240]); 
            s.Write(mData[241]); 
            s.Write(mData[242]); 
            s.Write(mData[243]); 
            s.Write(mData[244]); 
            s.Write(mData[245]); 
            s.Write(mData[246]); 
            s.Write(mData[247]); 
            s.Write(mData[248]); 
            s.Write(mData[249]); 
            s.Write(mData[250]); 
            s.Write(mData[251]); 
            s.Write(mData[252]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSeqnr = s.ReadUInt16();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
            this.mData[70] = s.ReadByte();
            this.mData[71] = s.ReadByte();
            this.mData[72] = s.ReadByte();
            this.mData[73] = s.ReadByte();
            this.mData[74] = s.ReadByte();
            this.mData[75] = s.ReadByte();
            this.mData[76] = s.ReadByte();
            this.mData[77] = s.ReadByte();
            this.mData[78] = s.ReadByte();
            this.mData[79] = s.ReadByte();
            this.mData[80] = s.ReadByte();
            this.mData[81] = s.ReadByte();
            this.mData[82] = s.ReadByte();
            this.mData[83] = s.ReadByte();
            this.mData[84] = s.ReadByte();
            this.mData[85] = s.ReadByte();
            this.mData[86] = s.ReadByte();
            this.mData[87] = s.ReadByte();
            this.mData[88] = s.ReadByte();
            this.mData[89] = s.ReadByte();
            this.mData[90] = s.ReadByte();
            this.mData[91] = s.ReadByte();
            this.mData[92] = s.ReadByte();
            this.mData[93] = s.ReadByte();
            this.mData[94] = s.ReadByte();
            this.mData[95] = s.ReadByte();
            this.mData[96] = s.ReadByte();
            this.mData[97] = s.ReadByte();
            this.mData[98] = s.ReadByte();
            this.mData[99] = s.ReadByte();
            this.mData[100] = s.ReadByte();
            this.mData[101] = s.ReadByte();
            this.mData[102] = s.ReadByte();
            this.mData[103] = s.ReadByte();
            this.mData[104] = s.ReadByte();
            this.mData[105] = s.ReadByte();
            this.mData[106] = s.ReadByte();
            this.mData[107] = s.ReadByte();
            this.mData[108] = s.ReadByte();
            this.mData[109] = s.ReadByte();
            this.mData[110] = s.ReadByte();
            this.mData[111] = s.ReadByte();
            this.mData[112] = s.ReadByte();
            this.mData[113] = s.ReadByte();
            this.mData[114] = s.ReadByte();
            this.mData[115] = s.ReadByte();
            this.mData[116] = s.ReadByte();
            this.mData[117] = s.ReadByte();
            this.mData[118] = s.ReadByte();
            this.mData[119] = s.ReadByte();
            this.mData[120] = s.ReadByte();
            this.mData[121] = s.ReadByte();
            this.mData[122] = s.ReadByte();
            this.mData[123] = s.ReadByte();
            this.mData[124] = s.ReadByte();
            this.mData[125] = s.ReadByte();
            this.mData[126] = s.ReadByte();
            this.mData[127] = s.ReadByte();
            this.mData[128] = s.ReadByte();
            this.mData[129] = s.ReadByte();
            this.mData[130] = s.ReadByte();
            this.mData[131] = s.ReadByte();
            this.mData[132] = s.ReadByte();
            this.mData[133] = s.ReadByte();
            this.mData[134] = s.ReadByte();
            this.mData[135] = s.ReadByte();
            this.mData[136] = s.ReadByte();
            this.mData[137] = s.ReadByte();
            this.mData[138] = s.ReadByte();
            this.mData[139] = s.ReadByte();
            this.mData[140] = s.ReadByte();
            this.mData[141] = s.ReadByte();
            this.mData[142] = s.ReadByte();
            this.mData[143] = s.ReadByte();
            this.mData[144] = s.ReadByte();
            this.mData[145] = s.ReadByte();
            this.mData[146] = s.ReadByte();
            this.mData[147] = s.ReadByte();
            this.mData[148] = s.ReadByte();
            this.mData[149] = s.ReadByte();
            this.mData[150] = s.ReadByte();
            this.mData[151] = s.ReadByte();
            this.mData[152] = s.ReadByte();
            this.mData[153] = s.ReadByte();
            this.mData[154] = s.ReadByte();
            this.mData[155] = s.ReadByte();
            this.mData[156] = s.ReadByte();
            this.mData[157] = s.ReadByte();
            this.mData[158] = s.ReadByte();
            this.mData[159] = s.ReadByte();
            this.mData[160] = s.ReadByte();
            this.mData[161] = s.ReadByte();
            this.mData[162] = s.ReadByte();
            this.mData[163] = s.ReadByte();
            this.mData[164] = s.ReadByte();
            this.mData[165] = s.ReadByte();
            this.mData[166] = s.ReadByte();
            this.mData[167] = s.ReadByte();
            this.mData[168] = s.ReadByte();
            this.mData[169] = s.ReadByte();
            this.mData[170] = s.ReadByte();
            this.mData[171] = s.ReadByte();
            this.mData[172] = s.ReadByte();
            this.mData[173] = s.ReadByte();
            this.mData[174] = s.ReadByte();
            this.mData[175] = s.ReadByte();
            this.mData[176] = s.ReadByte();
            this.mData[177] = s.ReadByte();
            this.mData[178] = s.ReadByte();
            this.mData[179] = s.ReadByte();
            this.mData[180] = s.ReadByte();
            this.mData[181] = s.ReadByte();
            this.mData[182] = s.ReadByte();
            this.mData[183] = s.ReadByte();
            this.mData[184] = s.ReadByte();
            this.mData[185] = s.ReadByte();
            this.mData[186] = s.ReadByte();
            this.mData[187] = s.ReadByte();
            this.mData[188] = s.ReadByte();
            this.mData[189] = s.ReadByte();
            this.mData[190] = s.ReadByte();
            this.mData[191] = s.ReadByte();
            this.mData[192] = s.ReadByte();
            this.mData[193] = s.ReadByte();
            this.mData[194] = s.ReadByte();
            this.mData[195] = s.ReadByte();
            this.mData[196] = s.ReadByte();
            this.mData[197] = s.ReadByte();
            this.mData[198] = s.ReadByte();
            this.mData[199] = s.ReadByte();
            this.mData[200] = s.ReadByte();
            this.mData[201] = s.ReadByte();
            this.mData[202] = s.ReadByte();
            this.mData[203] = s.ReadByte();
            this.mData[204] = s.ReadByte();
            this.mData[205] = s.ReadByte();
            this.mData[206] = s.ReadByte();
            this.mData[207] = s.ReadByte();
            this.mData[208] = s.ReadByte();
            this.mData[209] = s.ReadByte();
            this.mData[210] = s.ReadByte();
            this.mData[211] = s.ReadByte();
            this.mData[212] = s.ReadByte();
            this.mData[213] = s.ReadByte();
            this.mData[214] = s.ReadByte();
            this.mData[215] = s.ReadByte();
            this.mData[216] = s.ReadByte();
            this.mData[217] = s.ReadByte();
            this.mData[218] = s.ReadByte();
            this.mData[219] = s.ReadByte();
            this.mData[220] = s.ReadByte();
            this.mData[221] = s.ReadByte();
            this.mData[222] = s.ReadByte();
            this.mData[223] = s.ReadByte();
            this.mData[224] = s.ReadByte();
            this.mData[225] = s.ReadByte();
            this.mData[226] = s.ReadByte();
            this.mData[227] = s.ReadByte();
            this.mData[228] = s.ReadByte();
            this.mData[229] = s.ReadByte();
            this.mData[230] = s.ReadByte();
            this.mData[231] = s.ReadByte();
            this.mData[232] = s.ReadByte();
            this.mData[233] = s.ReadByte();
            this.mData[234] = s.ReadByte();
            this.mData[235] = s.ReadByte();
            this.mData[236] = s.ReadByte();
            this.mData[237] = s.ReadByte();
            this.mData[238] = s.ReadByte();
            this.mData[239] = s.ReadByte();
            this.mData[240] = s.ReadByte();
            this.mData[241] = s.ReadByte();
            this.mData[242] = s.ReadByte();
            this.mData[243] = s.ReadByte();
            this.mData[244] = s.ReadByte();
            this.mData[245] = s.ReadByte();
            this.mData[246] = s.ReadByte();
            this.mData[247] = s.ReadByte();
            this.mData[248] = s.ReadByte();
            this.mData[249] = s.ReadByte();
            this.mData[250] = s.ReadByte();
            this.mData[251] = s.ReadByte();
            this.mData[252] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = ""
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seqnr",
                Description = "sequence number (starting with 0 on every transmission)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "image data bytes",
                NumElements = 253,
            });

        }

        private UInt16 mSeqnr;
        private byte[] mData = new byte[253];
    }


    // ___________________________________________________________________________________


    public class UasDistanceSensor: UasMessage
    {
        /// <summary>
        /// Time since system boot
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Minimum distance the sensor can measure in centimeters
        /// </summary>
        public UInt16 MinDistance {
            get { return mMinDistance; }
            set { mMinDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Maximum distance the sensor can measure in centimeters
        /// </summary>
        public UInt16 MaxDistance {
            get { return mMaxDistance; }
            set { mMaxDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current distance reading
        /// </summary>
        public UInt16 CurrentDistance {
            get { return mCurrentDistance; }
            set { mCurrentDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type from MAV_DISTANCE_SENSOR enum.
        /// </summary>
        public MavDistanceSensor Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Onboard ID of the sensor
        /// </summary>
        public byte Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Direction the sensor faces from MAV_SENSOR_ORIENTATION enum.
        /// </summary>
        public MavSensorOrientation Orientation {
            get { return mOrientation; }
            set { mOrientation = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Measurement covariance in centimeters, 0 for unknown / invalid readings
        /// </summary>
        public byte Covariance {
            get { return mCovariance; }
            set { mCovariance = value; NotifyUpdated(); }
        }

        public UasDistanceSensor()
        {
            mMessageId = 132;
            CrcExtra = 85;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mMinDistance);
            s.Write(mMaxDistance);
            s.Write(mCurrentDistance);
            s.Write((byte)mType);
            s.Write(mId);
            s.Write((byte)mOrientation);
            s.Write(mCovariance);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mMinDistance = s.ReadUInt16();
            this.mMaxDistance = s.ReadUInt16();
            this.mCurrentDistance = s.ReadUInt16();
            this.mType = (MavDistanceSensor)s.ReadByte();
            this.mId = s.ReadByte();
            this.mOrientation = (MavSensorOrientation)s.ReadByte();
            this.mCovariance = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = ""
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Time since system boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MinDistance",
                Description = "Minimum distance the sensor can measure in centimeters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MaxDistance",
                Description = "Maximum distance the sensor can measure in centimeters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentDistance",
                Description = "Current distance reading",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Type from MAV_DISTANCE_SENSOR enum.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavDistanceSensor"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Onboard ID of the sensor",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Orientation",
                Description = "Direction the sensor faces from MAV_SENSOR_ORIENTATION enum.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavSensorOrientation"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Covariance",
                Description = "Measurement covariance in centimeters, 0 for unknown / invalid readings",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private UInt16 mMinDistance;
        private UInt16 mMaxDistance;
        private UInt16 mCurrentDistance;
        private MavDistanceSensor mType;
        private byte mId;
        private MavSensorOrientation mOrientation;
        private byte mCovariance;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request for terrain data and terrain status
    /// </summary>
    public class UasTerrainRequest: UasMessage
    {
        /// <summary>
        /// Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)
        /// </summary>
        public UInt64 Mask {
            get { return mMask; }
            set { mMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude of SW corner of first grid (degrees *10^7)
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude of SW corner of first grid (in degrees *10^7)
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Grid spacing in meters
        /// </summary>
        public UInt16 GridSpacing {
            get { return mGridSpacing; }
            set { mGridSpacing = value; NotifyUpdated(); }
        }

        public UasTerrainRequest()
        {
            mMessageId = 133;
            CrcExtra = 6;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mMask);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mGridSpacing);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mMask = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mGridSpacing = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request for terrain data and terrain status"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Mask",
                Description = "Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude of SW corner of first grid (degrees *10^7)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude of SW corner of first grid (in degrees *10^7)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GridSpacing",
                Description = "Grid spacing in meters",
                NumElements = 1,
            });

        }

        private UInt64 mMask;
        private Int32 mLat;
        private Int32 mLon;
        private UInt16 mGridSpacing;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUEST
    /// </summary>
    public class UasTerrainData: UasMessage
    {
        /// <summary>
        /// Latitude of SW corner of first grid (degrees *10^7)
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude of SW corner of first grid (in degrees *10^7)
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Grid spacing in meters
        /// </summary>
        public UInt16 GridSpacing {
            get { return mGridSpacing; }
            set { mGridSpacing = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Terrain data in meters AMSL
        /// </summary>
        public Int16[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        /// <summary>
        /// bit within the terrain request mask
        /// </summary>
        public byte Gridbit {
            get { return mGridbit; }
            set { mGridbit = value; NotifyUpdated(); }
        }

        public UasTerrainData()
        {
            mMessageId = 134;
            CrcExtra = 229;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mGridSpacing);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mGridbit);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mGridSpacing = s.ReadUInt16();
            this.mData[0] = s.ReadInt16();
            this.mData[1] = s.ReadInt16();
            this.mData[2] = s.ReadInt16();
            this.mData[3] = s.ReadInt16();
            this.mData[4] = s.ReadInt16();
            this.mData[5] = s.ReadInt16();
            this.mData[6] = s.ReadInt16();
            this.mData[7] = s.ReadInt16();
            this.mData[8] = s.ReadInt16();
            this.mData[9] = s.ReadInt16();
            this.mData[10] = s.ReadInt16();
            this.mData[11] = s.ReadInt16();
            this.mData[12] = s.ReadInt16();
            this.mData[13] = s.ReadInt16();
            this.mData[14] = s.ReadInt16();
            this.mData[15] = s.ReadInt16();
            this.mGridbit = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUEST"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude of SW corner of first grid (degrees *10^7)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude of SW corner of first grid (in degrees *10^7)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GridSpacing",
                Description = "Grid spacing in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "Terrain data in meters AMSL",
                NumElements = 16,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Gridbit",
                Description = "bit within the terrain request mask",
                NumElements = 1,
            });

        }

        private Int32 mLat;
        private Int32 mLon;
        private UInt16 mGridSpacing;
        private Int16[] mData = new Int16[16];
        private byte mGridbit;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle has all terrain data needed for a mission.
    /// </summary>
    public class UasTerrainCheck: UasMessage
    {
        /// <summary>
        /// Latitude (degrees *10^7)
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (degrees *10^7)
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        public UasTerrainCheck()
        {
            mMessageId = 135;
            CrcExtra = 203;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mLat);
            s.Write(mLon);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle has all terrain data needed for a mission."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (degrees *10^7)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (degrees *10^7)",
                NumElements = 1,
            });

        }

        private Int32 mLat;
        private Int32 mLon;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Response from a TERRAIN_CHECK request
    /// </summary>
    public class UasTerrainReport: UasMessage
    {
        /// <summary>
        /// Latitude (degrees *10^7)
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (degrees *10^7)
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Terrain height in meters AMSL
        /// </summary>
        public float TerrainHeight {
            get { return mTerrainHeight; }
            set { mTerrainHeight = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current vehicle height above lat/lon terrain height (meters)
        /// </summary>
        public float CurrentHeight {
            get { return mCurrentHeight; }
            set { mCurrentHeight = value; NotifyUpdated(); }
        }

        /// <summary>
        /// grid spacing (zero if terrain at this location unavailable)
        /// </summary>
        public UInt16 Spacing {
            get { return mSpacing; }
            set { mSpacing = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of 4x4 terrain blocks waiting to be received or read from disk
        /// </summary>
        public UInt16 Pending {
            get { return mPending; }
            set { mPending = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Number of 4x4 terrain blocks in memory
        /// </summary>
        public UInt16 Loaded {
            get { return mLoaded; }
            set { mLoaded = value; NotifyUpdated(); }
        }

        public UasTerrainReport()
        {
            mMessageId = 136;
            CrcExtra = 1;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mTerrainHeight);
            s.Write(mCurrentHeight);
            s.Write(mSpacing);
            s.Write(mPending);
            s.Write(mLoaded);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mTerrainHeight = s.ReadSingle();
            this.mCurrentHeight = s.ReadSingle();
            this.mSpacing = s.ReadUInt16();
            this.mPending = s.ReadUInt16();
            this.mLoaded = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Response from a TERRAIN_CHECK request"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (degrees *10^7)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (degrees *10^7)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TerrainHeight",
                Description = "Terrain height in meters AMSL",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentHeight",
                Description = "Current vehicle height above lat/lon terrain height (meters)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Spacing",
                Description = "grid spacing (zero if terrain at this location unavailable)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pending",
                Description = "Number of 4x4 terrain blocks waiting to be received or read from disk",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Loaded",
                Description = "Number of 4x4 terrain blocks in memory",
                NumElements = 1,
            });

        }

        private Int32 mLat;
        private Int32 mLon;
        private float mTerrainHeight;
        private float mCurrentHeight;
        private UInt16 mSpacing;
        private UInt16 mPending;
        private UInt16 mLoaded;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Barometer readings for 2nd barometer
    /// </summary>
    public class UasScaledPressure2: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure (hectopascal)
        /// </summary>
        public float PressAbs {
            get { return mPressAbs; }
            set { mPressAbs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure 1 (hectopascal)
        /// </summary>
        public float PressDiff {
            get { return mPressDiff; }
            set { mPressDiff = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature measurement (0.01 degrees celsius)
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        public UasScaledPressure2()
        {
            mMessageId = 137;
            CrcExtra = 195;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mPressAbs);
            s.Write(mPressDiff);
            s.Write(mTemperature);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mPressAbs = s.ReadSingle();
            this.mPressDiff = s.ReadSingle();
            this.mTemperature = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Barometer readings for 2nd barometer"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressAbs",
                Description = "Absolute pressure (hectopascal)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressDiff",
                Description = "Differential pressure 1 (hectopascal)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature measurement (0.01 degrees celsius)",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mPressAbs;
        private float mPressDiff;
        private Int16 mTemperature;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Motion capture attitude and position
    /// </summary>
    public class UasAttPosMocap: UasMessage
    {
        /// <summary>
        /// Timestamp (micros since boot or Unix epoch)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X position in meters (NED)
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y position in meters (NED)
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z position in meters (NED)
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        public UasAttPosMocap()
        {
            mMessageId = 138;
            CrcExtra = 109;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Motion capture attitude and position"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (micros since boot or Unix epoch)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "X position in meters (NED)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Y position in meters (NED)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Z position in meters (NED)",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float[] mQ = new float[4];
        private float mX;
        private float mY;
        private float mZ;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set the vehicle attitude and body angular rates.
    /// </summary>
    public class UasSetActuatorControlTarget: UasMessage
    {
        /// <summary>
        /// Timestamp (micros since boot or Unix epoch)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
        /// </summary>
        public float[] Controls {
            get { return mControls; }
            set { mControls = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Actuator group. The '_mlx' indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.
        /// </summary>
        public byte GroupMlx {
            get { return mGroupMlx; }
            set { mGroupMlx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasSetActuatorControlTarget()
        {
            mMessageId = 139;
            CrcExtra = 168;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mControls[0]); 
            s.Write(mControls[1]); 
            s.Write(mControls[2]); 
            s.Write(mControls[3]); 
            s.Write(mControls[4]); 
            s.Write(mControls[5]); 
            s.Write(mControls[6]); 
            s.Write(mControls[7]); 
            s.Write(mGroupMlx);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mControls[0] = s.ReadSingle();
            this.mControls[1] = s.ReadSingle();
            this.mControls[2] = s.ReadSingle();
            this.mControls[3] = s.ReadSingle();
            this.mControls[4] = s.ReadSingle();
            this.mControls[5] = s.ReadSingle();
            this.mControls[6] = s.ReadSingle();
            this.mControls[7] = s.ReadSingle();
            this.mGroupMlx = s.ReadByte();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set the vehicle attitude and body angular rates."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (micros since boot or Unix epoch)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Controls",
                Description = "Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.",
                NumElements = 8,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GroupMlx",
                Description = "Actuator group. The '_mlx' indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float[] mControls = new float[8];
        private byte mGroupMlx;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Set the vehicle attitude and body angular rates.
    /// </summary>
    public class UasActuatorControlTarget: UasMessage
    {
        /// <summary>
        /// Timestamp (micros since boot or Unix epoch)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
        /// </summary>
        public float[] Controls {
            get { return mControls; }
            set { mControls = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Actuator group. The '_mlx' indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.
        /// </summary>
        public byte GroupMlx {
            get { return mGroupMlx; }
            set { mGroupMlx = value; NotifyUpdated(); }
        }

        public UasActuatorControlTarget()
        {
            mMessageId = 140;
            CrcExtra = 181;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mControls[0]); 
            s.Write(mControls[1]); 
            s.Write(mControls[2]); 
            s.Write(mControls[3]); 
            s.Write(mControls[4]); 
            s.Write(mControls[5]); 
            s.Write(mControls[6]); 
            s.Write(mControls[7]); 
            s.Write(mGroupMlx);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mControls[0] = s.ReadSingle();
            this.mControls[1] = s.ReadSingle();
            this.mControls[2] = s.ReadSingle();
            this.mControls[3] = s.ReadSingle();
            this.mControls[4] = s.ReadSingle();
            this.mControls[5] = s.ReadSingle();
            this.mControls[6] = s.ReadSingle();
            this.mControls[7] = s.ReadSingle();
            this.mGroupMlx = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Set the vehicle attitude and body angular rates."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (micros since boot or Unix epoch)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Controls",
                Description = "Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.",
                NumElements = 8,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GroupMlx",
                Description = "Actuator group. The '_mlx' indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float[] mControls = new float[8];
        private byte mGroupMlx;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The current system altitude.
    /// </summary>
    public class UasAltitude: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This altitude measure is initialized on system boot and monotonic (it is never reset, but represents the local altitude change). The only guarantee on this field is that it will never be reset and is consistent within a flight. The recommended value for this field is the uncorrected barometric altitude at boot time. This altitude will also drift and vary between flights.
        /// </summary>
        public float AltitudeMonotonic {
            get { return mAltitudeMonotonic; }
            set { mAltitudeMonotonic = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This altitude measure is strictly above mean sea level and might be non-monotonic (it might reset on events like GPS lock or when a new QNH value is set). It should be the altitude to which global altitude waypoints are compared to. Note that it is *not* the GPS altitude, however, most GPS modules already output AMSL by default and not the WGS84 altitude.
        /// </summary>
        public float AltitudeAmsl {
            get { return mAltitudeAmsl; }
            set { mAltitudeAmsl = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This is the local altitude in the local coordinate frame. It is not the altitude above home, but in reference to the coordinate origin (0, 0, 0). It is up-positive.
        /// </summary>
        public float AltitudeLocal {
            get { return mAltitudeLocal; }
            set { mAltitudeLocal = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This is the altitude above the home position. It resets on each change of the current home position.
        /// </summary>
        public float AltitudeRelative {
            get { return mAltitudeRelative; }
            set { mAltitudeRelative = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This is the altitude above terrain. It might be fed by a terrain database or an altimeter. Values smaller than -1000 should be interpreted as unknown.
        /// </summary>
        public float AltitudeTerrain {
            get { return mAltitudeTerrain; }
            set { mAltitudeTerrain = value; NotifyUpdated(); }
        }

        /// <summary>
        /// This is not the altitude, but the clear space below the system according to the fused clearance estimate. It generally should max out at the maximum range of e.g. the laser altimeter. It is generally a moving target. A negative value indicates no measurement available.
        /// </summary>
        public float BottomClearance {
            get { return mBottomClearance; }
            set { mBottomClearance = value; NotifyUpdated(); }
        }

        public UasAltitude()
        {
            mMessageId = 141;
            CrcExtra = 47;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mAltitudeMonotonic);
            s.Write(mAltitudeAmsl);
            s.Write(mAltitudeLocal);
            s.Write(mAltitudeRelative);
            s.Write(mAltitudeTerrain);
            s.Write(mBottomClearance);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mAltitudeMonotonic = s.ReadSingle();
            this.mAltitudeAmsl = s.ReadSingle();
            this.mAltitudeLocal = s.ReadSingle();
            this.mAltitudeRelative = s.ReadSingle();
            this.mAltitudeTerrain = s.ReadSingle();
            this.mBottomClearance = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The current system altitude."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeMonotonic",
                Description = "This altitude measure is initialized on system boot and monotonic (it is never reset, but represents the local altitude change). The only guarantee on this field is that it will never be reset and is consistent within a flight. The recommended value for this field is the uncorrected barometric altitude at boot time. This altitude will also drift and vary between flights.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeAmsl",
                Description = "This altitude measure is strictly above mean sea level and might be non-monotonic (it might reset on events like GPS lock or when a new QNH value is set). It should be the altitude to which global altitude waypoints are compared to. Note that it is *not* the GPS altitude, however, most GPS modules already output AMSL by default and not the WGS84 altitude.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeLocal",
                Description = "This is the local altitude in the local coordinate frame. It is not the altitude above home, but in reference to the coordinate origin (0, 0, 0). It is up-positive.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeRelative",
                Description = "This is the altitude above the home position. It resets on each change of the current home position.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeTerrain",
                Description = "This is the altitude above terrain. It might be fed by a terrain database or an altimeter. Values smaller than -1000 should be interpreted as unknown.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BottomClearance",
                Description = "This is not the altitude, but the clear space below the system according to the fused clearance estimate. It generally should max out at the maximum range of e.g. the laser altimeter. It is generally a moving target. A negative value indicates no measurement available.",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mAltitudeMonotonic;
        private float mAltitudeAmsl;
        private float mAltitudeLocal;
        private float mAltitudeRelative;
        private float mAltitudeTerrain;
        private float mBottomClearance;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The autopilot is requesting a resource (file, binary, other type of data)
    /// </summary>
    public class UasResourceRequest: UasMessage
    {
        /// <summary>
        /// Request ID. This ID should be re-used when sending back URI contents
        /// </summary>
        public byte RequestId {
            get { return mRequestId; }
            set { mRequestId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary
        /// </summary>
        public byte UriType {
            get { return mUriType; }
            set { mUriType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The requested unique resource identifier (URI). It is not necessarily a straight domain name (depends on the URI type enum)
        /// </summary>
        public byte[] Uri {
            get { return mUri; }
            set { mUri = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.
        /// </summary>
        public byte TransferType {
            get { return mTransferType; }
            set { mTransferType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The storage path the autopilot wants the URI to be stored in. Will only be valid if the transfer_type has a storage associated (e.g. MAVLink FTP).
        /// </summary>
        public byte[] Storage {
            get { return mStorage; }
            set { mStorage = value; NotifyUpdated(); }
        }

        public UasResourceRequest()
        {
            mMessageId = 142;
            CrcExtra = 72;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mRequestId);
            s.Write(mUriType);
            s.Write(mUri[0]); 
            s.Write(mUri[1]); 
            s.Write(mUri[2]); 
            s.Write(mUri[3]); 
            s.Write(mUri[4]); 
            s.Write(mUri[5]); 
            s.Write(mUri[6]); 
            s.Write(mUri[7]); 
            s.Write(mUri[8]); 
            s.Write(mUri[9]); 
            s.Write(mUri[10]); 
            s.Write(mUri[11]); 
            s.Write(mUri[12]); 
            s.Write(mUri[13]); 
            s.Write(mUri[14]); 
            s.Write(mUri[15]); 
            s.Write(mUri[16]); 
            s.Write(mUri[17]); 
            s.Write(mUri[18]); 
            s.Write(mUri[19]); 
            s.Write(mUri[20]); 
            s.Write(mUri[21]); 
            s.Write(mUri[22]); 
            s.Write(mUri[23]); 
            s.Write(mUri[24]); 
            s.Write(mUri[25]); 
            s.Write(mUri[26]); 
            s.Write(mUri[27]); 
            s.Write(mUri[28]); 
            s.Write(mUri[29]); 
            s.Write(mUri[30]); 
            s.Write(mUri[31]); 
            s.Write(mUri[32]); 
            s.Write(mUri[33]); 
            s.Write(mUri[34]); 
            s.Write(mUri[35]); 
            s.Write(mUri[36]); 
            s.Write(mUri[37]); 
            s.Write(mUri[38]); 
            s.Write(mUri[39]); 
            s.Write(mUri[40]); 
            s.Write(mUri[41]); 
            s.Write(mUri[42]); 
            s.Write(mUri[43]); 
            s.Write(mUri[44]); 
            s.Write(mUri[45]); 
            s.Write(mUri[46]); 
            s.Write(mUri[47]); 
            s.Write(mUri[48]); 
            s.Write(mUri[49]); 
            s.Write(mUri[50]); 
            s.Write(mUri[51]); 
            s.Write(mUri[52]); 
            s.Write(mUri[53]); 
            s.Write(mUri[54]); 
            s.Write(mUri[55]); 
            s.Write(mUri[56]); 
            s.Write(mUri[57]); 
            s.Write(mUri[58]); 
            s.Write(mUri[59]); 
            s.Write(mUri[60]); 
            s.Write(mUri[61]); 
            s.Write(mUri[62]); 
            s.Write(mUri[63]); 
            s.Write(mUri[64]); 
            s.Write(mUri[65]); 
            s.Write(mUri[66]); 
            s.Write(mUri[67]); 
            s.Write(mUri[68]); 
            s.Write(mUri[69]); 
            s.Write(mUri[70]); 
            s.Write(mUri[71]); 
            s.Write(mUri[72]); 
            s.Write(mUri[73]); 
            s.Write(mUri[74]); 
            s.Write(mUri[75]); 
            s.Write(mUri[76]); 
            s.Write(mUri[77]); 
            s.Write(mUri[78]); 
            s.Write(mUri[79]); 
            s.Write(mUri[80]); 
            s.Write(mUri[81]); 
            s.Write(mUri[82]); 
            s.Write(mUri[83]); 
            s.Write(mUri[84]); 
            s.Write(mUri[85]); 
            s.Write(mUri[86]); 
            s.Write(mUri[87]); 
            s.Write(mUri[88]); 
            s.Write(mUri[89]); 
            s.Write(mUri[90]); 
            s.Write(mUri[91]); 
            s.Write(mUri[92]); 
            s.Write(mUri[93]); 
            s.Write(mUri[94]); 
            s.Write(mUri[95]); 
            s.Write(mUri[96]); 
            s.Write(mUri[97]); 
            s.Write(mUri[98]); 
            s.Write(mUri[99]); 
            s.Write(mUri[100]); 
            s.Write(mUri[101]); 
            s.Write(mUri[102]); 
            s.Write(mUri[103]); 
            s.Write(mUri[104]); 
            s.Write(mUri[105]); 
            s.Write(mUri[106]); 
            s.Write(mUri[107]); 
            s.Write(mUri[108]); 
            s.Write(mUri[109]); 
            s.Write(mUri[110]); 
            s.Write(mUri[111]); 
            s.Write(mUri[112]); 
            s.Write(mUri[113]); 
            s.Write(mUri[114]); 
            s.Write(mUri[115]); 
            s.Write(mUri[116]); 
            s.Write(mUri[117]); 
            s.Write(mUri[118]); 
            s.Write(mUri[119]); 
            s.Write(mTransferType);
            s.Write(mStorage[0]); 
            s.Write(mStorage[1]); 
            s.Write(mStorage[2]); 
            s.Write(mStorage[3]); 
            s.Write(mStorage[4]); 
            s.Write(mStorage[5]); 
            s.Write(mStorage[6]); 
            s.Write(mStorage[7]); 
            s.Write(mStorage[8]); 
            s.Write(mStorage[9]); 
            s.Write(mStorage[10]); 
            s.Write(mStorage[11]); 
            s.Write(mStorage[12]); 
            s.Write(mStorage[13]); 
            s.Write(mStorage[14]); 
            s.Write(mStorage[15]); 
            s.Write(mStorage[16]); 
            s.Write(mStorage[17]); 
            s.Write(mStorage[18]); 
            s.Write(mStorage[19]); 
            s.Write(mStorage[20]); 
            s.Write(mStorage[21]); 
            s.Write(mStorage[22]); 
            s.Write(mStorage[23]); 
            s.Write(mStorage[24]); 
            s.Write(mStorage[25]); 
            s.Write(mStorage[26]); 
            s.Write(mStorage[27]); 
            s.Write(mStorage[28]); 
            s.Write(mStorage[29]); 
            s.Write(mStorage[30]); 
            s.Write(mStorage[31]); 
            s.Write(mStorage[32]); 
            s.Write(mStorage[33]); 
            s.Write(mStorage[34]); 
            s.Write(mStorage[35]); 
            s.Write(mStorage[36]); 
            s.Write(mStorage[37]); 
            s.Write(mStorage[38]); 
            s.Write(mStorage[39]); 
            s.Write(mStorage[40]); 
            s.Write(mStorage[41]); 
            s.Write(mStorage[42]); 
            s.Write(mStorage[43]); 
            s.Write(mStorage[44]); 
            s.Write(mStorage[45]); 
            s.Write(mStorage[46]); 
            s.Write(mStorage[47]); 
            s.Write(mStorage[48]); 
            s.Write(mStorage[49]); 
            s.Write(mStorage[50]); 
            s.Write(mStorage[51]); 
            s.Write(mStorage[52]); 
            s.Write(mStorage[53]); 
            s.Write(mStorage[54]); 
            s.Write(mStorage[55]); 
            s.Write(mStorage[56]); 
            s.Write(mStorage[57]); 
            s.Write(mStorage[58]); 
            s.Write(mStorage[59]); 
            s.Write(mStorage[60]); 
            s.Write(mStorage[61]); 
            s.Write(mStorage[62]); 
            s.Write(mStorage[63]); 
            s.Write(mStorage[64]); 
            s.Write(mStorage[65]); 
            s.Write(mStorage[66]); 
            s.Write(mStorage[67]); 
            s.Write(mStorage[68]); 
            s.Write(mStorage[69]); 
            s.Write(mStorage[70]); 
            s.Write(mStorage[71]); 
            s.Write(mStorage[72]); 
            s.Write(mStorage[73]); 
            s.Write(mStorage[74]); 
            s.Write(mStorage[75]); 
            s.Write(mStorage[76]); 
            s.Write(mStorage[77]); 
            s.Write(mStorage[78]); 
            s.Write(mStorage[79]); 
            s.Write(mStorage[80]); 
            s.Write(mStorage[81]); 
            s.Write(mStorage[82]); 
            s.Write(mStorage[83]); 
            s.Write(mStorage[84]); 
            s.Write(mStorage[85]); 
            s.Write(mStorage[86]); 
            s.Write(mStorage[87]); 
            s.Write(mStorage[88]); 
            s.Write(mStorage[89]); 
            s.Write(mStorage[90]); 
            s.Write(mStorage[91]); 
            s.Write(mStorage[92]); 
            s.Write(mStorage[93]); 
            s.Write(mStorage[94]); 
            s.Write(mStorage[95]); 
            s.Write(mStorage[96]); 
            s.Write(mStorage[97]); 
            s.Write(mStorage[98]); 
            s.Write(mStorage[99]); 
            s.Write(mStorage[100]); 
            s.Write(mStorage[101]); 
            s.Write(mStorage[102]); 
            s.Write(mStorage[103]); 
            s.Write(mStorage[104]); 
            s.Write(mStorage[105]); 
            s.Write(mStorage[106]); 
            s.Write(mStorage[107]); 
            s.Write(mStorage[108]); 
            s.Write(mStorage[109]); 
            s.Write(mStorage[110]); 
            s.Write(mStorage[111]); 
            s.Write(mStorage[112]); 
            s.Write(mStorage[113]); 
            s.Write(mStorage[114]); 
            s.Write(mStorage[115]); 
            s.Write(mStorage[116]); 
            s.Write(mStorage[117]); 
            s.Write(mStorage[118]); 
            s.Write(mStorage[119]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mRequestId = s.ReadByte();
            this.mUriType = s.ReadByte();
            this.mUri[0] = s.ReadByte();
            this.mUri[1] = s.ReadByte();
            this.mUri[2] = s.ReadByte();
            this.mUri[3] = s.ReadByte();
            this.mUri[4] = s.ReadByte();
            this.mUri[5] = s.ReadByte();
            this.mUri[6] = s.ReadByte();
            this.mUri[7] = s.ReadByte();
            this.mUri[8] = s.ReadByte();
            this.mUri[9] = s.ReadByte();
            this.mUri[10] = s.ReadByte();
            this.mUri[11] = s.ReadByte();
            this.mUri[12] = s.ReadByte();
            this.mUri[13] = s.ReadByte();
            this.mUri[14] = s.ReadByte();
            this.mUri[15] = s.ReadByte();
            this.mUri[16] = s.ReadByte();
            this.mUri[17] = s.ReadByte();
            this.mUri[18] = s.ReadByte();
            this.mUri[19] = s.ReadByte();
            this.mUri[20] = s.ReadByte();
            this.mUri[21] = s.ReadByte();
            this.mUri[22] = s.ReadByte();
            this.mUri[23] = s.ReadByte();
            this.mUri[24] = s.ReadByte();
            this.mUri[25] = s.ReadByte();
            this.mUri[26] = s.ReadByte();
            this.mUri[27] = s.ReadByte();
            this.mUri[28] = s.ReadByte();
            this.mUri[29] = s.ReadByte();
            this.mUri[30] = s.ReadByte();
            this.mUri[31] = s.ReadByte();
            this.mUri[32] = s.ReadByte();
            this.mUri[33] = s.ReadByte();
            this.mUri[34] = s.ReadByte();
            this.mUri[35] = s.ReadByte();
            this.mUri[36] = s.ReadByte();
            this.mUri[37] = s.ReadByte();
            this.mUri[38] = s.ReadByte();
            this.mUri[39] = s.ReadByte();
            this.mUri[40] = s.ReadByte();
            this.mUri[41] = s.ReadByte();
            this.mUri[42] = s.ReadByte();
            this.mUri[43] = s.ReadByte();
            this.mUri[44] = s.ReadByte();
            this.mUri[45] = s.ReadByte();
            this.mUri[46] = s.ReadByte();
            this.mUri[47] = s.ReadByte();
            this.mUri[48] = s.ReadByte();
            this.mUri[49] = s.ReadByte();
            this.mUri[50] = s.ReadByte();
            this.mUri[51] = s.ReadByte();
            this.mUri[52] = s.ReadByte();
            this.mUri[53] = s.ReadByte();
            this.mUri[54] = s.ReadByte();
            this.mUri[55] = s.ReadByte();
            this.mUri[56] = s.ReadByte();
            this.mUri[57] = s.ReadByte();
            this.mUri[58] = s.ReadByte();
            this.mUri[59] = s.ReadByte();
            this.mUri[60] = s.ReadByte();
            this.mUri[61] = s.ReadByte();
            this.mUri[62] = s.ReadByte();
            this.mUri[63] = s.ReadByte();
            this.mUri[64] = s.ReadByte();
            this.mUri[65] = s.ReadByte();
            this.mUri[66] = s.ReadByte();
            this.mUri[67] = s.ReadByte();
            this.mUri[68] = s.ReadByte();
            this.mUri[69] = s.ReadByte();
            this.mUri[70] = s.ReadByte();
            this.mUri[71] = s.ReadByte();
            this.mUri[72] = s.ReadByte();
            this.mUri[73] = s.ReadByte();
            this.mUri[74] = s.ReadByte();
            this.mUri[75] = s.ReadByte();
            this.mUri[76] = s.ReadByte();
            this.mUri[77] = s.ReadByte();
            this.mUri[78] = s.ReadByte();
            this.mUri[79] = s.ReadByte();
            this.mUri[80] = s.ReadByte();
            this.mUri[81] = s.ReadByte();
            this.mUri[82] = s.ReadByte();
            this.mUri[83] = s.ReadByte();
            this.mUri[84] = s.ReadByte();
            this.mUri[85] = s.ReadByte();
            this.mUri[86] = s.ReadByte();
            this.mUri[87] = s.ReadByte();
            this.mUri[88] = s.ReadByte();
            this.mUri[89] = s.ReadByte();
            this.mUri[90] = s.ReadByte();
            this.mUri[91] = s.ReadByte();
            this.mUri[92] = s.ReadByte();
            this.mUri[93] = s.ReadByte();
            this.mUri[94] = s.ReadByte();
            this.mUri[95] = s.ReadByte();
            this.mUri[96] = s.ReadByte();
            this.mUri[97] = s.ReadByte();
            this.mUri[98] = s.ReadByte();
            this.mUri[99] = s.ReadByte();
            this.mUri[100] = s.ReadByte();
            this.mUri[101] = s.ReadByte();
            this.mUri[102] = s.ReadByte();
            this.mUri[103] = s.ReadByte();
            this.mUri[104] = s.ReadByte();
            this.mUri[105] = s.ReadByte();
            this.mUri[106] = s.ReadByte();
            this.mUri[107] = s.ReadByte();
            this.mUri[108] = s.ReadByte();
            this.mUri[109] = s.ReadByte();
            this.mUri[110] = s.ReadByte();
            this.mUri[111] = s.ReadByte();
            this.mUri[112] = s.ReadByte();
            this.mUri[113] = s.ReadByte();
            this.mUri[114] = s.ReadByte();
            this.mUri[115] = s.ReadByte();
            this.mUri[116] = s.ReadByte();
            this.mUri[117] = s.ReadByte();
            this.mUri[118] = s.ReadByte();
            this.mUri[119] = s.ReadByte();
            this.mTransferType = s.ReadByte();
            this.mStorage[0] = s.ReadByte();
            this.mStorage[1] = s.ReadByte();
            this.mStorage[2] = s.ReadByte();
            this.mStorage[3] = s.ReadByte();
            this.mStorage[4] = s.ReadByte();
            this.mStorage[5] = s.ReadByte();
            this.mStorage[6] = s.ReadByte();
            this.mStorage[7] = s.ReadByte();
            this.mStorage[8] = s.ReadByte();
            this.mStorage[9] = s.ReadByte();
            this.mStorage[10] = s.ReadByte();
            this.mStorage[11] = s.ReadByte();
            this.mStorage[12] = s.ReadByte();
            this.mStorage[13] = s.ReadByte();
            this.mStorage[14] = s.ReadByte();
            this.mStorage[15] = s.ReadByte();
            this.mStorage[16] = s.ReadByte();
            this.mStorage[17] = s.ReadByte();
            this.mStorage[18] = s.ReadByte();
            this.mStorage[19] = s.ReadByte();
            this.mStorage[20] = s.ReadByte();
            this.mStorage[21] = s.ReadByte();
            this.mStorage[22] = s.ReadByte();
            this.mStorage[23] = s.ReadByte();
            this.mStorage[24] = s.ReadByte();
            this.mStorage[25] = s.ReadByte();
            this.mStorage[26] = s.ReadByte();
            this.mStorage[27] = s.ReadByte();
            this.mStorage[28] = s.ReadByte();
            this.mStorage[29] = s.ReadByte();
            this.mStorage[30] = s.ReadByte();
            this.mStorage[31] = s.ReadByte();
            this.mStorage[32] = s.ReadByte();
            this.mStorage[33] = s.ReadByte();
            this.mStorage[34] = s.ReadByte();
            this.mStorage[35] = s.ReadByte();
            this.mStorage[36] = s.ReadByte();
            this.mStorage[37] = s.ReadByte();
            this.mStorage[38] = s.ReadByte();
            this.mStorage[39] = s.ReadByte();
            this.mStorage[40] = s.ReadByte();
            this.mStorage[41] = s.ReadByte();
            this.mStorage[42] = s.ReadByte();
            this.mStorage[43] = s.ReadByte();
            this.mStorage[44] = s.ReadByte();
            this.mStorage[45] = s.ReadByte();
            this.mStorage[46] = s.ReadByte();
            this.mStorage[47] = s.ReadByte();
            this.mStorage[48] = s.ReadByte();
            this.mStorage[49] = s.ReadByte();
            this.mStorage[50] = s.ReadByte();
            this.mStorage[51] = s.ReadByte();
            this.mStorage[52] = s.ReadByte();
            this.mStorage[53] = s.ReadByte();
            this.mStorage[54] = s.ReadByte();
            this.mStorage[55] = s.ReadByte();
            this.mStorage[56] = s.ReadByte();
            this.mStorage[57] = s.ReadByte();
            this.mStorage[58] = s.ReadByte();
            this.mStorage[59] = s.ReadByte();
            this.mStorage[60] = s.ReadByte();
            this.mStorage[61] = s.ReadByte();
            this.mStorage[62] = s.ReadByte();
            this.mStorage[63] = s.ReadByte();
            this.mStorage[64] = s.ReadByte();
            this.mStorage[65] = s.ReadByte();
            this.mStorage[66] = s.ReadByte();
            this.mStorage[67] = s.ReadByte();
            this.mStorage[68] = s.ReadByte();
            this.mStorage[69] = s.ReadByte();
            this.mStorage[70] = s.ReadByte();
            this.mStorage[71] = s.ReadByte();
            this.mStorage[72] = s.ReadByte();
            this.mStorage[73] = s.ReadByte();
            this.mStorage[74] = s.ReadByte();
            this.mStorage[75] = s.ReadByte();
            this.mStorage[76] = s.ReadByte();
            this.mStorage[77] = s.ReadByte();
            this.mStorage[78] = s.ReadByte();
            this.mStorage[79] = s.ReadByte();
            this.mStorage[80] = s.ReadByte();
            this.mStorage[81] = s.ReadByte();
            this.mStorage[82] = s.ReadByte();
            this.mStorage[83] = s.ReadByte();
            this.mStorage[84] = s.ReadByte();
            this.mStorage[85] = s.ReadByte();
            this.mStorage[86] = s.ReadByte();
            this.mStorage[87] = s.ReadByte();
            this.mStorage[88] = s.ReadByte();
            this.mStorage[89] = s.ReadByte();
            this.mStorage[90] = s.ReadByte();
            this.mStorage[91] = s.ReadByte();
            this.mStorage[92] = s.ReadByte();
            this.mStorage[93] = s.ReadByte();
            this.mStorage[94] = s.ReadByte();
            this.mStorage[95] = s.ReadByte();
            this.mStorage[96] = s.ReadByte();
            this.mStorage[97] = s.ReadByte();
            this.mStorage[98] = s.ReadByte();
            this.mStorage[99] = s.ReadByte();
            this.mStorage[100] = s.ReadByte();
            this.mStorage[101] = s.ReadByte();
            this.mStorage[102] = s.ReadByte();
            this.mStorage[103] = s.ReadByte();
            this.mStorage[104] = s.ReadByte();
            this.mStorage[105] = s.ReadByte();
            this.mStorage[106] = s.ReadByte();
            this.mStorage[107] = s.ReadByte();
            this.mStorage[108] = s.ReadByte();
            this.mStorage[109] = s.ReadByte();
            this.mStorage[110] = s.ReadByte();
            this.mStorage[111] = s.ReadByte();
            this.mStorage[112] = s.ReadByte();
            this.mStorage[113] = s.ReadByte();
            this.mStorage[114] = s.ReadByte();
            this.mStorage[115] = s.ReadByte();
            this.mStorage[116] = s.ReadByte();
            this.mStorage[117] = s.ReadByte();
            this.mStorage[118] = s.ReadByte();
            this.mStorage[119] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The autopilot is requesting a resource (file, binary, other type of data)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RequestId",
                Description = "Request ID. This ID should be re-used when sending back URI contents",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "UriType",
                Description = "The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Uri",
                Description = "The requested unique resource identifier (URI). It is not necessarily a straight domain name (depends on the URI type enum)",
                NumElements = 120,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TransferType",
                Description = "The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Storage",
                Description = "The storage path the autopilot wants the URI to be stored in. Will only be valid if the transfer_type has a storage associated (e.g. MAVLink FTP).",
                NumElements = 120,
            });

        }

        private byte mRequestId;
        private byte mUriType;
        private byte[] mUri = new byte[120];
        private byte mTransferType;
        private byte[] mStorage = new byte[120];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Barometer readings for 3rd barometer
    /// </summary>
    public class UasScaledPressure3: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Absolute pressure (hectopascal)
        /// </summary>
        public float PressAbs {
            get { return mPressAbs; }
            set { mPressAbs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure 1 (hectopascal)
        /// </summary>
        public float PressDiff {
            get { return mPressDiff; }
            set { mPressDiff = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature measurement (0.01 degrees celsius)
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        public UasScaledPressure3()
        {
            mMessageId = 143;
            CrcExtra = 131;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mPressAbs);
            s.Write(mPressDiff);
            s.Write(mTemperature);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mPressAbs = s.ReadSingle();
            this.mPressDiff = s.ReadSingle();
            this.mTemperature = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Barometer readings for 3rd barometer"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressAbs",
                Description = "Absolute pressure (hectopascal)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PressDiff",
                Description = "Differential pressure 1 (hectopascal)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature measurement (0.01 degrees celsius)",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mPressAbs;
        private float mPressDiff;
        private Int16 mTemperature;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// current motion information from a designated system
    /// </summary>
    public class UasFollowTarget: UasMessage
    {
        /// <summary>
        /// Timestamp in milliseconds since system boot
        /// </summary>
        public UInt64 Timestamp {
            get { return mTimestamp; }
            set { mTimestamp = value; NotifyUpdated(); }
        }

        /// <summary>
        /// button states or switches of a tracker device
        /// </summary>
        public UInt64 CustomState {
            get { return mCustomState; }
            set { mCustomState = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// AMSL, in meters
        /// </summary>
        public float Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// target velocity (0,0,0) for unknown
        /// </summary>
        public float[] Vel {
            get { return mVel; }
            set { mVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// linear target acceleration (0,0,0) for unknown
        /// </summary>
        public float[] Acc {
            get { return mAcc; }
            set { mAcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// (1 0 0 0 for unknown)
        /// </summary>
        public float[] AttitudeQ {
            get { return mAttitudeQ; }
            set { mAttitudeQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// (0 0 0 for unknown)
        /// </summary>
        public float[] Rates {
            get { return mRates; }
            set { mRates = value; NotifyUpdated(); }
        }

        /// <summary>
        /// eph epv
        /// </summary>
        public float[] PositionCov {
            get { return mPositionCov; }
            set { mPositionCov = value; NotifyUpdated(); }
        }

        /// <summary>
        /// bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)
        /// </summary>
        public byte EstCapabilities {
            get { return mEstCapabilities; }
            set { mEstCapabilities = value; NotifyUpdated(); }
        }

        public UasFollowTarget()
        {
            mMessageId = 144;
            CrcExtra = 127;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimestamp);
            s.Write(mCustomState);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAlt);
            s.Write(mVel[0]); 
            s.Write(mVel[1]); 
            s.Write(mVel[2]); 
            s.Write(mAcc[0]); 
            s.Write(mAcc[1]); 
            s.Write(mAcc[2]); 
            s.Write(mAttitudeQ[0]); 
            s.Write(mAttitudeQ[1]); 
            s.Write(mAttitudeQ[2]); 
            s.Write(mAttitudeQ[3]); 
            s.Write(mRates[0]); 
            s.Write(mRates[1]); 
            s.Write(mRates[2]); 
            s.Write(mPositionCov[0]); 
            s.Write(mPositionCov[1]); 
            s.Write(mPositionCov[2]); 
            s.Write(mEstCapabilities);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimestamp = s.ReadUInt64();
            this.mCustomState = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAlt = s.ReadSingle();
            this.mVel[0] = s.ReadSingle();
            this.mVel[1] = s.ReadSingle();
            this.mVel[2] = s.ReadSingle();
            this.mAcc[0] = s.ReadSingle();
            this.mAcc[1] = s.ReadSingle();
            this.mAcc[2] = s.ReadSingle();
            this.mAttitudeQ[0] = s.ReadSingle();
            this.mAttitudeQ[1] = s.ReadSingle();
            this.mAttitudeQ[2] = s.ReadSingle();
            this.mAttitudeQ[3] = s.ReadSingle();
            this.mRates[0] = s.ReadSingle();
            this.mRates[1] = s.ReadSingle();
            this.mRates[2] = s.ReadSingle();
            this.mPositionCov[0] = s.ReadSingle();
            this.mPositionCov[1] = s.ReadSingle();
            this.mPositionCov[2] = s.ReadSingle();
            this.mEstCapabilities = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "current motion information from a designated system"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Timestamp",
                Description = "Timestamp in milliseconds since system boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CustomState",
                Description = "button states or switches of a tracker device",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "AMSL, in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vel",
                Description = "target velocity (0,0,0) for unknown",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Acc",
                Description = "linear target acceleration (0,0,0) for unknown",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AttitudeQ",
                Description = "(1 0 0 0 for unknown)",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rates",
                Description = "(0 0 0 for unknown)",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PositionCov",
                Description = "eph epv",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EstCapabilities",
                Description = "bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)",
                NumElements = 1,
            });

        }

        private UInt64 mTimestamp;
        private UInt64 mCustomState;
        private Int32 mLat;
        private Int32 mLon;
        private float mAlt;
        private float[] mVel = new float[3];
        private float[] mAcc = new float[3];
        private float[] mAttitudeQ = new float[4];
        private float[] mRates = new float[3];
        private float[] mPositionCov = new float[3];
        private byte mEstCapabilities;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The smoothed, monotonic system state used to feed the control loops of the system.
    /// </summary>
    public class UasControlSystemState: UasMessage
    {
        /// <summary>
        /// Timestamp (micros since boot or Unix epoch)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration in body frame
        /// </summary>
        public float XAcc {
            get { return mXAcc; }
            set { mXAcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration in body frame
        /// </summary>
        public float YAcc {
            get { return mYAcc; }
            set { mYAcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration in body frame
        /// </summary>
        public float ZAcc {
            get { return mZAcc; }
            set { mZAcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X velocity in body frame
        /// </summary>
        public float XVel {
            get { return mXVel; }
            set { mXVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y velocity in body frame
        /// </summary>
        public float YVel {
            get { return mYVel; }
            set { mYVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z velocity in body frame
        /// </summary>
        public float ZVel {
            get { return mZVel; }
            set { mZVel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X position in local frame
        /// </summary>
        public float XPos {
            get { return mXPos; }
            set { mXPos = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y position in local frame
        /// </summary>
        public float YPos {
            get { return mYPos; }
            set { mYPos = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z position in local frame
        /// </summary>
        public float ZPos {
            get { return mZPos; }
            set { mZPos = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Airspeed, set to -1 if unknown
        /// </summary>
        public float Airspeed {
            get { return mAirspeed; }
            set { mAirspeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variance of body velocity estimate
        /// </summary>
        public float[] VelVariance {
            get { return mVelVariance; }
            set { mVelVariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variance in local position
        /// </summary>
        public float[] PosVariance {
            get { return mPosVariance; }
            set { mPosVariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The attitude, represented as Quaternion
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular rate in roll axis
        /// </summary>
        public float RollRate {
            get { return mRollRate; }
            set { mRollRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular rate in pitch axis
        /// </summary>
        public float PitchRate {
            get { return mPitchRate; }
            set { mPitchRate = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular rate in yaw axis
        /// </summary>
        public float YawRate {
            get { return mYawRate; }
            set { mYawRate = value; NotifyUpdated(); }
        }

        public UasControlSystemState()
        {
            mMessageId = 146;
            CrcExtra = 103;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mXAcc);
            s.Write(mYAcc);
            s.Write(mZAcc);
            s.Write(mXVel);
            s.Write(mYVel);
            s.Write(mZVel);
            s.Write(mXPos);
            s.Write(mYPos);
            s.Write(mZPos);
            s.Write(mAirspeed);
            s.Write(mVelVariance[0]); 
            s.Write(mVelVariance[1]); 
            s.Write(mVelVariance[2]); 
            s.Write(mPosVariance[0]); 
            s.Write(mPosVariance[1]); 
            s.Write(mPosVariance[2]); 
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mRollRate);
            s.Write(mPitchRate);
            s.Write(mYawRate);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mXAcc = s.ReadSingle();
            this.mYAcc = s.ReadSingle();
            this.mZAcc = s.ReadSingle();
            this.mXVel = s.ReadSingle();
            this.mYVel = s.ReadSingle();
            this.mZVel = s.ReadSingle();
            this.mXPos = s.ReadSingle();
            this.mYPos = s.ReadSingle();
            this.mZPos = s.ReadSingle();
            this.mAirspeed = s.ReadSingle();
            this.mVelVariance[0] = s.ReadSingle();
            this.mVelVariance[1] = s.ReadSingle();
            this.mVelVariance[2] = s.ReadSingle();
            this.mPosVariance[0] = s.ReadSingle();
            this.mPosVariance[1] = s.ReadSingle();
            this.mPosVariance[2] = s.ReadSingle();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mRollRate = s.ReadSingle();
            this.mPitchRate = s.ReadSingle();
            this.mYawRate = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The smoothed, monotonic system state used to feed the control loops of the system."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (micros since boot or Unix epoch)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "XAcc",
                Description = "X acceleration in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YAcc",
                Description = "Y acceleration in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ZAcc",
                Description = "Z acceleration in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "XVel",
                Description = "X velocity in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YVel",
                Description = "Y velocity in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ZVel",
                Description = "Z velocity in body frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "XPos",
                Description = "X position in local frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YPos",
                Description = "Y position in local frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ZPos",
                Description = "Z position in local frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Airspeed",
                Description = "Airspeed, set to -1 if unknown",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VelVariance",
                Description = "Variance of body velocity estimate",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosVariance",
                Description = "Variance in local position",
                NumElements = 3,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "The attitude, represented as Quaternion",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RollRate",
                Description = "Angular rate in roll axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PitchRate",
                Description = "Angular rate in pitch axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "YawRate",
                Description = "Angular rate in yaw axis",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mXAcc;
        private float mYAcc;
        private float mZAcc;
        private float mXVel;
        private float mYVel;
        private float mZVel;
        private float mXPos;
        private float mYPos;
        private float mZPos;
        private float mAirspeed;
        private float[] mVelVariance = new float[3];
        private float[] mPosVariance = new float[3];
        private float[] mQ = new float[4];
        private float mRollRate;
        private float mPitchRate;
        private float mYawRate;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Battery information
    /// </summary>
    public class UasBatteryStatus: UasMessage
    {
        /// <summary>
        /// Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate
        /// </summary>
        public Int32 CurrentConsumed {
            get { return mCurrentConsumed; }
            set { mCurrentConsumed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Consumed energy, in 100*Joules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate
        /// </summary>
        public Int32 EnergyConsumed {
            get { return mEnergyConsumed; }
            set { mEnergyConsumed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Temperature of the battery in centi-degrees celsius. INT16_MAX for unknown temperature.
        /// </summary>
        public Int16 Temperature {
            get { return mTemperature; }
            set { mTemperature = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery voltage of cells, in millivolts (1 = 1 millivolt). Cells above the valid cell count for this battery should have the UINT16_MAX value.
        /// </summary>
        public UInt16[] Voltages {
            get { return mVoltages; }
            set { mVoltages = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
        /// </summary>
        public Int16 CurrentBattery {
            get { return mCurrentBattery; }
            set { mCurrentBattery = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery ID
        /// </summary>
        public byte Id {
            get { return mId; }
            set { mId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Function of the battery
        /// </summary>
        public byte BatteryFunction {
            get { return mBatteryFunction; }
            set { mBatteryFunction = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type (chemistry) of the battery
        /// </summary>
        public byte Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery
        /// </summary>
        public SByte BatteryRemaining {
            get { return mBatteryRemaining; }
            set { mBatteryRemaining = value; NotifyUpdated(); }
        }

        public UasBatteryStatus()
        {
            mMessageId = 147;
            CrcExtra = 154;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mCurrentConsumed);
            s.Write(mEnergyConsumed);
            s.Write(mTemperature);
            s.Write(mVoltages[0]); 
            s.Write(mVoltages[1]); 
            s.Write(mVoltages[2]); 
            s.Write(mVoltages[3]); 
            s.Write(mVoltages[4]); 
            s.Write(mVoltages[5]); 
            s.Write(mVoltages[6]); 
            s.Write(mVoltages[7]); 
            s.Write(mVoltages[8]); 
            s.Write(mVoltages[9]); 
            s.Write(mCurrentBattery);
            s.Write(mId);
            s.Write(mBatteryFunction);
            s.Write(mType);
            s.Write(mBatteryRemaining);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mCurrentConsumed = s.ReadInt32();
            this.mEnergyConsumed = s.ReadInt32();
            this.mTemperature = s.ReadInt16();
            this.mVoltages[0] = s.ReadUInt16();
            this.mVoltages[1] = s.ReadUInt16();
            this.mVoltages[2] = s.ReadUInt16();
            this.mVoltages[3] = s.ReadUInt16();
            this.mVoltages[4] = s.ReadUInt16();
            this.mVoltages[5] = s.ReadUInt16();
            this.mVoltages[6] = s.ReadUInt16();
            this.mVoltages[7] = s.ReadUInt16();
            this.mVoltages[8] = s.ReadUInt16();
            this.mVoltages[9] = s.ReadUInt16();
            this.mCurrentBattery = s.ReadInt16();
            this.mId = s.ReadByte();
            this.mBatteryFunction = s.ReadByte();
            this.mType = s.ReadByte();
            this.mBatteryRemaining = s.ReadSByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Battery information"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentConsumed",
                Description = "Consumed charge, in milliampere hours (1 = 1 mAh), -1: autopilot does not provide mAh consumption estimate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EnergyConsumed",
                Description = "Consumed energy, in 100*Joules (intergrated U*I*dt)  (1 = 100 Joule), -1: autopilot does not provide energy consumption estimate",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Temperature",
                Description = "Temperature of the battery in centi-degrees celsius. INT16_MAX for unknown temperature.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Voltages",
                Description = "Battery voltage of cells, in millivolts (1 = 1 millivolt). Cells above the valid cell count for this battery should have the UINT16_MAX value.",
                NumElements = 10,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentBattery",
                Description = "Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Id",
                Description = "Battery ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BatteryFunction",
                Description = "Function of the battery",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Type (chemistry) of the battery",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BatteryRemaining",
                Description = "Remaining battery energy: (0%: 0, 100%: 100), -1: autopilot does not estimate the remaining battery",
                NumElements = 1,
            });

        }

        private Int32 mCurrentConsumed;
        private Int32 mEnergyConsumed;
        private Int16 mTemperature;
        private UInt16[] mVoltages = new UInt16[10];
        private Int16 mCurrentBattery;
        private byte mId;
        private byte mBatteryFunction;
        private byte mType;
        private SByte mBatteryRemaining;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Version and capability of autopilot software
    /// </summary>
    public class UasAutopilotVersion: UasMessage
    {
        /// <summary>
        /// bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum)
        /// </summary>
        public MavProtocolCapability Capabilities {
            get { return mCapabilities; }
            set { mCapabilities = value; NotifyUpdated(); }
        }

        /// <summary>
        /// UID if provided by hardware
        /// </summary>
        public UInt64 Uid {
            get { return mUid; }
            set { mUid = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Firmware version number
        /// </summary>
        public UInt32 FlightSwVersion {
            get { return mFlightSwVersion; }
            set { mFlightSwVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Middleware version number
        /// </summary>
        public UInt32 MiddlewareSwVersion {
            get { return mMiddlewareSwVersion; }
            set { mMiddlewareSwVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Operating system version number
        /// </summary>
        public UInt32 OsSwVersion {
            get { return mOsSwVersion; }
            set { mOsSwVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// HW / board version (last 8 bytes should be silicon ID, if any)
        /// </summary>
        public UInt32 BoardVersion {
            get { return mBoardVersion; }
            set { mBoardVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ID of the board vendor
        /// </summary>
        public UInt16 VendorId {
            get { return mVendorId; }
            set { mVendorId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ID of the product
        /// </summary>
        public UInt16 ProductId {
            get { return mProductId; }
            set { mProductId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
        /// </summary>
        public byte[] FlightCustomVersion {
            get { return mFlightCustomVersion; }
            set { mFlightCustomVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
        /// </summary>
        public byte[] MiddlewareCustomVersion {
            get { return mMiddlewareCustomVersion; }
            set { mMiddlewareCustomVersion = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
        /// </summary>
        public byte[] OsCustomVersion {
            get { return mOsCustomVersion; }
            set { mOsCustomVersion = value; NotifyUpdated(); }
        }

        public UasAutopilotVersion()
        {
            mMessageId = 148;
            CrcExtra = 178;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write((UInt64)mCapabilities);
            s.Write(mUid);
            s.Write(mFlightSwVersion);
            s.Write(mMiddlewareSwVersion);
            s.Write(mOsSwVersion);
            s.Write(mBoardVersion);
            s.Write(mVendorId);
            s.Write(mProductId);
            s.Write(mFlightCustomVersion[0]); 
            s.Write(mFlightCustomVersion[1]); 
            s.Write(mFlightCustomVersion[2]); 
            s.Write(mFlightCustomVersion[3]); 
            s.Write(mFlightCustomVersion[4]); 
            s.Write(mFlightCustomVersion[5]); 
            s.Write(mFlightCustomVersion[6]); 
            s.Write(mFlightCustomVersion[7]); 
            s.Write(mMiddlewareCustomVersion[0]); 
            s.Write(mMiddlewareCustomVersion[1]); 
            s.Write(mMiddlewareCustomVersion[2]); 
            s.Write(mMiddlewareCustomVersion[3]); 
            s.Write(mMiddlewareCustomVersion[4]); 
            s.Write(mMiddlewareCustomVersion[5]); 
            s.Write(mMiddlewareCustomVersion[6]); 
            s.Write(mMiddlewareCustomVersion[7]); 
            s.Write(mOsCustomVersion[0]); 
            s.Write(mOsCustomVersion[1]); 
            s.Write(mOsCustomVersion[2]); 
            s.Write(mOsCustomVersion[3]); 
            s.Write(mOsCustomVersion[4]); 
            s.Write(mOsCustomVersion[5]); 
            s.Write(mOsCustomVersion[6]); 
            s.Write(mOsCustomVersion[7]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mCapabilities = (MavProtocolCapability)s.ReadUInt64();
            this.mUid = s.ReadUInt64();
            this.mFlightSwVersion = s.ReadUInt32();
            this.mMiddlewareSwVersion = s.ReadUInt32();
            this.mOsSwVersion = s.ReadUInt32();
            this.mBoardVersion = s.ReadUInt32();
            this.mVendorId = s.ReadUInt16();
            this.mProductId = s.ReadUInt16();
            this.mFlightCustomVersion[0] = s.ReadByte();
            this.mFlightCustomVersion[1] = s.ReadByte();
            this.mFlightCustomVersion[2] = s.ReadByte();
            this.mFlightCustomVersion[3] = s.ReadByte();
            this.mFlightCustomVersion[4] = s.ReadByte();
            this.mFlightCustomVersion[5] = s.ReadByte();
            this.mFlightCustomVersion[6] = s.ReadByte();
            this.mFlightCustomVersion[7] = s.ReadByte();
            this.mMiddlewareCustomVersion[0] = s.ReadByte();
            this.mMiddlewareCustomVersion[1] = s.ReadByte();
            this.mMiddlewareCustomVersion[2] = s.ReadByte();
            this.mMiddlewareCustomVersion[3] = s.ReadByte();
            this.mMiddlewareCustomVersion[4] = s.ReadByte();
            this.mMiddlewareCustomVersion[5] = s.ReadByte();
            this.mMiddlewareCustomVersion[6] = s.ReadByte();
            this.mMiddlewareCustomVersion[7] = s.ReadByte();
            this.mOsCustomVersion[0] = s.ReadByte();
            this.mOsCustomVersion[1] = s.ReadByte();
            this.mOsCustomVersion[2] = s.ReadByte();
            this.mOsCustomVersion[3] = s.ReadByte();
            this.mOsCustomVersion[4] = s.ReadByte();
            this.mOsCustomVersion[5] = s.ReadByte();
            this.mOsCustomVersion[6] = s.ReadByte();
            this.mOsCustomVersion[7] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Version and capability of autopilot software"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Capabilities",
                Description = "bitmask of capabilities (see MAV_PROTOCOL_CAPABILITY enum)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavProtocolCapability"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Uid",
                Description = "UID if provided by hardware",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlightSwVersion",
                Description = "Firmware version number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MiddlewareSwVersion",
                Description = "Middleware version number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OsSwVersion",
                Description = "Operating system version number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BoardVersion",
                Description = "HW / board version (last 8 bytes should be silicon ID, if any)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VendorId",
                Description = "ID of the board vendor",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ProductId",
                Description = "ID of the product",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FlightCustomVersion",
                Description = "Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.",
                NumElements = 8,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MiddlewareCustomVersion",
                Description = "Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.",
                NumElements = 8,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OsCustomVersion",
                Description = "Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.",
                NumElements = 8,
            });

        }

        private MavProtocolCapability mCapabilities;
        private UInt64 mUid;
        private UInt32 mFlightSwVersion;
        private UInt32 mMiddlewareSwVersion;
        private UInt32 mOsSwVersion;
        private UInt32 mBoardVersion;
        private UInt16 mVendorId;
        private UInt16 mProductId;
        private byte[] mFlightCustomVersion = new byte[8];
        private byte[] mMiddlewareCustomVersion = new byte[8];
        private byte[] mOsCustomVersion = new byte[8];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The location of a landing area captured from a downward facing camera
    /// </summary>
    public class UasLandingTarget: UasMessage
    {
        /// <summary>
        /// Timestamp (micros since boot or Unix epoch)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X-axis angular offset (in radians) of the target from the center of the image
        /// </summary>
        public float AngleX {
            get { return mAngleX; }
            set { mAngleX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y-axis angular offset (in radians) of the target from the center of the image
        /// </summary>
        public float AngleY {
            get { return mAngleY; }
            set { mAngleY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Distance to the target from the vehicle in meters
        /// </summary>
        public float Distance {
            get { return mDistance; }
            set { mDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Size in radians of target along x-axis
        /// </summary>
        public float SizeX {
            get { return mSizeX; }
            set { mSizeX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Size in radians of target along y-axis
        /// </summary>
        public float SizeY {
            get { return mSizeY; }
            set { mSizeY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The ID of the target if multiple targets are present
        /// </summary>
        public byte TargetNum {
            get { return mTargetNum; }
            set { mTargetNum = value; NotifyUpdated(); }
        }

        /// <summary>
        /// MAV_FRAME enum specifying the whether the following feilds are earth-frame, body-frame, etc.
        /// </summary>
        public MavFrame Frame {
            get { return mFrame; }
            set { mFrame = value; NotifyUpdated(); }
        }

        public UasLandingTarget()
        {
            mMessageId = 149;
            CrcExtra = 200;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mAngleX);
            s.Write(mAngleY);
            s.Write(mDistance);
            s.Write(mSizeX);
            s.Write(mSizeY);
            s.Write(mTargetNum);
            s.Write((byte)mFrame);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mAngleX = s.ReadSingle();
            this.mAngleY = s.ReadSingle();
            this.mDistance = s.ReadSingle();
            this.mSizeX = s.ReadSingle();
            this.mSizeY = s.ReadSingle();
            this.mTargetNum = s.ReadByte();
            this.mFrame = (MavFrame)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The location of a landing area captured from a downward facing camera"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (micros since boot or Unix epoch)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AngleX",
                Description = "X-axis angular offset (in radians) of the target from the center of the image",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AngleY",
                Description = "Y-axis angular offset (in radians) of the target from the center of the image",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Distance",
                Description = "Distance to the target from the vehicle in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SizeX",
                Description = "Size in radians of target along x-axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SizeY",
                Description = "Size in radians of target along y-axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetNum",
                Description = "The ID of the target if multiple targets are present",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Frame",
                Description = "MAV_FRAME enum specifying the whether the following feilds are earth-frame, body-frame, etc.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavFrame"),
            });

        }

        private UInt64 mTimeUsec;
        private float mAngleX;
        private float mAngleY;
        private float mDistance;
        private float mSizeX;
        private float mSizeY;
        private byte mTargetNum;
        private MavFrame mFrame;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS enum definition for further information. The innovaton test ratios show the magnitude of the sensor innovation divided by the innovation check threshold. Under normal operation the innovaton test ratios should be below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should be optional and controllable by the user.
    /// </summary>
    public class UasEstimatorStatus: UasMessage
    {
        /// <summary>
        /// Timestamp (micros since boot or Unix epoch)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Velocity innovation test ratio
        /// </summary>
        public float VelRatio {
            get { return mVelRatio; }
            set { mVelRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Horizontal position innovation test ratio
        /// </summary>
        public float PosHorizRatio {
            get { return mPosHorizRatio; }
            set { mPosHorizRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vertical position innovation test ratio
        /// </summary>
        public float PosVertRatio {
            get { return mPosVertRatio; }
            set { mPosVertRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Magnetometer innovation test ratio
        /// </summary>
        public float MagRatio {
            get { return mMagRatio; }
            set { mMagRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Height above terrain innovation test ratio
        /// </summary>
        public float HaglRatio {
            get { return mHaglRatio; }
            set { mHaglRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// True airspeed innovation test ratio
        /// </summary>
        public float TasRatio {
            get { return mTasRatio; }
            set { mTasRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Horizontal position 1-STD accuracy relative to the EKF local origin (m)
        /// </summary>
        public float PosHorizAccuracy {
            get { return mPosHorizAccuracy; }
            set { mPosHorizAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vertical position 1-STD accuracy relative to the EKF local origin (m)
        /// </summary>
        public float PosVertAccuracy {
            get { return mPosVertAccuracy; }
            set { mPosVertAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Integer bitmask indicating which EKF outputs are valid. See definition for ESTIMATOR_STATUS_FLAGS.
        /// </summary>
        public EstimatorStatusFlags Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        public UasEstimatorStatus()
        {
            mMessageId = 230;
            CrcExtra = 163;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mVelRatio);
            s.Write(mPosHorizRatio);
            s.Write(mPosVertRatio);
            s.Write(mMagRatio);
            s.Write(mHaglRatio);
            s.Write(mTasRatio);
            s.Write(mPosHorizAccuracy);
            s.Write(mPosVertAccuracy);
            s.Write((UInt16)mFlags);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mVelRatio = s.ReadSingle();
            this.mPosHorizRatio = s.ReadSingle();
            this.mPosVertRatio = s.ReadSingle();
            this.mMagRatio = s.ReadSingle();
            this.mHaglRatio = s.ReadSingle();
            this.mTasRatio = s.ReadSingle();
            this.mPosHorizAccuracy = s.ReadSingle();
            this.mPosVertAccuracy = s.ReadSingle();
            this.mFlags = (EstimatorStatusFlags)s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS enum definition for further information. The innovaton test ratios show the magnitude of the sensor innovation divided by the innovation check threshold. Under normal operation the innovaton test ratios should be below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should be optional and controllable by the user."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (micros since boot or Unix epoch)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VelRatio",
                Description = "Velocity innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosHorizRatio",
                Description = "Horizontal position innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosVertRatio",
                Description = "Vertical position innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MagRatio",
                Description = "Magnetometer innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "HaglRatio",
                Description = "Height above terrain innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TasRatio",
                Description = "True airspeed innovation test ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosHorizAccuracy",
                Description = "Horizontal position 1-STD accuracy relative to the EKF local origin (m)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosVertAccuracy",
                Description = "Vertical position 1-STD accuracy relative to the EKF local origin (m)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "Integer bitmask indicating which EKF outputs are valid. See definition for ESTIMATOR_STATUS_FLAGS.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("EstimatorStatusFlags"),
            });

        }

        private UInt64 mTimeUsec;
        private float mVelRatio;
        private float mPosHorizRatio;
        private float mPosVertRatio;
        private float mMagRatio;
        private float mHaglRatio;
        private float mTasRatio;
        private float mPosHorizAccuracy;
        private float mPosVertAccuracy;
        private EstimatorStatusFlags mFlags;
    }


    // ___________________________________________________________________________________


    public class UasWindCov: UasMessage
    {
        /// <summary>
        /// Timestamp (micros since boot or Unix epoch)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Wind in X (NED) direction in m/s
        /// </summary>
        public float WindX {
            get { return mWindX; }
            set { mWindX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Wind in Y (NED) direction in m/s
        /// </summary>
        public float WindY {
            get { return mWindY; }
            set { mWindY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Wind in Z (NED) direction in m/s
        /// </summary>
        public float WindZ {
            get { return mWindZ; }
            set { mWindZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate.
        /// </summary>
        public float VarHoriz {
            get { return mVarHoriz; }
            set { mVarHoriz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate.
        /// </summary>
        public float VarVert {
            get { return mVarVert; }
            set { mVarVert = value; NotifyUpdated(); }
        }

        /// <summary>
        /// AMSL altitude (m) this measurement was taken at
        /// </summary>
        public float WindAlt {
            get { return mWindAlt; }
            set { mWindAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Horizontal speed 1-STD accuracy
        /// </summary>
        public float HorizAccuracy {
            get { return mHorizAccuracy; }
            set { mHorizAccuracy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vertical speed 1-STD accuracy
        /// </summary>
        public float VertAccuracy {
            get { return mVertAccuracy; }
            set { mVertAccuracy = value; NotifyUpdated(); }
        }

        public UasWindCov()
        {
            mMessageId = 231;
            CrcExtra = 105;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mWindX);
            s.Write(mWindY);
            s.Write(mWindZ);
            s.Write(mVarHoriz);
            s.Write(mVarVert);
            s.Write(mWindAlt);
            s.Write(mHorizAccuracy);
            s.Write(mVertAccuracy);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mWindX = s.ReadSingle();
            this.mWindY = s.ReadSingle();
            this.mWindZ = s.ReadSingle();
            this.mVarHoriz = s.ReadSingle();
            this.mVarVert = s.ReadSingle();
            this.mWindAlt = s.ReadSingle();
            this.mHorizAccuracy = s.ReadSingle();
            this.mVertAccuracy = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = ""
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (micros since boot or Unix epoch)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WindX",
                Description = "Wind in X (NED) direction in m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WindY",
                Description = "Wind in Y (NED) direction in m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WindZ",
                Description = "Wind in Z (NED) direction in m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VarHoriz",
                Description = "Variability of the wind in XY. RMS of a 1 Hz lowpassed wind estimate.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VarVert",
                Description = "Variability of the wind in Z. RMS of a 1 Hz lowpassed wind estimate.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "WindAlt",
                Description = "AMSL altitude (m) this measurement was taken at",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "HorizAccuracy",
                Description = "Horizontal speed 1-STD accuracy",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VertAccuracy",
                Description = "Vertical speed 1-STD accuracy",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mWindX;
        private float mWindY;
        private float mWindZ;
        private float mVarHoriz;
        private float mVarVert;
        private float mWindAlt;
        private float mHorizAccuracy;
        private float mVertAccuracy;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// WORK IN PROGRESS! RTCM message for injecting into the onboard GPS (used for DGPS)
    /// </summary>
    public class UasGpsRtcmData: UasMessage
    {
        /// <summary>
        /// LSB: 1 means message is fragmented
        /// </summary>
        public byte Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        /// <summary>
        /// data length
        /// </summary>
        public byte Len {
            get { return mLen; }
            set { mLen = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RTCM message (may be fragmented)
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasGpsRtcmData()
        {
            mMessageId = 233;
            CrcExtra = 35;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mFlags);
            s.Write(mLen);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
            s.Write(mData[70]); 
            s.Write(mData[71]); 
            s.Write(mData[72]); 
            s.Write(mData[73]); 
            s.Write(mData[74]); 
            s.Write(mData[75]); 
            s.Write(mData[76]); 
            s.Write(mData[77]); 
            s.Write(mData[78]); 
            s.Write(mData[79]); 
            s.Write(mData[80]); 
            s.Write(mData[81]); 
            s.Write(mData[82]); 
            s.Write(mData[83]); 
            s.Write(mData[84]); 
            s.Write(mData[85]); 
            s.Write(mData[86]); 
            s.Write(mData[87]); 
            s.Write(mData[88]); 
            s.Write(mData[89]); 
            s.Write(mData[90]); 
            s.Write(mData[91]); 
            s.Write(mData[92]); 
            s.Write(mData[93]); 
            s.Write(mData[94]); 
            s.Write(mData[95]); 
            s.Write(mData[96]); 
            s.Write(mData[97]); 
            s.Write(mData[98]); 
            s.Write(mData[99]); 
            s.Write(mData[100]); 
            s.Write(mData[101]); 
            s.Write(mData[102]); 
            s.Write(mData[103]); 
            s.Write(mData[104]); 
            s.Write(mData[105]); 
            s.Write(mData[106]); 
            s.Write(mData[107]); 
            s.Write(mData[108]); 
            s.Write(mData[109]); 
            s.Write(mData[110]); 
            s.Write(mData[111]); 
            s.Write(mData[112]); 
            s.Write(mData[113]); 
            s.Write(mData[114]); 
            s.Write(mData[115]); 
            s.Write(mData[116]); 
            s.Write(mData[117]); 
            s.Write(mData[118]); 
            s.Write(mData[119]); 
            s.Write(mData[120]); 
            s.Write(mData[121]); 
            s.Write(mData[122]); 
            s.Write(mData[123]); 
            s.Write(mData[124]); 
            s.Write(mData[125]); 
            s.Write(mData[126]); 
            s.Write(mData[127]); 
            s.Write(mData[128]); 
            s.Write(mData[129]); 
            s.Write(mData[130]); 
            s.Write(mData[131]); 
            s.Write(mData[132]); 
            s.Write(mData[133]); 
            s.Write(mData[134]); 
            s.Write(mData[135]); 
            s.Write(mData[136]); 
            s.Write(mData[137]); 
            s.Write(mData[138]); 
            s.Write(mData[139]); 
            s.Write(mData[140]); 
            s.Write(mData[141]); 
            s.Write(mData[142]); 
            s.Write(mData[143]); 
            s.Write(mData[144]); 
            s.Write(mData[145]); 
            s.Write(mData[146]); 
            s.Write(mData[147]); 
            s.Write(mData[148]); 
            s.Write(mData[149]); 
            s.Write(mData[150]); 
            s.Write(mData[151]); 
            s.Write(mData[152]); 
            s.Write(mData[153]); 
            s.Write(mData[154]); 
            s.Write(mData[155]); 
            s.Write(mData[156]); 
            s.Write(mData[157]); 
            s.Write(mData[158]); 
            s.Write(mData[159]); 
            s.Write(mData[160]); 
            s.Write(mData[161]); 
            s.Write(mData[162]); 
            s.Write(mData[163]); 
            s.Write(mData[164]); 
            s.Write(mData[165]); 
            s.Write(mData[166]); 
            s.Write(mData[167]); 
            s.Write(mData[168]); 
            s.Write(mData[169]); 
            s.Write(mData[170]); 
            s.Write(mData[171]); 
            s.Write(mData[172]); 
            s.Write(mData[173]); 
            s.Write(mData[174]); 
            s.Write(mData[175]); 
            s.Write(mData[176]); 
            s.Write(mData[177]); 
            s.Write(mData[178]); 
            s.Write(mData[179]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mFlags = s.ReadByte();
            this.mLen = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
            this.mData[70] = s.ReadByte();
            this.mData[71] = s.ReadByte();
            this.mData[72] = s.ReadByte();
            this.mData[73] = s.ReadByte();
            this.mData[74] = s.ReadByte();
            this.mData[75] = s.ReadByte();
            this.mData[76] = s.ReadByte();
            this.mData[77] = s.ReadByte();
            this.mData[78] = s.ReadByte();
            this.mData[79] = s.ReadByte();
            this.mData[80] = s.ReadByte();
            this.mData[81] = s.ReadByte();
            this.mData[82] = s.ReadByte();
            this.mData[83] = s.ReadByte();
            this.mData[84] = s.ReadByte();
            this.mData[85] = s.ReadByte();
            this.mData[86] = s.ReadByte();
            this.mData[87] = s.ReadByte();
            this.mData[88] = s.ReadByte();
            this.mData[89] = s.ReadByte();
            this.mData[90] = s.ReadByte();
            this.mData[91] = s.ReadByte();
            this.mData[92] = s.ReadByte();
            this.mData[93] = s.ReadByte();
            this.mData[94] = s.ReadByte();
            this.mData[95] = s.ReadByte();
            this.mData[96] = s.ReadByte();
            this.mData[97] = s.ReadByte();
            this.mData[98] = s.ReadByte();
            this.mData[99] = s.ReadByte();
            this.mData[100] = s.ReadByte();
            this.mData[101] = s.ReadByte();
            this.mData[102] = s.ReadByte();
            this.mData[103] = s.ReadByte();
            this.mData[104] = s.ReadByte();
            this.mData[105] = s.ReadByte();
            this.mData[106] = s.ReadByte();
            this.mData[107] = s.ReadByte();
            this.mData[108] = s.ReadByte();
            this.mData[109] = s.ReadByte();
            this.mData[110] = s.ReadByte();
            this.mData[111] = s.ReadByte();
            this.mData[112] = s.ReadByte();
            this.mData[113] = s.ReadByte();
            this.mData[114] = s.ReadByte();
            this.mData[115] = s.ReadByte();
            this.mData[116] = s.ReadByte();
            this.mData[117] = s.ReadByte();
            this.mData[118] = s.ReadByte();
            this.mData[119] = s.ReadByte();
            this.mData[120] = s.ReadByte();
            this.mData[121] = s.ReadByte();
            this.mData[122] = s.ReadByte();
            this.mData[123] = s.ReadByte();
            this.mData[124] = s.ReadByte();
            this.mData[125] = s.ReadByte();
            this.mData[126] = s.ReadByte();
            this.mData[127] = s.ReadByte();
            this.mData[128] = s.ReadByte();
            this.mData[129] = s.ReadByte();
            this.mData[130] = s.ReadByte();
            this.mData[131] = s.ReadByte();
            this.mData[132] = s.ReadByte();
            this.mData[133] = s.ReadByte();
            this.mData[134] = s.ReadByte();
            this.mData[135] = s.ReadByte();
            this.mData[136] = s.ReadByte();
            this.mData[137] = s.ReadByte();
            this.mData[138] = s.ReadByte();
            this.mData[139] = s.ReadByte();
            this.mData[140] = s.ReadByte();
            this.mData[141] = s.ReadByte();
            this.mData[142] = s.ReadByte();
            this.mData[143] = s.ReadByte();
            this.mData[144] = s.ReadByte();
            this.mData[145] = s.ReadByte();
            this.mData[146] = s.ReadByte();
            this.mData[147] = s.ReadByte();
            this.mData[148] = s.ReadByte();
            this.mData[149] = s.ReadByte();
            this.mData[150] = s.ReadByte();
            this.mData[151] = s.ReadByte();
            this.mData[152] = s.ReadByte();
            this.mData[153] = s.ReadByte();
            this.mData[154] = s.ReadByte();
            this.mData[155] = s.ReadByte();
            this.mData[156] = s.ReadByte();
            this.mData[157] = s.ReadByte();
            this.mData[158] = s.ReadByte();
            this.mData[159] = s.ReadByte();
            this.mData[160] = s.ReadByte();
            this.mData[161] = s.ReadByte();
            this.mData[162] = s.ReadByte();
            this.mData[163] = s.ReadByte();
            this.mData[164] = s.ReadByte();
            this.mData[165] = s.ReadByte();
            this.mData[166] = s.ReadByte();
            this.mData[167] = s.ReadByte();
            this.mData[168] = s.ReadByte();
            this.mData[169] = s.ReadByte();
            this.mData[170] = s.ReadByte();
            this.mData[171] = s.ReadByte();
            this.mData[172] = s.ReadByte();
            this.mData[173] = s.ReadByte();
            this.mData[174] = s.ReadByte();
            this.mData[175] = s.ReadByte();
            this.mData[176] = s.ReadByte();
            this.mData[177] = s.ReadByte();
            this.mData[178] = s.ReadByte();
            this.mData[179] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "WORK IN PROGRESS! RTCM message for injecting into the onboard GPS (used for DGPS)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "LSB: 1 means message is fragmented",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Len",
                Description = "data length",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "RTCM message (may be fragmented)",
                NumElements = 180,
            });

        }

        private byte mFlags;
        private byte mLen;
        private byte[] mData = new byte[180];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Vibration levels and accelerometer clipping
    /// </summary>
    public class UasVibration: UasMessage
    {
        /// <summary>
        /// Timestamp (micros since boot or Unix epoch)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vibration levels on X-axis
        /// </summary>
        public float VibrationX {
            get { return mVibrationX; }
            set { mVibrationX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vibration levels on Y-axis
        /// </summary>
        public float VibrationY {
            get { return mVibrationY; }
            set { mVibrationY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vibration levels on Z-axis
        /// </summary>
        public float VibrationZ {
            get { return mVibrationZ; }
            set { mVibrationZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// first accelerometer clipping count
        /// </summary>
        public UInt32 Clipping0 {
            get { return mClipping0; }
            set { mClipping0 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// second accelerometer clipping count
        /// </summary>
        public UInt32 Clipping1 {
            get { return mClipping1; }
            set { mClipping1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// third accelerometer clipping count
        /// </summary>
        public UInt32 Clipping2 {
            get { return mClipping2; }
            set { mClipping2 = value; NotifyUpdated(); }
        }

        public UasVibration()
        {
            mMessageId = 241;
            CrcExtra = 90;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mVibrationX);
            s.Write(mVibrationY);
            s.Write(mVibrationZ);
            s.Write(mClipping0);
            s.Write(mClipping1);
            s.Write(mClipping2);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mVibrationX = s.ReadSingle();
            this.mVibrationY = s.ReadSingle();
            this.mVibrationZ = s.ReadSingle();
            this.mClipping0 = s.ReadUInt32();
            this.mClipping1 = s.ReadUInt32();
            this.mClipping2 = s.ReadUInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Vibration levels and accelerometer clipping"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp (micros since boot or Unix epoch)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VibrationX",
                Description = "Vibration levels on X-axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VibrationY",
                Description = "Vibration levels on Y-axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VibrationZ",
                Description = "Vibration levels on Z-axis",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Clipping0",
                Description = "first accelerometer clipping count",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Clipping1",
                Description = "second accelerometer clipping count",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Clipping2",
                Description = "third accelerometer clipping count",
                NumElements = 1,
            });

        }

        private UInt64 mTimeUsec;
        private float mVibrationX;
        private float mVibrationY;
        private float mVibrationZ;
        private UInt32 mClipping0;
        private UInt32 mClipping1;
        private UInt32 mClipping2;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitely set by the operator before or after. The position the system will return to and land on. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
    /// </summary>
    public class UasHomePosition: UasMessage
    {
        /// <summary>
        /// Latitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Latitude {
            get { return mLatitude; }
            set { mLatitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84, in degrees * 1E7
        /// </summary>
        public Int32 Longitude {
            get { return mLongitude; }
            set { mLongitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (AMSL), in meters * 1000 (positive for up)
        /// </summary>
        public Int32 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local X position of this position in the local coordinate frame
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Y position of this position in the local coordinate frame
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Z position of this position in the local coordinate frame
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachX {
            get { return mApproachX; }
            set { mApproachX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachY {
            get { return mApproachY; }
            set { mApproachY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachZ {
            get { return mApproachZ; }
            set { mApproachZ = value; NotifyUpdated(); }
        }

        public UasHomePosition()
        {
            mMessageId = 242;
            CrcExtra = 104;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mLatitude);
            s.Write(mLongitude);
            s.Write(mAltitude);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mApproachX);
            s.Write(mApproachY);
            s.Write(mApproachZ);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mLatitude = s.ReadInt32();
            this.mLongitude = s.ReadInt32();
            this.mAltitude = s.ReadInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mApproachX = s.ReadSingle();
            this.mApproachY = s.ReadSingle();
            this.mApproachZ = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitely set by the operator before or after. The position the system will return to and land on. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Latitude",
                Description = "Latitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Longitude",
                Description = "Longitude (WGS84, in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude (AMSL), in meters * 1000 (positive for up)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Local X position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Local Y position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Local Z position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachX",
                Description = "Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachY",
                Description = "Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachZ",
                Description = "Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

        }

        private Int32 mLatitude;
        private Int32 mLongitude;
        private Int32 mAltitude;
        private float mX;
        private float mY;
        private float mZ;
        private float[] mQ = new float[4];
        private float mApproachX;
        private float mApproachY;
        private float mApproachZ;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitely set by the operator before or after. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
    /// </summary>
    public class UasSetHomePosition: UasMessage
    {
        /// <summary>
        /// Latitude (WGS84), in degrees * 1E7
        /// </summary>
        public Int32 Latitude {
            get { return mLatitude; }
            set { mLatitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude (WGS84, in degrees * 1E7
        /// </summary>
        public Int32 Longitude {
            get { return mLongitude; }
            set { mLongitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (AMSL), in meters * 1000 (positive for up)
        /// </summary>
        public Int32 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local X position of this position in the local coordinate frame
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Y position of this position in the local coordinate frame
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Z position of this position in the local coordinate frame
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground
        /// </summary>
        public float[] Q {
            get { return mQ; }
            set { mQ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachX {
            get { return mApproachX; }
            set { mApproachX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachY {
            get { return mApproachY; }
            set { mApproachY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
        /// </summary>
        public float ApproachZ {
            get { return mApproachZ; }
            set { mApproachZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID.
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        public UasSetHomePosition()
        {
            mMessageId = 243;
            CrcExtra = 85;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mLatitude);
            s.Write(mLongitude);
            s.Write(mAltitude);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mQ[0]); 
            s.Write(mQ[1]); 
            s.Write(mQ[2]); 
            s.Write(mQ[3]); 
            s.Write(mApproachX);
            s.Write(mApproachY);
            s.Write(mApproachZ);
            s.Write(mTargetSystem);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mLatitude = s.ReadInt32();
            this.mLongitude = s.ReadInt32();
            this.mAltitude = s.ReadInt32();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mQ[0] = s.ReadSingle();
            this.mQ[1] = s.ReadSingle();
            this.mQ[2] = s.ReadSingle();
            this.mQ[3] = s.ReadSingle();
            this.mApproachX = s.ReadSingle();
            this.mApproachY = s.ReadSingle();
            this.mApproachZ = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The position the system will return to and land on. The position is set automatically by the system during the takeoff in case it was not explicitely set by the operator before or after. The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Latitude",
                Description = "Latitude (WGS84), in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Longitude",
                Description = "Longitude (WGS84, in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude (AMSL), in meters * 1000 (positive for up)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "Local X position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "Local Y position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "Local Z position of this position in the local coordinate frame",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Q",
                Description = "World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground",
                NumElements = 4,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachX",
                Description = "Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachY",
                Description = "Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ApproachZ",
                Description = "Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID.",
                NumElements = 1,
            });

        }

        private Int32 mLatitude;
        private Int32 mLongitude;
        private Int32 mAltitude;
        private float mX;
        private float mY;
        private float mZ;
        private float[] mQ = new float[4];
        private float mApproachX;
        private float mApproachY;
        private float mApproachZ;
        private byte mTargetSystem;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// This interface replaces DATA_STREAM
    /// </summary>
    public class UasMessageInterval: UasMessage
    {
        /// <summary>
        /// The interval between two messages, in microseconds. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.
        /// </summary>
        public Int32 IntervalUs {
            get { return mIntervalUs; }
            set { mIntervalUs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The ID of the requested MAVLink message. v1.0 is limited to 254 messages.
        /// </summary>
        public UInt16 MessageId {
            get { return mMessageId; }
            set { mMessageId = value; NotifyUpdated(); }
        }

        public UasMessageInterval()
        {
            mMessageId = 244;
            CrcExtra = 95;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mIntervalUs);
            s.Write(mMessageId);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mIntervalUs = s.ReadInt32();
            this.mMessageId = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "This interface replaces DATA_STREAM"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IntervalUs",
                Description = "The interval between two messages, in microseconds. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MessageId",
                Description = "The ID of the requested MAVLink message. v1.0 is limited to 254 messages.",
                NumElements = 1,
            });

        }

        private Int32 mIntervalUs;
        private UInt16 mMessageId;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Provides state for additional features
    /// </summary>
    public class UasExtendedSysState: UasMessage
    {
        /// <summary>
        /// The VTOL state if applicable. Is set to MAV_VTOL_STATE_UNDEFINED if UAV is not in VTOL configuration.
        /// </summary>
        public MavVtolState VtolState {
            get { return mVtolState; }
            set { mVtolState = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.
        /// </summary>
        public MavLandedState LandedState {
            get { return mLandedState; }
            set { mLandedState = value; NotifyUpdated(); }
        }

        public UasExtendedSysState()
        {
            mMessageId = 245;
            CrcExtra = 130;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write((byte)mVtolState);
            s.Write((byte)mLandedState);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mVtolState = (MavVtolState)s.ReadByte();
            this.mLandedState = (MavLandedState)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Provides state for additional features"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VtolState",
                Description = "The VTOL state if applicable. Is set to MAV_VTOL_STATE_UNDEFINED if UAV is not in VTOL configuration.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavVtolState"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LandedState",
                Description = "The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavLandedState"),
            });

        }

        private MavVtolState mVtolState;
        private MavLandedState mLandedState;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// The location and information of an ADSB vehicle
    /// </summary>
    public class UasAdsbVehicle: UasMessage
    {
        /// <summary>
        /// ICAO address
        /// </summary>
        public UInt32 IcaoAddress {
            get { return mIcaoAddress; }
            set { mIcaoAddress = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude, expressed as degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude, expressed as degrees * 1E7
        /// </summary>
        public Int32 Lon {
            get { return mLon; }
            set { mLon = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude(ASL) in millimeters
        /// </summary>
        public Int32 Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Course over ground in centidegrees
        /// </summary>
        public UInt16 Heading {
            get { return mHeading; }
            set { mHeading = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The horizontal velocity in centimeters/second
        /// </summary>
        public UInt16 HorVelocity {
            get { return mHorVelocity; }
            set { mHorVelocity = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The vertical velocity in centimeters/second, positive is up
        /// </summary>
        public Int16 VerVelocity {
            get { return mVerVelocity; }
            set { mVerVelocity = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flags to indicate various statuses including valid data fields
        /// </summary>
        public UInt16 Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Squawk code
        /// </summary>
        public UInt16 Squawk {
            get { return mSquawk; }
            set { mSquawk = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type from ADSB_ALTITUDE_TYPE enum
        /// </summary>
        public AdsbAltitudeType AltitudeType {
            get { return mAltitudeType; }
            set { mAltitudeType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// The callsign, 8+null
        /// </summary>
        public char[] Callsign {
            get { return mCallsign; }
            set { mCallsign = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type from ADSB_EMITTER_TYPE enum
        /// </summary>
        public AdsbEmitterType EmitterType {
            get { return mEmitterType; }
            set { mEmitterType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Time since last communication in seconds
        /// </summary>
        public byte Tslc {
            get { return mTslc; }
            set { mTslc = value; NotifyUpdated(); }
        }

        public UasAdsbVehicle()
        {
            mMessageId = 246;
            CrcExtra = 184;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mIcaoAddress);
            s.Write(mLat);
            s.Write(mLon);
            s.Write(mAltitude);
            s.Write(mHeading);
            s.Write(mHorVelocity);
            s.Write(mVerVelocity);
            s.Write(mFlags);
            s.Write(mSquawk);
            s.Write((byte)mAltitudeType);
            s.Write(mCallsign[0]); 
            s.Write(mCallsign[1]); 
            s.Write(mCallsign[2]); 
            s.Write(mCallsign[3]); 
            s.Write(mCallsign[4]); 
            s.Write(mCallsign[5]); 
            s.Write(mCallsign[6]); 
            s.Write(mCallsign[7]); 
            s.Write(mCallsign[8]); 
            s.Write((byte)mEmitterType);
            s.Write(mTslc);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mIcaoAddress = s.ReadUInt32();
            this.mLat = s.ReadInt32();
            this.mLon = s.ReadInt32();
            this.mAltitude = s.ReadInt32();
            this.mHeading = s.ReadUInt16();
            this.mHorVelocity = s.ReadUInt16();
            this.mVerVelocity = s.ReadInt16();
            this.mFlags = s.ReadUInt16();
            this.mSquawk = s.ReadUInt16();
            this.mAltitudeType = (AdsbAltitudeType)s.ReadByte();
            this.mCallsign[0] = s.ReadChar();
            this.mCallsign[1] = s.ReadChar();
            this.mCallsign[2] = s.ReadChar();
            this.mCallsign[3] = s.ReadChar();
            this.mCallsign[4] = s.ReadChar();
            this.mCallsign[5] = s.ReadChar();
            this.mCallsign[6] = s.ReadChar();
            this.mCallsign[7] = s.ReadChar();
            this.mCallsign[8] = s.ReadChar();
            this.mEmitterType = (AdsbEmitterType)s.ReadByte();
            this.mTslc = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "The location and information of an ADSB vehicle"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "IcaoAddress",
                Description = "ICAO address",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude, expressed as degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lon",
                Description = "Longitude, expressed as degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude(ASL) in millimeters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Heading",
                Description = "Course over ground in centidegrees",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "HorVelocity",
                Description = "The horizontal velocity in centimeters/second",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VerVelocity",
                Description = "The vertical velocity in centimeters/second, positive is up",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "Flags to indicate various statuses including valid data fields",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Squawk",
                Description = "Squawk code",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltitudeType",
                Description = "Type from ADSB_ALTITUDE_TYPE enum",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("AdsbAltitudeType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Callsign",
                Description = "The callsign, 8+null",
                NumElements = 9,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EmitterType",
                Description = "Type from ADSB_EMITTER_TYPE enum",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("AdsbEmitterType"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Tslc",
                Description = "Time since last communication in seconds",
                NumElements = 1,
            });

        }

        private UInt32 mIcaoAddress;
        private Int32 mLat;
        private Int32 mLon;
        private Int32 mAltitude;
        private UInt16 mHeading;
        private UInt16 mHorVelocity;
        private Int16 mVerVelocity;
        private UInt16 mFlags;
        private UInt16 mSquawk;
        private AdsbAltitudeType mAltitudeType;
        private char[] mCallsign = new char[9];
        private AdsbEmitterType mEmitterType;
        private byte mTslc;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message implementing parts of the V2 payload specs in V1 frames for transitional support.
    /// </summary>
    public class UasV2Extension: UasMessage
    {
        /// <summary>
        /// A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
        /// </summary>
        public UInt16 MessageType {
            get { return mMessageType; }
            set { mMessageType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Network ID (0 for broadcast)
        /// </summary>
        public byte TargetNetwork {
            get { return mTargetNetwork; }
            set { mTargetNetwork = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID (0 for broadcast)
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID (0 for broadcast)
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.
        /// </summary>
        public byte[] Payload {
            get { return mPayload; }
            set { mPayload = value; NotifyUpdated(); }
        }

        public UasV2Extension()
        {
            mMessageId = 248;
            CrcExtra = 8;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mMessageType);
            s.Write(mTargetNetwork);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mPayload[0]); 
            s.Write(mPayload[1]); 
            s.Write(mPayload[2]); 
            s.Write(mPayload[3]); 
            s.Write(mPayload[4]); 
            s.Write(mPayload[5]); 
            s.Write(mPayload[6]); 
            s.Write(mPayload[7]); 
            s.Write(mPayload[8]); 
            s.Write(mPayload[9]); 
            s.Write(mPayload[10]); 
            s.Write(mPayload[11]); 
            s.Write(mPayload[12]); 
            s.Write(mPayload[13]); 
            s.Write(mPayload[14]); 
            s.Write(mPayload[15]); 
            s.Write(mPayload[16]); 
            s.Write(mPayload[17]); 
            s.Write(mPayload[18]); 
            s.Write(mPayload[19]); 
            s.Write(mPayload[20]); 
            s.Write(mPayload[21]); 
            s.Write(mPayload[22]); 
            s.Write(mPayload[23]); 
            s.Write(mPayload[24]); 
            s.Write(mPayload[25]); 
            s.Write(mPayload[26]); 
            s.Write(mPayload[27]); 
            s.Write(mPayload[28]); 
            s.Write(mPayload[29]); 
            s.Write(mPayload[30]); 
            s.Write(mPayload[31]); 
            s.Write(mPayload[32]); 
            s.Write(mPayload[33]); 
            s.Write(mPayload[34]); 
            s.Write(mPayload[35]); 
            s.Write(mPayload[36]); 
            s.Write(mPayload[37]); 
            s.Write(mPayload[38]); 
            s.Write(mPayload[39]); 
            s.Write(mPayload[40]); 
            s.Write(mPayload[41]); 
            s.Write(mPayload[42]); 
            s.Write(mPayload[43]); 
            s.Write(mPayload[44]); 
            s.Write(mPayload[45]); 
            s.Write(mPayload[46]); 
            s.Write(mPayload[47]); 
            s.Write(mPayload[48]); 
            s.Write(mPayload[49]); 
            s.Write(mPayload[50]); 
            s.Write(mPayload[51]); 
            s.Write(mPayload[52]); 
            s.Write(mPayload[53]); 
            s.Write(mPayload[54]); 
            s.Write(mPayload[55]); 
            s.Write(mPayload[56]); 
            s.Write(mPayload[57]); 
            s.Write(mPayload[58]); 
            s.Write(mPayload[59]); 
            s.Write(mPayload[60]); 
            s.Write(mPayload[61]); 
            s.Write(mPayload[62]); 
            s.Write(mPayload[63]); 
            s.Write(mPayload[64]); 
            s.Write(mPayload[65]); 
            s.Write(mPayload[66]); 
            s.Write(mPayload[67]); 
            s.Write(mPayload[68]); 
            s.Write(mPayload[69]); 
            s.Write(mPayload[70]); 
            s.Write(mPayload[71]); 
            s.Write(mPayload[72]); 
            s.Write(mPayload[73]); 
            s.Write(mPayload[74]); 
            s.Write(mPayload[75]); 
            s.Write(mPayload[76]); 
            s.Write(mPayload[77]); 
            s.Write(mPayload[78]); 
            s.Write(mPayload[79]); 
            s.Write(mPayload[80]); 
            s.Write(mPayload[81]); 
            s.Write(mPayload[82]); 
            s.Write(mPayload[83]); 
            s.Write(mPayload[84]); 
            s.Write(mPayload[85]); 
            s.Write(mPayload[86]); 
            s.Write(mPayload[87]); 
            s.Write(mPayload[88]); 
            s.Write(mPayload[89]); 
            s.Write(mPayload[90]); 
            s.Write(mPayload[91]); 
            s.Write(mPayload[92]); 
            s.Write(mPayload[93]); 
            s.Write(mPayload[94]); 
            s.Write(mPayload[95]); 
            s.Write(mPayload[96]); 
            s.Write(mPayload[97]); 
            s.Write(mPayload[98]); 
            s.Write(mPayload[99]); 
            s.Write(mPayload[100]); 
            s.Write(mPayload[101]); 
            s.Write(mPayload[102]); 
            s.Write(mPayload[103]); 
            s.Write(mPayload[104]); 
            s.Write(mPayload[105]); 
            s.Write(mPayload[106]); 
            s.Write(mPayload[107]); 
            s.Write(mPayload[108]); 
            s.Write(mPayload[109]); 
            s.Write(mPayload[110]); 
            s.Write(mPayload[111]); 
            s.Write(mPayload[112]); 
            s.Write(mPayload[113]); 
            s.Write(mPayload[114]); 
            s.Write(mPayload[115]); 
            s.Write(mPayload[116]); 
            s.Write(mPayload[117]); 
            s.Write(mPayload[118]); 
            s.Write(mPayload[119]); 
            s.Write(mPayload[120]); 
            s.Write(mPayload[121]); 
            s.Write(mPayload[122]); 
            s.Write(mPayload[123]); 
            s.Write(mPayload[124]); 
            s.Write(mPayload[125]); 
            s.Write(mPayload[126]); 
            s.Write(mPayload[127]); 
            s.Write(mPayload[128]); 
            s.Write(mPayload[129]); 
            s.Write(mPayload[130]); 
            s.Write(mPayload[131]); 
            s.Write(mPayload[132]); 
            s.Write(mPayload[133]); 
            s.Write(mPayload[134]); 
            s.Write(mPayload[135]); 
            s.Write(mPayload[136]); 
            s.Write(mPayload[137]); 
            s.Write(mPayload[138]); 
            s.Write(mPayload[139]); 
            s.Write(mPayload[140]); 
            s.Write(mPayload[141]); 
            s.Write(mPayload[142]); 
            s.Write(mPayload[143]); 
            s.Write(mPayload[144]); 
            s.Write(mPayload[145]); 
            s.Write(mPayload[146]); 
            s.Write(mPayload[147]); 
            s.Write(mPayload[148]); 
            s.Write(mPayload[149]); 
            s.Write(mPayload[150]); 
            s.Write(mPayload[151]); 
            s.Write(mPayload[152]); 
            s.Write(mPayload[153]); 
            s.Write(mPayload[154]); 
            s.Write(mPayload[155]); 
            s.Write(mPayload[156]); 
            s.Write(mPayload[157]); 
            s.Write(mPayload[158]); 
            s.Write(mPayload[159]); 
            s.Write(mPayload[160]); 
            s.Write(mPayload[161]); 
            s.Write(mPayload[162]); 
            s.Write(mPayload[163]); 
            s.Write(mPayload[164]); 
            s.Write(mPayload[165]); 
            s.Write(mPayload[166]); 
            s.Write(mPayload[167]); 
            s.Write(mPayload[168]); 
            s.Write(mPayload[169]); 
            s.Write(mPayload[170]); 
            s.Write(mPayload[171]); 
            s.Write(mPayload[172]); 
            s.Write(mPayload[173]); 
            s.Write(mPayload[174]); 
            s.Write(mPayload[175]); 
            s.Write(mPayload[176]); 
            s.Write(mPayload[177]); 
            s.Write(mPayload[178]); 
            s.Write(mPayload[179]); 
            s.Write(mPayload[180]); 
            s.Write(mPayload[181]); 
            s.Write(mPayload[182]); 
            s.Write(mPayload[183]); 
            s.Write(mPayload[184]); 
            s.Write(mPayload[185]); 
            s.Write(mPayload[186]); 
            s.Write(mPayload[187]); 
            s.Write(mPayload[188]); 
            s.Write(mPayload[189]); 
            s.Write(mPayload[190]); 
            s.Write(mPayload[191]); 
            s.Write(mPayload[192]); 
            s.Write(mPayload[193]); 
            s.Write(mPayload[194]); 
            s.Write(mPayload[195]); 
            s.Write(mPayload[196]); 
            s.Write(mPayload[197]); 
            s.Write(mPayload[198]); 
            s.Write(mPayload[199]); 
            s.Write(mPayload[200]); 
            s.Write(mPayload[201]); 
            s.Write(mPayload[202]); 
            s.Write(mPayload[203]); 
            s.Write(mPayload[204]); 
            s.Write(mPayload[205]); 
            s.Write(mPayload[206]); 
            s.Write(mPayload[207]); 
            s.Write(mPayload[208]); 
            s.Write(mPayload[209]); 
            s.Write(mPayload[210]); 
            s.Write(mPayload[211]); 
            s.Write(mPayload[212]); 
            s.Write(mPayload[213]); 
            s.Write(mPayload[214]); 
            s.Write(mPayload[215]); 
            s.Write(mPayload[216]); 
            s.Write(mPayload[217]); 
            s.Write(mPayload[218]); 
            s.Write(mPayload[219]); 
            s.Write(mPayload[220]); 
            s.Write(mPayload[221]); 
            s.Write(mPayload[222]); 
            s.Write(mPayload[223]); 
            s.Write(mPayload[224]); 
            s.Write(mPayload[225]); 
            s.Write(mPayload[226]); 
            s.Write(mPayload[227]); 
            s.Write(mPayload[228]); 
            s.Write(mPayload[229]); 
            s.Write(mPayload[230]); 
            s.Write(mPayload[231]); 
            s.Write(mPayload[232]); 
            s.Write(mPayload[233]); 
            s.Write(mPayload[234]); 
            s.Write(mPayload[235]); 
            s.Write(mPayload[236]); 
            s.Write(mPayload[237]); 
            s.Write(mPayload[238]); 
            s.Write(mPayload[239]); 
            s.Write(mPayload[240]); 
            s.Write(mPayload[241]); 
            s.Write(mPayload[242]); 
            s.Write(mPayload[243]); 
            s.Write(mPayload[244]); 
            s.Write(mPayload[245]); 
            s.Write(mPayload[246]); 
            s.Write(mPayload[247]); 
            s.Write(mPayload[248]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mMessageType = s.ReadUInt16();
            this.mTargetNetwork = s.ReadByte();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mPayload[0] = s.ReadByte();
            this.mPayload[1] = s.ReadByte();
            this.mPayload[2] = s.ReadByte();
            this.mPayload[3] = s.ReadByte();
            this.mPayload[4] = s.ReadByte();
            this.mPayload[5] = s.ReadByte();
            this.mPayload[6] = s.ReadByte();
            this.mPayload[7] = s.ReadByte();
            this.mPayload[8] = s.ReadByte();
            this.mPayload[9] = s.ReadByte();
            this.mPayload[10] = s.ReadByte();
            this.mPayload[11] = s.ReadByte();
            this.mPayload[12] = s.ReadByte();
            this.mPayload[13] = s.ReadByte();
            this.mPayload[14] = s.ReadByte();
            this.mPayload[15] = s.ReadByte();
            this.mPayload[16] = s.ReadByte();
            this.mPayload[17] = s.ReadByte();
            this.mPayload[18] = s.ReadByte();
            this.mPayload[19] = s.ReadByte();
            this.mPayload[20] = s.ReadByte();
            this.mPayload[21] = s.ReadByte();
            this.mPayload[22] = s.ReadByte();
            this.mPayload[23] = s.ReadByte();
            this.mPayload[24] = s.ReadByte();
            this.mPayload[25] = s.ReadByte();
            this.mPayload[26] = s.ReadByte();
            this.mPayload[27] = s.ReadByte();
            this.mPayload[28] = s.ReadByte();
            this.mPayload[29] = s.ReadByte();
            this.mPayload[30] = s.ReadByte();
            this.mPayload[31] = s.ReadByte();
            this.mPayload[32] = s.ReadByte();
            this.mPayload[33] = s.ReadByte();
            this.mPayload[34] = s.ReadByte();
            this.mPayload[35] = s.ReadByte();
            this.mPayload[36] = s.ReadByte();
            this.mPayload[37] = s.ReadByte();
            this.mPayload[38] = s.ReadByte();
            this.mPayload[39] = s.ReadByte();
            this.mPayload[40] = s.ReadByte();
            this.mPayload[41] = s.ReadByte();
            this.mPayload[42] = s.ReadByte();
            this.mPayload[43] = s.ReadByte();
            this.mPayload[44] = s.ReadByte();
            this.mPayload[45] = s.ReadByte();
            this.mPayload[46] = s.ReadByte();
            this.mPayload[47] = s.ReadByte();
            this.mPayload[48] = s.ReadByte();
            this.mPayload[49] = s.ReadByte();
            this.mPayload[50] = s.ReadByte();
            this.mPayload[51] = s.ReadByte();
            this.mPayload[52] = s.ReadByte();
            this.mPayload[53] = s.ReadByte();
            this.mPayload[54] = s.ReadByte();
            this.mPayload[55] = s.ReadByte();
            this.mPayload[56] = s.ReadByte();
            this.mPayload[57] = s.ReadByte();
            this.mPayload[58] = s.ReadByte();
            this.mPayload[59] = s.ReadByte();
            this.mPayload[60] = s.ReadByte();
            this.mPayload[61] = s.ReadByte();
            this.mPayload[62] = s.ReadByte();
            this.mPayload[63] = s.ReadByte();
            this.mPayload[64] = s.ReadByte();
            this.mPayload[65] = s.ReadByte();
            this.mPayload[66] = s.ReadByte();
            this.mPayload[67] = s.ReadByte();
            this.mPayload[68] = s.ReadByte();
            this.mPayload[69] = s.ReadByte();
            this.mPayload[70] = s.ReadByte();
            this.mPayload[71] = s.ReadByte();
            this.mPayload[72] = s.ReadByte();
            this.mPayload[73] = s.ReadByte();
            this.mPayload[74] = s.ReadByte();
            this.mPayload[75] = s.ReadByte();
            this.mPayload[76] = s.ReadByte();
            this.mPayload[77] = s.ReadByte();
            this.mPayload[78] = s.ReadByte();
            this.mPayload[79] = s.ReadByte();
            this.mPayload[80] = s.ReadByte();
            this.mPayload[81] = s.ReadByte();
            this.mPayload[82] = s.ReadByte();
            this.mPayload[83] = s.ReadByte();
            this.mPayload[84] = s.ReadByte();
            this.mPayload[85] = s.ReadByte();
            this.mPayload[86] = s.ReadByte();
            this.mPayload[87] = s.ReadByte();
            this.mPayload[88] = s.ReadByte();
            this.mPayload[89] = s.ReadByte();
            this.mPayload[90] = s.ReadByte();
            this.mPayload[91] = s.ReadByte();
            this.mPayload[92] = s.ReadByte();
            this.mPayload[93] = s.ReadByte();
            this.mPayload[94] = s.ReadByte();
            this.mPayload[95] = s.ReadByte();
            this.mPayload[96] = s.ReadByte();
            this.mPayload[97] = s.ReadByte();
            this.mPayload[98] = s.ReadByte();
            this.mPayload[99] = s.ReadByte();
            this.mPayload[100] = s.ReadByte();
            this.mPayload[101] = s.ReadByte();
            this.mPayload[102] = s.ReadByte();
            this.mPayload[103] = s.ReadByte();
            this.mPayload[104] = s.ReadByte();
            this.mPayload[105] = s.ReadByte();
            this.mPayload[106] = s.ReadByte();
            this.mPayload[107] = s.ReadByte();
            this.mPayload[108] = s.ReadByte();
            this.mPayload[109] = s.ReadByte();
            this.mPayload[110] = s.ReadByte();
            this.mPayload[111] = s.ReadByte();
            this.mPayload[112] = s.ReadByte();
            this.mPayload[113] = s.ReadByte();
            this.mPayload[114] = s.ReadByte();
            this.mPayload[115] = s.ReadByte();
            this.mPayload[116] = s.ReadByte();
            this.mPayload[117] = s.ReadByte();
            this.mPayload[118] = s.ReadByte();
            this.mPayload[119] = s.ReadByte();
            this.mPayload[120] = s.ReadByte();
            this.mPayload[121] = s.ReadByte();
            this.mPayload[122] = s.ReadByte();
            this.mPayload[123] = s.ReadByte();
            this.mPayload[124] = s.ReadByte();
            this.mPayload[125] = s.ReadByte();
            this.mPayload[126] = s.ReadByte();
            this.mPayload[127] = s.ReadByte();
            this.mPayload[128] = s.ReadByte();
            this.mPayload[129] = s.ReadByte();
            this.mPayload[130] = s.ReadByte();
            this.mPayload[131] = s.ReadByte();
            this.mPayload[132] = s.ReadByte();
            this.mPayload[133] = s.ReadByte();
            this.mPayload[134] = s.ReadByte();
            this.mPayload[135] = s.ReadByte();
            this.mPayload[136] = s.ReadByte();
            this.mPayload[137] = s.ReadByte();
            this.mPayload[138] = s.ReadByte();
            this.mPayload[139] = s.ReadByte();
            this.mPayload[140] = s.ReadByte();
            this.mPayload[141] = s.ReadByte();
            this.mPayload[142] = s.ReadByte();
            this.mPayload[143] = s.ReadByte();
            this.mPayload[144] = s.ReadByte();
            this.mPayload[145] = s.ReadByte();
            this.mPayload[146] = s.ReadByte();
            this.mPayload[147] = s.ReadByte();
            this.mPayload[148] = s.ReadByte();
            this.mPayload[149] = s.ReadByte();
            this.mPayload[150] = s.ReadByte();
            this.mPayload[151] = s.ReadByte();
            this.mPayload[152] = s.ReadByte();
            this.mPayload[153] = s.ReadByte();
            this.mPayload[154] = s.ReadByte();
            this.mPayload[155] = s.ReadByte();
            this.mPayload[156] = s.ReadByte();
            this.mPayload[157] = s.ReadByte();
            this.mPayload[158] = s.ReadByte();
            this.mPayload[159] = s.ReadByte();
            this.mPayload[160] = s.ReadByte();
            this.mPayload[161] = s.ReadByte();
            this.mPayload[162] = s.ReadByte();
            this.mPayload[163] = s.ReadByte();
            this.mPayload[164] = s.ReadByte();
            this.mPayload[165] = s.ReadByte();
            this.mPayload[166] = s.ReadByte();
            this.mPayload[167] = s.ReadByte();
            this.mPayload[168] = s.ReadByte();
            this.mPayload[169] = s.ReadByte();
            this.mPayload[170] = s.ReadByte();
            this.mPayload[171] = s.ReadByte();
            this.mPayload[172] = s.ReadByte();
            this.mPayload[173] = s.ReadByte();
            this.mPayload[174] = s.ReadByte();
            this.mPayload[175] = s.ReadByte();
            this.mPayload[176] = s.ReadByte();
            this.mPayload[177] = s.ReadByte();
            this.mPayload[178] = s.ReadByte();
            this.mPayload[179] = s.ReadByte();
            this.mPayload[180] = s.ReadByte();
            this.mPayload[181] = s.ReadByte();
            this.mPayload[182] = s.ReadByte();
            this.mPayload[183] = s.ReadByte();
            this.mPayload[184] = s.ReadByte();
            this.mPayload[185] = s.ReadByte();
            this.mPayload[186] = s.ReadByte();
            this.mPayload[187] = s.ReadByte();
            this.mPayload[188] = s.ReadByte();
            this.mPayload[189] = s.ReadByte();
            this.mPayload[190] = s.ReadByte();
            this.mPayload[191] = s.ReadByte();
            this.mPayload[192] = s.ReadByte();
            this.mPayload[193] = s.ReadByte();
            this.mPayload[194] = s.ReadByte();
            this.mPayload[195] = s.ReadByte();
            this.mPayload[196] = s.ReadByte();
            this.mPayload[197] = s.ReadByte();
            this.mPayload[198] = s.ReadByte();
            this.mPayload[199] = s.ReadByte();
            this.mPayload[200] = s.ReadByte();
            this.mPayload[201] = s.ReadByte();
            this.mPayload[202] = s.ReadByte();
            this.mPayload[203] = s.ReadByte();
            this.mPayload[204] = s.ReadByte();
            this.mPayload[205] = s.ReadByte();
            this.mPayload[206] = s.ReadByte();
            this.mPayload[207] = s.ReadByte();
            this.mPayload[208] = s.ReadByte();
            this.mPayload[209] = s.ReadByte();
            this.mPayload[210] = s.ReadByte();
            this.mPayload[211] = s.ReadByte();
            this.mPayload[212] = s.ReadByte();
            this.mPayload[213] = s.ReadByte();
            this.mPayload[214] = s.ReadByte();
            this.mPayload[215] = s.ReadByte();
            this.mPayload[216] = s.ReadByte();
            this.mPayload[217] = s.ReadByte();
            this.mPayload[218] = s.ReadByte();
            this.mPayload[219] = s.ReadByte();
            this.mPayload[220] = s.ReadByte();
            this.mPayload[221] = s.ReadByte();
            this.mPayload[222] = s.ReadByte();
            this.mPayload[223] = s.ReadByte();
            this.mPayload[224] = s.ReadByte();
            this.mPayload[225] = s.ReadByte();
            this.mPayload[226] = s.ReadByte();
            this.mPayload[227] = s.ReadByte();
            this.mPayload[228] = s.ReadByte();
            this.mPayload[229] = s.ReadByte();
            this.mPayload[230] = s.ReadByte();
            this.mPayload[231] = s.ReadByte();
            this.mPayload[232] = s.ReadByte();
            this.mPayload[233] = s.ReadByte();
            this.mPayload[234] = s.ReadByte();
            this.mPayload[235] = s.ReadByte();
            this.mPayload[236] = s.ReadByte();
            this.mPayload[237] = s.ReadByte();
            this.mPayload[238] = s.ReadByte();
            this.mPayload[239] = s.ReadByte();
            this.mPayload[240] = s.ReadByte();
            this.mPayload[241] = s.ReadByte();
            this.mPayload[242] = s.ReadByte();
            this.mPayload[243] = s.ReadByte();
            this.mPayload[244] = s.ReadByte();
            this.mPayload[245] = s.ReadByte();
            this.mPayload[246] = s.ReadByte();
            this.mPayload[247] = s.ReadByte();
            this.mPayload[248] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message implementing parts of the V2 payload specs in V1 frames for transitional support."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MessageType",
                Description = "A code that identifies the software component that understands this message (analogous to usb device classes or mime type strings).  If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/extension-message-ids.xml.  Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetNetwork",
                Description = "Network ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID (0 for broadcast)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Payload",
                Description = "Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields.  The entire content of this block is opaque unless you understand any the encoding message_type.  The particular encoding used can be extension specific and might not always be documented as part of the mavlink specification.",
                NumElements = 249,
            });

        }

        private UInt16 mMessageType;
        private byte mTargetNetwork;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte[] mPayload = new byte[249];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
    /// </summary>
    public class UasMemoryVect: UasMessage
    {
        /// <summary>
        /// Starting address of the debug variables
        /// </summary>
        public UInt16 Address {
            get { return mAddress; }
            set { mAddress = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below
        /// </summary>
        public byte Ver {
            get { return mVer; }
            set { mVer = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14
        /// </summary>
        public byte Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Memory contents at specified address
        /// </summary>
        public SByte[] Value {
            get { return mValue; }
            set { mValue = value; NotifyUpdated(); }
        }

        public UasMemoryVect()
        {
            mMessageId = 249;
            CrcExtra = 204;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mAddress);
            s.Write(mVer);
            s.Write(mType);
            s.Write(mValue[0]); 
            s.Write(mValue[1]); 
            s.Write(mValue[2]); 
            s.Write(mValue[3]); 
            s.Write(mValue[4]); 
            s.Write(mValue[5]); 
            s.Write(mValue[6]); 
            s.Write(mValue[7]); 
            s.Write(mValue[8]); 
            s.Write(mValue[9]); 
            s.Write(mValue[10]); 
            s.Write(mValue[11]); 
            s.Write(mValue[12]); 
            s.Write(mValue[13]); 
            s.Write(mValue[14]); 
            s.Write(mValue[15]); 
            s.Write(mValue[16]); 
            s.Write(mValue[17]); 
            s.Write(mValue[18]); 
            s.Write(mValue[19]); 
            s.Write(mValue[20]); 
            s.Write(mValue[21]); 
            s.Write(mValue[22]); 
            s.Write(mValue[23]); 
            s.Write(mValue[24]); 
            s.Write(mValue[25]); 
            s.Write(mValue[26]); 
            s.Write(mValue[27]); 
            s.Write(mValue[28]); 
            s.Write(mValue[29]); 
            s.Write(mValue[30]); 
            s.Write(mValue[31]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mAddress = s.ReadUInt16();
            this.mVer = s.ReadByte();
            this.mType = s.ReadByte();
            this.mValue[0] = s.ReadSByte();
            this.mValue[1] = s.ReadSByte();
            this.mValue[2] = s.ReadSByte();
            this.mValue[3] = s.ReadSByte();
            this.mValue[4] = s.ReadSByte();
            this.mValue[5] = s.ReadSByte();
            this.mValue[6] = s.ReadSByte();
            this.mValue[7] = s.ReadSByte();
            this.mValue[8] = s.ReadSByte();
            this.mValue[9] = s.ReadSByte();
            this.mValue[10] = s.ReadSByte();
            this.mValue[11] = s.ReadSByte();
            this.mValue[12] = s.ReadSByte();
            this.mValue[13] = s.ReadSByte();
            this.mValue[14] = s.ReadSByte();
            this.mValue[15] = s.ReadSByte();
            this.mValue[16] = s.ReadSByte();
            this.mValue[17] = s.ReadSByte();
            this.mValue[18] = s.ReadSByte();
            this.mValue[19] = s.ReadSByte();
            this.mValue[20] = s.ReadSByte();
            this.mValue[21] = s.ReadSByte();
            this.mValue[22] = s.ReadSByte();
            this.mValue[23] = s.ReadSByte();
            this.mValue[24] = s.ReadSByte();
            this.mValue[25] = s.ReadSByte();
            this.mValue[26] = s.ReadSByte();
            this.mValue[27] = s.ReadSByte();
            this.mValue[28] = s.ReadSByte();
            this.mValue[29] = s.ReadSByte();
            this.mValue[30] = s.ReadSByte();
            this.mValue[31] = s.ReadSByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Address",
                Description = "Starting address of the debug variables",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ver",
                Description = "Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Value",
                Description = "Memory contents at specified address",
                NumElements = 32,
            });

        }

        private UInt16 mAddress;
        private byte mVer;
        private byte mType;
        private SByte[] mValue = new SByte[32];
    }


    // ___________________________________________________________________________________


    public class UasDebugVect: UasMessage
    {
        /// <summary>
        /// Timestamp
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// x
        /// </summary>
        public float X {
            get { return mX; }
            set { mX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// y
        /// </summary>
        public float Y {
            get { return mY; }
            set { mY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// z
        /// </summary>
        public float Z {
            get { return mZ; }
            set { mZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Name
        /// </summary>
        public char[] Name {
            get { return mName; }
            set { mName = value; NotifyUpdated(); }
        }

        public UasDebugVect()
        {
            mMessageId = 250;
            CrcExtra = 49;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mX);
            s.Write(mY);
            s.Write(mZ);
            s.Write(mName[0]); 
            s.Write(mName[1]); 
            s.Write(mName[2]); 
            s.Write(mName[3]); 
            s.Write(mName[4]); 
            s.Write(mName[5]); 
            s.Write(mName[6]); 
            s.Write(mName[7]); 
            s.Write(mName[8]); 
            s.Write(mName[9]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mX = s.ReadSingle();
            this.mY = s.ReadSingle();
            this.mZ = s.ReadSingle();
            this.mName[0] = s.ReadChar();
            this.mName[1] = s.ReadChar();
            this.mName[2] = s.ReadChar();
            this.mName[3] = s.ReadChar();
            this.mName[4] = s.ReadChar();
            this.mName[5] = s.ReadChar();
            this.mName[6] = s.ReadChar();
            this.mName[7] = s.ReadChar();
            this.mName[8] = s.ReadChar();
            this.mName[9] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = ""
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Timestamp",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "X",
                Description = "x",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Y",
                Description = "y",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Z",
                Description = "z",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Name",
                Description = "Name",
                NumElements = 10,
            });

        }

        private UInt64 mTimeUsec;
        private float mX;
        private float mY;
        private float mZ;
        private char[] mName = new char[10];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
    /// </summary>
    public class UasNamedValueFloat: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Floating point value
        /// </summary>
        public float Value {
            get { return mValue; }
            set { mValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Name of the debug variable
        /// </summary>
        public char[] Name {
            get { return mName; }
            set { mName = value; NotifyUpdated(); }
        }

        public UasNamedValueFloat()
        {
            mMessageId = 251;
            CrcExtra = 170;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mValue);
            s.Write(mName[0]); 
            s.Write(mName[1]); 
            s.Write(mName[2]); 
            s.Write(mName[3]); 
            s.Write(mName[4]); 
            s.Write(mName[5]); 
            s.Write(mName[6]); 
            s.Write(mName[7]); 
            s.Write(mName[8]); 
            s.Write(mName[9]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mValue = s.ReadSingle();
            this.mName[0] = s.ReadChar();
            this.mName[1] = s.ReadChar();
            this.mName[2] = s.ReadChar();
            this.mName[3] = s.ReadChar();
            this.mName[4] = s.ReadChar();
            this.mName[5] = s.ReadChar();
            this.mName[6] = s.ReadChar();
            this.mName[7] = s.ReadChar();
            this.mName[8] = s.ReadChar();
            this.mName[9] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Value",
                Description = "Floating point value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Name",
                Description = "Name of the debug variable",
                NumElements = 10,
            });

        }

        private UInt32 mTimeBootMs;
        private float mValue;
        private char[] mName = new char[10];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
    /// </summary>
    public class UasNamedValueInt: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Signed integer value
        /// </summary>
        public Int32 Value {
            get { return mValue; }
            set { mValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Name of the debug variable
        /// </summary>
        public char[] Name {
            get { return mName; }
            set { mName = value; NotifyUpdated(); }
        }

        public UasNamedValueInt()
        {
            mMessageId = 252;
            CrcExtra = 44;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mValue);
            s.Write(mName[0]); 
            s.Write(mName[1]); 
            s.Write(mName[2]); 
            s.Write(mName[3]); 
            s.Write(mName[4]); 
            s.Write(mName[5]); 
            s.Write(mName[6]); 
            s.Write(mName[7]); 
            s.Write(mName[8]); 
            s.Write(mName[9]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mValue = s.ReadInt32();
            this.mName[0] = s.ReadChar();
            this.mName[1] = s.ReadChar();
            this.mName[2] = s.ReadChar();
            this.mName[3] = s.ReadChar();
            this.mName[4] = s.ReadChar();
            this.mName[5] = s.ReadChar();
            this.mName[6] = s.ReadChar();
            this.mName[7] = s.ReadChar();
            this.mName[8] = s.ReadChar();
            this.mName[9] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Value",
                Description = "Signed integer value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Name",
                Description = "Name of the debug variable",
                NumElements = 10,
            });

        }

        private UInt32 mTimeBootMs;
        private Int32 mValue;
        private char[] mName = new char[10];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING: They consume quite some bandwidth, so use only for important status and error messages. If implemented wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz).
    /// </summary>
    public class UasStatustext: UasMessage
    {
        /// <summary>
        /// Severity of status. Relies on the definitions within RFC-5424. See enum MAV_SEVERITY.
        /// </summary>
        public MavSeverity Severity {
            get { return mSeverity; }
            set { mSeverity = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Status text message, without null termination character
        /// </summary>
        public char[] Text {
            get { return mText; }
            set { mText = value; NotifyUpdated(); }
        }

        public UasStatustext()
        {
            mMessageId = 253;
            CrcExtra = 83;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write((byte)mSeverity);
            s.Write(mText[0]); 
            s.Write(mText[1]); 
            s.Write(mText[2]); 
            s.Write(mText[3]); 
            s.Write(mText[4]); 
            s.Write(mText[5]); 
            s.Write(mText[6]); 
            s.Write(mText[7]); 
            s.Write(mText[8]); 
            s.Write(mText[9]); 
            s.Write(mText[10]); 
            s.Write(mText[11]); 
            s.Write(mText[12]); 
            s.Write(mText[13]); 
            s.Write(mText[14]); 
            s.Write(mText[15]); 
            s.Write(mText[16]); 
            s.Write(mText[17]); 
            s.Write(mText[18]); 
            s.Write(mText[19]); 
            s.Write(mText[20]); 
            s.Write(mText[21]); 
            s.Write(mText[22]); 
            s.Write(mText[23]); 
            s.Write(mText[24]); 
            s.Write(mText[25]); 
            s.Write(mText[26]); 
            s.Write(mText[27]); 
            s.Write(mText[28]); 
            s.Write(mText[29]); 
            s.Write(mText[30]); 
            s.Write(mText[31]); 
            s.Write(mText[32]); 
            s.Write(mText[33]); 
            s.Write(mText[34]); 
            s.Write(mText[35]); 
            s.Write(mText[36]); 
            s.Write(mText[37]); 
            s.Write(mText[38]); 
            s.Write(mText[39]); 
            s.Write(mText[40]); 
            s.Write(mText[41]); 
            s.Write(mText[42]); 
            s.Write(mText[43]); 
            s.Write(mText[44]); 
            s.Write(mText[45]); 
            s.Write(mText[46]); 
            s.Write(mText[47]); 
            s.Write(mText[48]); 
            s.Write(mText[49]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSeverity = (MavSeverity)s.ReadByte();
            this.mText[0] = s.ReadChar();
            this.mText[1] = s.ReadChar();
            this.mText[2] = s.ReadChar();
            this.mText[3] = s.ReadChar();
            this.mText[4] = s.ReadChar();
            this.mText[5] = s.ReadChar();
            this.mText[6] = s.ReadChar();
            this.mText[7] = s.ReadChar();
            this.mText[8] = s.ReadChar();
            this.mText[9] = s.ReadChar();
            this.mText[10] = s.ReadChar();
            this.mText[11] = s.ReadChar();
            this.mText[12] = s.ReadChar();
            this.mText[13] = s.ReadChar();
            this.mText[14] = s.ReadChar();
            this.mText[15] = s.ReadChar();
            this.mText[16] = s.ReadChar();
            this.mText[17] = s.ReadChar();
            this.mText[18] = s.ReadChar();
            this.mText[19] = s.ReadChar();
            this.mText[20] = s.ReadChar();
            this.mText[21] = s.ReadChar();
            this.mText[22] = s.ReadChar();
            this.mText[23] = s.ReadChar();
            this.mText[24] = s.ReadChar();
            this.mText[25] = s.ReadChar();
            this.mText[26] = s.ReadChar();
            this.mText[27] = s.ReadChar();
            this.mText[28] = s.ReadChar();
            this.mText[29] = s.ReadChar();
            this.mText[30] = s.ReadChar();
            this.mText[31] = s.ReadChar();
            this.mText[32] = s.ReadChar();
            this.mText[33] = s.ReadChar();
            this.mText[34] = s.ReadChar();
            this.mText[35] = s.ReadChar();
            this.mText[36] = s.ReadChar();
            this.mText[37] = s.ReadChar();
            this.mText[38] = s.ReadChar();
            this.mText[39] = s.ReadChar();
            this.mText[40] = s.ReadChar();
            this.mText[41] = s.ReadChar();
            this.mText[42] = s.ReadChar();
            this.mText[43] = s.ReadChar();
            this.mText[44] = s.ReadChar();
            this.mText[45] = s.ReadChar();
            this.mText[46] = s.ReadChar();
            this.mText[47] = s.ReadChar();
            this.mText[48] = s.ReadChar();
            this.mText[49] = s.ReadChar();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING: They consume quite some bandwidth, so use only for important status and error messages. If implemented wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz)."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Severity",
                Description = "Severity of status. Relies on the definitions within RFC-5424. See enum MAV_SEVERITY.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavSeverity"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Text",
                Description = "Status text message, without null termination character",
                NumElements = 50,
            });

        }

        private MavSeverity mSeverity;
        private char[] mText = new char[50];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send a debug value. The index is used to discriminate between values. These values show up in the plot of QGroundControl as DEBUG N.
    /// </summary>
    public class UasDebug: UasMessage
    {
        /// <summary>
        /// Timestamp (milliseconds since system boot)
        /// </summary>
        public UInt32 TimeBootMs {
            get { return mTimeBootMs; }
            set { mTimeBootMs = value; NotifyUpdated(); }
        }

        /// <summary>
        /// DEBUG value
        /// </summary>
        public float Value {
            get { return mValue; }
            set { mValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// index of debug variable
        /// </summary>
        public byte Ind {
            get { return mInd; }
            set { mInd = value; NotifyUpdated(); }
        }

        public UasDebug()
        {
            mMessageId = 254;
            CrcExtra = 46;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeBootMs);
            s.Write(mValue);
            s.Write(mInd);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeBootMs = s.ReadUInt32();
            this.mValue = s.ReadSingle();
            this.mInd = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send a debug value. The index is used to discriminate between values. These values show up in the plot of QGroundControl as DEBUG N."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeBootMs",
                Description = "Timestamp (milliseconds since system boot)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Value",
                Description = "DEBUG value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ind",
                Description = "index of debug variable",
                NumElements = 1,
            });

        }

        private UInt32 mTimeBootMs;
        private float mValue;
        private byte mInd;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Offsets and calibrations values for hardware sensors. This makes it easier to debug the calibration process.
    /// </summary>
    public class UasSensorOffsets: UasMessage
    {
        /// <summary>
        /// magnetic declination (radians)
        /// </summary>
        public float MagDeclination {
            get { return mMagDeclination; }
            set { mMagDeclination = value; NotifyUpdated(); }
        }

        /// <summary>
        /// raw pressure from barometer
        /// </summary>
        public Int32 RawPress {
            get { return mRawPress; }
            set { mRawPress = value; NotifyUpdated(); }
        }

        /// <summary>
        /// raw temperature from barometer
        /// </summary>
        public Int32 RawTemp {
            get { return mRawTemp; }
            set { mRawTemp = value; NotifyUpdated(); }
        }

        /// <summary>
        /// gyro X calibration
        /// </summary>
        public float GyroCalX {
            get { return mGyroCalX; }
            set { mGyroCalX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// gyro Y calibration
        /// </summary>
        public float GyroCalY {
            get { return mGyroCalY; }
            set { mGyroCalY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// gyro Z calibration
        /// </summary>
        public float GyroCalZ {
            get { return mGyroCalZ; }
            set { mGyroCalZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// accel X calibration
        /// </summary>
        public float AccelCalX {
            get { return mAccelCalX; }
            set { mAccelCalX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// accel Y calibration
        /// </summary>
        public float AccelCalY {
            get { return mAccelCalY; }
            set { mAccelCalY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// accel Z calibration
        /// </summary>
        public float AccelCalZ {
            get { return mAccelCalZ; }
            set { mAccelCalZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// magnetometer X offset
        /// </summary>
        public Int16 MagOfsX {
            get { return mMagOfsX; }
            set { mMagOfsX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// magnetometer Y offset
        /// </summary>
        public Int16 MagOfsY {
            get { return mMagOfsY; }
            set { mMagOfsY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// magnetometer Z offset
        /// </summary>
        public Int16 MagOfsZ {
            get { return mMagOfsZ; }
            set { mMagOfsZ = value; NotifyUpdated(); }
        }

        public UasSensorOffsets()
        {
            mMessageId = 150;
            CrcExtra = 134;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mMagDeclination);
            s.Write(mRawPress);
            s.Write(mRawTemp);
            s.Write(mGyroCalX);
            s.Write(mGyroCalY);
            s.Write(mGyroCalZ);
            s.Write(mAccelCalX);
            s.Write(mAccelCalY);
            s.Write(mAccelCalZ);
            s.Write(mMagOfsX);
            s.Write(mMagOfsY);
            s.Write(mMagOfsZ);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mMagDeclination = s.ReadSingle();
            this.mRawPress = s.ReadInt32();
            this.mRawTemp = s.ReadInt32();
            this.mGyroCalX = s.ReadSingle();
            this.mGyroCalY = s.ReadSingle();
            this.mGyroCalZ = s.ReadSingle();
            this.mAccelCalX = s.ReadSingle();
            this.mAccelCalY = s.ReadSingle();
            this.mAccelCalZ = s.ReadSingle();
            this.mMagOfsX = s.ReadInt16();
            this.mMagOfsY = s.ReadInt16();
            this.mMagOfsZ = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Offsets and calibrations values for hardware sensors. This makes it easier to debug the calibration process."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MagDeclination",
                Description = "magnetic declination (radians)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RawPress",
                Description = "raw pressure from barometer",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RawTemp",
                Description = "raw temperature from barometer",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GyroCalX",
                Description = "gyro X calibration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GyroCalY",
                Description = "gyro Y calibration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "GyroCalZ",
                Description = "gyro Z calibration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AccelCalX",
                Description = "accel X calibration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AccelCalY",
                Description = "accel Y calibration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AccelCalZ",
                Description = "accel Z calibration",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MagOfsX",
                Description = "magnetometer X offset",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MagOfsY",
                Description = "magnetometer Y offset",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MagOfsZ",
                Description = "magnetometer Z offset",
                NumElements = 1,
            });

        }

        private float mMagDeclination;
        private Int32 mRawPress;
        private Int32 mRawTemp;
        private float mGyroCalX;
        private float mGyroCalY;
        private float mGyroCalZ;
        private float mAccelCalX;
        private float mAccelCalY;
        private float mAccelCalZ;
        private Int16 mMagOfsX;
        private Int16 mMagOfsY;
        private Int16 mMagOfsZ;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the magnetometer offsets
    /// </summary>
    public class UasSetMagOffsets: UasMessage
    {
        /// <summary>
        /// magnetometer X offset
        /// </summary>
        public Int16 MagOfsX {
            get { return mMagOfsX; }
            set { mMagOfsX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// magnetometer Y offset
        /// </summary>
        public Int16 MagOfsY {
            get { return mMagOfsY; }
            set { mMagOfsY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// magnetometer Z offset
        /// </summary>
        public Int16 MagOfsZ {
            get { return mMagOfsZ; }
            set { mMagOfsZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasSetMagOffsets()
        {
            mMessageId = 151;
            CrcExtra = 219;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mMagOfsX);
            s.Write(mMagOfsY);
            s.Write(mMagOfsZ);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mMagOfsX = s.ReadInt16();
            this.mMagOfsY = s.ReadInt16();
            this.mMagOfsZ = s.ReadInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the magnetometer offsets"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MagOfsX",
                Description = "magnetometer X offset",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MagOfsY",
                Description = "magnetometer Y offset",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MagOfsZ",
                Description = "magnetometer Z offset",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private Int16 mMagOfsX;
        private Int16 mMagOfsY;
        private Int16 mMagOfsZ;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// state of APM memory
    /// </summary>
    public class UasMeminfo: UasMessage
    {
        /// <summary>
        /// free memory (32 bit)
        /// </summary>
        public UInt32 Freemem32 {
            get { return mFreemem32; }
            set { mFreemem32 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// heap top
        /// </summary>
        public UInt16 Brkval {
            get { return mBrkval; }
            set { mBrkval = value; NotifyUpdated(); }
        }

        /// <summary>
        /// free memory
        /// </summary>
        public UInt16 Freemem {
            get { return mFreemem; }
            set { mFreemem = value; NotifyUpdated(); }
        }

        public UasMeminfo()
        {
            mMessageId = 152;
            CrcExtra = 112;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mFreemem32);
            s.Write(mBrkval);
            s.Write(mFreemem);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mFreemem32 = s.ReadUInt32();
            this.mBrkval = s.ReadUInt16();
            this.mFreemem = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "state of APM memory"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Freemem32",
                Description = "free memory (32 bit)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Brkval",
                Description = "heap top",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Freemem",
                Description = "free memory",
                NumElements = 1,
            });

        }

        private UInt32 mFreemem32;
        private UInt16 mBrkval;
        private UInt16 mFreemem;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// raw ADC output
    /// </summary>
    public class UasApAdc: UasMessage
    {
        /// <summary>
        /// ADC output 1
        /// </summary>
        public UInt16 Adc1 {
            get { return mAdc1; }
            set { mAdc1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ADC output 2
        /// </summary>
        public UInt16 Adc2 {
            get { return mAdc2; }
            set { mAdc2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ADC output 3
        /// </summary>
        public UInt16 Adc3 {
            get { return mAdc3; }
            set { mAdc3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ADC output 4
        /// </summary>
        public UInt16 Adc4 {
            get { return mAdc4; }
            set { mAdc4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ADC output 5
        /// </summary>
        public UInt16 Adc5 {
            get { return mAdc5; }
            set { mAdc5 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ADC output 6
        /// </summary>
        public UInt16 Adc6 {
            get { return mAdc6; }
            set { mAdc6 = value; NotifyUpdated(); }
        }

        public UasApAdc()
        {
            mMessageId = 153;
            CrcExtra = 188;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mAdc1);
            s.Write(mAdc2);
            s.Write(mAdc3);
            s.Write(mAdc4);
            s.Write(mAdc5);
            s.Write(mAdc6);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mAdc1 = s.ReadUInt16();
            this.mAdc2 = s.ReadUInt16();
            this.mAdc3 = s.ReadUInt16();
            this.mAdc4 = s.ReadUInt16();
            this.mAdc5 = s.ReadUInt16();
            this.mAdc6 = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "raw ADC output"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Adc1",
                Description = "ADC output 1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Adc2",
                Description = "ADC output 2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Adc3",
                Description = "ADC output 3",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Adc4",
                Description = "ADC output 4",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Adc5",
                Description = "ADC output 5",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Adc6",
                Description = "ADC output 6",
                NumElements = 1,
            });

        }

        private UInt16 mAdc1;
        private UInt16 mAdc2;
        private UInt16 mAdc3;
        private UInt16 mAdc4;
        private UInt16 mAdc5;
        private UInt16 mAdc6;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Configure on-board Camera Control System.
    /// </summary>
    public class UasDigicamConfigure: UasMessage
    {
        /// <summary>
        /// Correspondent value to given extra_param
        /// </summary>
        public float ExtraValue {
            get { return mExtraValue; }
            set { mExtraValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Divisor number //e.g. 1000 means 1/1000 (0 means ignore)
        /// </summary>
        public UInt16 ShutterSpeed {
            get { return mShutterSpeed; }
            set { mShutterSpeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Mode enumeration from 1 to N //P, TV, AV, M, Etc (0 means ignore)
        /// </summary>
        public byte Mode {
            get { return mMode; }
            set { mMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// F stop number x 10 //e.g. 28 means 2.8 (0 means ignore)
        /// </summary>
        public byte Aperture {
            get { return mAperture; }
            set { mAperture = value; NotifyUpdated(); }
        }

        /// <summary>
        /// ISO enumeration from 1 to N //e.g. 80, 100, 200, Etc (0 means ignore)
        /// </summary>
        public byte Iso {
            get { return mIso; }
            set { mIso = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Exposure type enumeration from 1 to N (0 means ignore)
        /// </summary>
        public byte ExposureType {
            get { return mExposureType; }
            set { mExposureType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once
        /// </summary>
        public byte CommandId {
            get { return mCommandId; }
            set { mCommandId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off)
        /// </summary>
        public byte EngineCutOff {
            get { return mEngineCutOff; }
            set { mEngineCutOff = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Extra parameters enumeration (0 means ignore)
        /// </summary>
        public byte ExtraParam {
            get { return mExtraParam; }
            set { mExtraParam = value; NotifyUpdated(); }
        }

        public UasDigicamConfigure()
        {
            mMessageId = 154;
            CrcExtra = 84;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mExtraValue);
            s.Write(mShutterSpeed);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mMode);
            s.Write(mAperture);
            s.Write(mIso);
            s.Write(mExposureType);
            s.Write(mCommandId);
            s.Write(mEngineCutOff);
            s.Write(mExtraParam);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mExtraValue = s.ReadSingle();
            this.mShutterSpeed = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mMode = s.ReadByte();
            this.mAperture = s.ReadByte();
            this.mIso = s.ReadByte();
            this.mExposureType = s.ReadByte();
            this.mCommandId = s.ReadByte();
            this.mEngineCutOff = s.ReadByte();
            this.mExtraParam = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Configure on-board Camera Control System."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ExtraValue",
                Description = "Correspondent value to given extra_param",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ShutterSpeed",
                Description = "Divisor number //e.g. 1000 means 1/1000 (0 means ignore)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Mode",
                Description = "Mode enumeration from 1 to N //P, TV, AV, M, Etc (0 means ignore)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Aperture",
                Description = "F stop number x 10 //e.g. 28 means 2.8 (0 means ignore)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Iso",
                Description = "ISO enumeration from 1 to N //e.g. 80, 100, 200, Etc (0 means ignore)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ExposureType",
                Description = "Exposure type enumeration from 1 to N (0 means ignore)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CommandId",
                Description = "Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EngineCutOff",
                Description = "Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ExtraParam",
                Description = "Extra parameters enumeration (0 means ignore)",
                NumElements = 1,
            });

        }

        private float mExtraValue;
        private UInt16 mShutterSpeed;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mMode;
        private byte mAperture;
        private byte mIso;
        private byte mExposureType;
        private byte mCommandId;
        private byte mEngineCutOff;
        private byte mExtraParam;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Control on-board Camera Control System to take shots.
    /// </summary>
    public class UasDigicamControl: UasMessage
    {
        /// <summary>
        /// Correspondent value to given extra_param
        /// </summary>
        public float ExtraValue {
            get { return mExtraValue; }
            set { mExtraValue = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: stop, 1: start or keep it up //Session control e.g. show/hide lens
        /// </summary>
        public byte Session {
            get { return mSession; }
            set { mSession = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 1 to N //Zoom's absolute position (0 means ignore)
        /// </summary>
        public byte ZoomPos {
            get { return mZoomPos; }
            set { mZoomPos = value; NotifyUpdated(); }
        }

        /// <summary>
        /// -100 to 100 //Zooming step value to offset zoom from the current position
        /// </summary>
        public SByte ZoomStep {
            get { return mZoomStep; }
            set { mZoomStep = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: unlock focus or keep unlocked, 1: lock focus or keep locked, 3: re-lock focus
        /// </summary>
        public byte FocusLock {
            get { return mFocusLock; }
            set { mFocusLock = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0: ignore, 1: shot or start filming
        /// </summary>
        public byte Shot {
            get { return mShot; }
            set { mShot = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once
        /// </summary>
        public byte CommandId {
            get { return mCommandId; }
            set { mCommandId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Extra parameters enumeration (0 means ignore)
        /// </summary>
        public byte ExtraParam {
            get { return mExtraParam; }
            set { mExtraParam = value; NotifyUpdated(); }
        }

        public UasDigicamControl()
        {
            mMessageId = 155;
            CrcExtra = 22;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mExtraValue);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mSession);
            s.Write(mZoomPos);
            s.Write(mZoomStep);
            s.Write(mFocusLock);
            s.Write(mShot);
            s.Write(mCommandId);
            s.Write(mExtraParam);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mExtraValue = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mSession = s.ReadByte();
            this.mZoomPos = s.ReadByte();
            this.mZoomStep = s.ReadSByte();
            this.mFocusLock = s.ReadByte();
            this.mShot = s.ReadByte();
            this.mCommandId = s.ReadByte();
            this.mExtraParam = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Control on-board Camera Control System to take shots."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ExtraValue",
                Description = "Correspondent value to given extra_param",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Session",
                Description = "0: stop, 1: start or keep it up //Session control e.g. show/hide lens",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ZoomPos",
                Description = "1 to N //Zoom's absolute position (0 means ignore)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ZoomStep",
                Description = "-100 to 100 //Zooming step value to offset zoom from the current position",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FocusLock",
                Description = "0: unlock focus or keep unlocked, 1: lock focus or keep locked, 3: re-lock focus",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Shot",
                Description = "0: ignore, 1: shot or start filming",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CommandId",
                Description = "Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ExtraParam",
                Description = "Extra parameters enumeration (0 means ignore)",
                NumElements = 1,
            });

        }

        private float mExtraValue;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mSession;
        private byte mZoomPos;
        private SByte mZoomStep;
        private byte mFocusLock;
        private byte mShot;
        private byte mCommandId;
        private byte mExtraParam;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message to configure a camera mount, directional antenna, etc.
    /// </summary>
    public class UasMountConfigure: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// mount operating mode (see MAV_MOUNT_MODE enum)
        /// </summary>
        public MavMountMode MountMode {
            get { return mMountMode; }
            set { mMountMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// (1 = yes, 0 = no)
        /// </summary>
        public byte StabRoll {
            get { return mStabRoll; }
            set { mStabRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// (1 = yes, 0 = no)
        /// </summary>
        public byte StabPitch {
            get { return mStabPitch; }
            set { mStabPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// (1 = yes, 0 = no)
        /// </summary>
        public byte StabYaw {
            get { return mStabYaw; }
            set { mStabYaw = value; NotifyUpdated(); }
        }

        public UasMountConfigure()
        {
            mMessageId = 156;
            CrcExtra = 19;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write((byte)mMountMode);
            s.Write(mStabRoll);
            s.Write(mStabPitch);
            s.Write(mStabYaw);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mMountMode = (MavMountMode)s.ReadByte();
            this.mStabRoll = s.ReadByte();
            this.mStabPitch = s.ReadByte();
            this.mStabYaw = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message to configure a camera mount, directional antenna, etc."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "MountMode",
                Description = "mount operating mode (see MAV_MOUNT_MODE enum)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavMountMode"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StabRoll",
                Description = "(1 = yes, 0 = no)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StabPitch",
                Description = "(1 = yes, 0 = no)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StabYaw",
                Description = "(1 = yes, 0 = no)",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
        private MavMountMode mMountMode;
        private byte mStabRoll;
        private byte mStabPitch;
        private byte mStabYaw;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message to control a camera mount, directional antenna, etc.
    /// </summary>
    public class UasMountControl: UasMessage
    {
        /// <summary>
        /// pitch(deg*100) or lat, depending on mount mode
        /// </summary>
        public Int32 InputA {
            get { return mInputA; }
            set { mInputA = value; NotifyUpdated(); }
        }

        /// <summary>
        /// roll(deg*100) or lon depending on mount mode
        /// </summary>
        public Int32 InputB {
            get { return mInputB; }
            set { mInputB = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw(deg*100) or alt (in cm) depending on mount mode
        /// </summary>
        public Int32 InputC {
            get { return mInputC; }
            set { mInputC = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// if '1' it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING)
        /// </summary>
        public byte SavePosition {
            get { return mSavePosition; }
            set { mSavePosition = value; NotifyUpdated(); }
        }

        public UasMountControl()
        {
            mMessageId = 157;
            CrcExtra = 21;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mInputA);
            s.Write(mInputB);
            s.Write(mInputC);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mSavePosition);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mInputA = s.ReadInt32();
            this.mInputB = s.ReadInt32();
            this.mInputC = s.ReadInt32();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mSavePosition = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message to control a camera mount, directional antenna, etc."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "InputA",
                Description = "pitch(deg*100) or lat, depending on mount mode",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "InputB",
                Description = "roll(deg*100) or lon depending on mount mode",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "InputC",
                Description = "yaw(deg*100) or alt (in cm) depending on mount mode",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SavePosition",
                Description = "if '1' it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING)",
                NumElements = 1,
            });

        }

        private Int32 mInputA;
        private Int32 mInputB;
        private Int32 mInputC;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mSavePosition;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Message with some status from APM to GCS about camera or antenna mount
    /// </summary>
    public class UasMountStatus: UasMessage
    {
        /// <summary>
        /// pitch(deg*100)
        /// </summary>
        public Int32 PointingA {
            get { return mPointingA; }
            set { mPointingA = value; NotifyUpdated(); }
        }

        /// <summary>
        /// roll(deg*100)
        /// </summary>
        public Int32 PointingB {
            get { return mPointingB; }
            set { mPointingB = value; NotifyUpdated(); }
        }

        /// <summary>
        /// yaw(deg*100)
        /// </summary>
        public Int32 PointingC {
            get { return mPointingC; }
            set { mPointingC = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasMountStatus()
        {
            mMessageId = 158;
            CrcExtra = 134;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mPointingA);
            s.Write(mPointingB);
            s.Write(mPointingC);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mPointingA = s.ReadInt32();
            this.mPointingB = s.ReadInt32();
            this.mPointingC = s.ReadInt32();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Message with some status from APM to GCS about camera or antenna mount"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PointingA",
                Description = "pitch(deg*100)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PointingB",
                Description = "roll(deg*100)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PointingC",
                Description = "yaw(deg*100)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private Int32 mPointingA;
        private Int32 mPointingB;
        private Int32 mPointingC;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// A fence point. Used to set a point when from GCS -> MAV. Also used to return a point from MAV -> GCS
    /// </summary>
    public class UasFencePoint: UasMessage
    {
        /// <summary>
        /// Latitude of point
        /// </summary>
        public float Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude of point
        /// </summary>
        public float Lng {
            get { return mLng; }
            set { mLng = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// point index (first point is 1, 0 is for return point)
        /// </summary>
        public byte Idx {
            get { return mIdx; }
            set { mIdx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// total number of points (for sanity checking)
        /// </summary>
        public byte Count {
            get { return mCount; }
            set { mCount = value; NotifyUpdated(); }
        }

        public UasFencePoint()
        {
            mMessageId = 160;
            CrcExtra = 78;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mLat);
            s.Write(mLng);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mIdx);
            s.Write(mCount);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mLat = s.ReadSingle();
            this.mLng = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mIdx = s.ReadByte();
            this.mCount = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "A fence point. Used to set a point when from GCS -> MAV. Also used to return a point from MAV -> GCS"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude of point",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lng",
                Description = "Longitude of point",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Idx",
                Description = "point index (first point is 1, 0 is for return point)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Count",
                Description = "total number of points (for sanity checking)",
                NumElements = 1,
            });

        }

        private float mLat;
        private float mLng;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mIdx;
        private byte mCount;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request a current fence point from MAV
    /// </summary>
    public class UasFenceFetchPoint: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// point index (first point is 1, 0 is for return point)
        /// </summary>
        public byte Idx {
            get { return mIdx; }
            set { mIdx = value; NotifyUpdated(); }
        }

        public UasFenceFetchPoint()
        {
            mMessageId = 161;
            CrcExtra = 68;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mIdx);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mIdx = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request a current fence point from MAV"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Idx",
                Description = "point index (first point is 1, 0 is for return point)",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mIdx;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of geo-fencing. Sent in extended status stream when fencing enabled
    /// </summary>
    public class UasFenceStatus: UasMessage
    {
        /// <summary>
        /// time of last breach in milliseconds since boot
        /// </summary>
        public UInt32 BreachTime {
            get { return mBreachTime; }
            set { mBreachTime = value; NotifyUpdated(); }
        }

        /// <summary>
        /// number of fence breaches
        /// </summary>
        public UInt16 BreachCount {
            get { return mBreachCount; }
            set { mBreachCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0 if currently inside fence, 1 if outside
        /// </summary>
        public byte BreachStatus {
            get { return mBreachStatus; }
            set { mBreachStatus = value; NotifyUpdated(); }
        }

        /// <summary>
        /// last breach type (see FENCE_BREACH_* enum)
        /// </summary>
        public FenceBreach BreachType {
            get { return mBreachType; }
            set { mBreachType = value; NotifyUpdated(); }
        }

        public UasFenceStatus()
        {
            mMessageId = 162;
            CrcExtra = 189;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mBreachTime);
            s.Write(mBreachCount);
            s.Write(mBreachStatus);
            s.Write((byte)mBreachType);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mBreachTime = s.ReadUInt32();
            this.mBreachCount = s.ReadUInt16();
            this.mBreachStatus = s.ReadByte();
            this.mBreachType = (FenceBreach)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of geo-fencing. Sent in extended status stream when fencing enabled"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BreachTime",
                Description = "time of last breach in milliseconds since boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BreachCount",
                Description = "number of fence breaches",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BreachStatus",
                Description = "0 if currently inside fence, 1 if outside",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BreachType",
                Description = "last breach type (see FENCE_BREACH_* enum)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("FenceBreach"),
            });

        }

        private UInt32 mBreachTime;
        private UInt16 mBreachCount;
        private byte mBreachStatus;
        private FenceBreach mBreachType;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of DCM attitude estimator
    /// </summary>
    public class UasAhrs: UasMessage
    {
        /// <summary>
        /// X gyro drift estimate rad/s
        /// </summary>
        public float Omegaix {
            get { return mOmegaix; }
            set { mOmegaix = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y gyro drift estimate rad/s
        /// </summary>
        public float Omegaiy {
            get { return mOmegaiy; }
            set { mOmegaiy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z gyro drift estimate rad/s
        /// </summary>
        public float Omegaiz {
            get { return mOmegaiz; }
            set { mOmegaiz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// average accel_weight
        /// </summary>
        public float AccelWeight {
            get { return mAccelWeight; }
            set { mAccelWeight = value; NotifyUpdated(); }
        }

        /// <summary>
        /// average renormalisation value
        /// </summary>
        public float RenormVal {
            get { return mRenormVal; }
            set { mRenormVal = value; NotifyUpdated(); }
        }

        /// <summary>
        /// average error_roll_pitch value
        /// </summary>
        public float ErrorRp {
            get { return mErrorRp; }
            set { mErrorRp = value; NotifyUpdated(); }
        }

        /// <summary>
        /// average error_yaw value
        /// </summary>
        public float ErrorYaw {
            get { return mErrorYaw; }
            set { mErrorYaw = value; NotifyUpdated(); }
        }

        public UasAhrs()
        {
            mMessageId = 163;
            CrcExtra = 127;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mOmegaix);
            s.Write(mOmegaiy);
            s.Write(mOmegaiz);
            s.Write(mAccelWeight);
            s.Write(mRenormVal);
            s.Write(mErrorRp);
            s.Write(mErrorYaw);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mOmegaix = s.ReadSingle();
            this.mOmegaiy = s.ReadSingle();
            this.mOmegaiz = s.ReadSingle();
            this.mAccelWeight = s.ReadSingle();
            this.mRenormVal = s.ReadSingle();
            this.mErrorRp = s.ReadSingle();
            this.mErrorYaw = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of DCM attitude estimator"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Omegaix",
                Description = "X gyro drift estimate rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Omegaiy",
                Description = "Y gyro drift estimate rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Omegaiz",
                Description = "Z gyro drift estimate rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AccelWeight",
                Description = "average accel_weight",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RenormVal",
                Description = "average renormalisation value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorRp",
                Description = "average error_roll_pitch value",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ErrorYaw",
                Description = "average error_yaw value",
                NumElements = 1,
            });

        }

        private float mOmegaix;
        private float mOmegaiy;
        private float mOmegaiz;
        private float mAccelWeight;
        private float mRenormVal;
        private float mErrorRp;
        private float mErrorYaw;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of simulation environment, if used
    /// </summary>
    public class UasSimstate: UasMessage
    {
        /// <summary>
        /// Roll angle (rad)
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle (rad)
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle (rad)
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X acceleration m/s/s
        /// </summary>
        public float Xacc {
            get { return mXacc; }
            set { mXacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y acceleration m/s/s
        /// </summary>
        public float Yacc {
            get { return mYacc; }
            set { mYacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z acceleration m/s/s
        /// </summary>
        public float Zacc {
            get { return mZacc; }
            set { mZacc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around X axis rad/s
        /// </summary>
        public float Xgyro {
            get { return mXgyro; }
            set { mXgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Y axis rad/s
        /// </summary>
        public float Ygyro {
            get { return mYgyro; }
            set { mYgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Angular speed around Z axis rad/s
        /// </summary>
        public float Zgyro {
            get { return mZgyro; }
            set { mZgyro = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude in degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude in degrees * 1E7
        /// </summary>
        public Int32 Lng {
            get { return mLng; }
            set { mLng = value; NotifyUpdated(); }
        }

        public UasSimstate()
        {
            mMessageId = 164;
            CrcExtra = 154;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mXacc);
            s.Write(mYacc);
            s.Write(mZacc);
            s.Write(mXgyro);
            s.Write(mYgyro);
            s.Write(mZgyro);
            s.Write(mLat);
            s.Write(mLng);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mXacc = s.ReadSingle();
            this.mYacc = s.ReadSingle();
            this.mZacc = s.ReadSingle();
            this.mXgyro = s.ReadSingle();
            this.mYgyro = s.ReadSingle();
            this.mZgyro = s.ReadSingle();
            this.mLat = s.ReadInt32();
            this.mLng = s.ReadInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of simulation environment, if used"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xacc",
                Description = "X acceleration m/s/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yacc",
                Description = "Y acceleration m/s/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zacc",
                Description = "Z acceleration m/s/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Xgyro",
                Description = "Angular speed around X axis rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ygyro",
                Description = "Angular speed around Y axis rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Zgyro",
                Description = "Angular speed around Z axis rad/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lng",
                Description = "Longitude in degrees * 1E7",
                NumElements = 1,
            });

        }

        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mXacc;
        private float mYacc;
        private float mZacc;
        private float mXgyro;
        private float mYgyro;
        private float mZgyro;
        private Int32 mLat;
        private Int32 mLng;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of key hardware
    /// </summary>
    public class UasHwstatus: UasMessage
    {
        /// <summary>
        /// board voltage (mV)
        /// </summary>
        public UInt16 Vcc {
            get { return mVcc; }
            set { mVcc = value; NotifyUpdated(); }
        }

        /// <summary>
        /// I2C error count
        /// </summary>
        public byte I2cerr {
            get { return mI2cerr; }
            set { mI2cerr = value; NotifyUpdated(); }
        }

        public UasHwstatus()
        {
            mMessageId = 165;
            CrcExtra = 21;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mVcc);
            s.Write(mI2cerr);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mVcc = s.ReadUInt16();
            this.mI2cerr = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of key hardware"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vcc",
                Description = "board voltage (mV)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "I2cerr",
                Description = "I2C error count",
                NumElements = 1,
            });

        }

        private UInt16 mVcc;
        private byte mI2cerr;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status generated by radio
    /// </summary>
    public class UasRadio: UasMessage
    {
        /// <summary>
        /// receive errors
        /// </summary>
        public UInt16 Rxerrors {
            get { return mRxerrors; }
            set { mRxerrors = value; NotifyUpdated(); }
        }

        /// <summary>
        /// count of error corrected packets
        /// </summary>
        public UInt16 Fixed {
            get { return mFixed; }
            set { mFixed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// local signal strength
        /// </summary>
        public byte Rssi {
            get { return mRssi; }
            set { mRssi = value; NotifyUpdated(); }
        }

        /// <summary>
        /// remote signal strength
        /// </summary>
        public byte Remrssi {
            get { return mRemrssi; }
            set { mRemrssi = value; NotifyUpdated(); }
        }

        /// <summary>
        /// how full the tx buffer is as a percentage
        /// </summary>
        public byte Txbuf {
            get { return mTxbuf; }
            set { mTxbuf = value; NotifyUpdated(); }
        }

        /// <summary>
        /// background noise level
        /// </summary>
        public byte Noise {
            get { return mNoise; }
            set { mNoise = value; NotifyUpdated(); }
        }

        /// <summary>
        /// remote background noise level
        /// </summary>
        public byte Remnoise {
            get { return mRemnoise; }
            set { mRemnoise = value; NotifyUpdated(); }
        }

        public UasRadio()
        {
            mMessageId = 166;
            CrcExtra = 21;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mRxerrors);
            s.Write(mFixed);
            s.Write(mRssi);
            s.Write(mRemrssi);
            s.Write(mTxbuf);
            s.Write(mNoise);
            s.Write(mRemnoise);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mRxerrors = s.ReadUInt16();
            this.mFixed = s.ReadUInt16();
            this.mRssi = s.ReadByte();
            this.mRemrssi = s.ReadByte();
            this.mTxbuf = s.ReadByte();
            this.mNoise = s.ReadByte();
            this.mRemnoise = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status generated by radio"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rxerrors",
                Description = "receive errors",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Fixed",
                Description = "count of error corrected packets",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rssi",
                Description = "local signal strength",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Remrssi",
                Description = "remote signal strength",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Txbuf",
                Description = "how full the tx buffer is as a percentage",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Noise",
                Description = "background noise level",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Remnoise",
                Description = "remote background noise level",
                NumElements = 1,
            });

        }

        private UInt16 mRxerrors;
        private UInt16 mFixed;
        private byte mRssi;
        private byte mRemrssi;
        private byte mTxbuf;
        private byte mNoise;
        private byte mRemnoise;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled
    /// </summary>
    public class UasLimitsStatus: UasMessage
    {
        /// <summary>
        /// time of last breach in milliseconds since boot
        /// </summary>
        public UInt32 LastTrigger {
            get { return mLastTrigger; }
            set { mLastTrigger = value; NotifyUpdated(); }
        }

        /// <summary>
        /// time of last recovery action in milliseconds since boot
        /// </summary>
        public UInt32 LastAction {
            get { return mLastAction; }
            set { mLastAction = value; NotifyUpdated(); }
        }

        /// <summary>
        /// time of last successful recovery in milliseconds since boot
        /// </summary>
        public UInt32 LastRecovery {
            get { return mLastRecovery; }
            set { mLastRecovery = value; NotifyUpdated(); }
        }

        /// <summary>
        /// time of last all-clear in milliseconds since boot
        /// </summary>
        public UInt32 LastClear {
            get { return mLastClear; }
            set { mLastClear = value; NotifyUpdated(); }
        }

        /// <summary>
        /// number of fence breaches
        /// </summary>
        public UInt16 BreachCount {
            get { return mBreachCount; }
            set { mBreachCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// state of AP_Limits, (see enum LimitState, LIMITS_STATE)
        /// </summary>
        public LimitsState LimitsState {
            get { return mLimitsState; }
            set { mLimitsState = value; NotifyUpdated(); }
        }

        /// <summary>
        /// AP_Limit_Module bitfield of enabled modules, (see enum moduleid or LIMIT_MODULE)
        /// </summary>
        public LimitModule ModsEnabled {
            get { return mModsEnabled; }
            set { mModsEnabled = value; NotifyUpdated(); }
        }

        /// <summary>
        /// AP_Limit_Module bitfield of required modules, (see enum moduleid or LIMIT_MODULE)
        /// </summary>
        public LimitModule ModsRequired {
            get { return mModsRequired; }
            set { mModsRequired = value; NotifyUpdated(); }
        }

        /// <summary>
        /// AP_Limit_Module bitfield of triggered modules, (see enum moduleid or LIMIT_MODULE)
        /// </summary>
        public LimitModule ModsTriggered {
            get { return mModsTriggered; }
            set { mModsTriggered = value; NotifyUpdated(); }
        }

        public UasLimitsStatus()
        {
            mMessageId = 167;
            CrcExtra = 144;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mLastTrigger);
            s.Write(mLastAction);
            s.Write(mLastRecovery);
            s.Write(mLastClear);
            s.Write(mBreachCount);
            s.Write((byte)mLimitsState);
            s.Write((byte)mModsEnabled);
            s.Write((byte)mModsRequired);
            s.Write((byte)mModsTriggered);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mLastTrigger = s.ReadUInt32();
            this.mLastAction = s.ReadUInt32();
            this.mLastRecovery = s.ReadUInt32();
            this.mLastClear = s.ReadUInt32();
            this.mBreachCount = s.ReadUInt16();
            this.mLimitsState = (LimitsState)s.ReadByte();
            this.mModsEnabled = (LimitModule)s.ReadByte();
            this.mModsRequired = (LimitModule)s.ReadByte();
            this.mModsTriggered = (LimitModule)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LastTrigger",
                Description = "time of last breach in milliseconds since boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LastAction",
                Description = "time of last recovery action in milliseconds since boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LastRecovery",
                Description = "time of last successful recovery in milliseconds since boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LastClear",
                Description = "time of last all-clear in milliseconds since boot",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BreachCount",
                Description = "number of fence breaches",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LimitsState",
                Description = "state of AP_Limits, (see enum LimitState, LIMITS_STATE)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("LimitsState"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ModsEnabled",
                Description = "AP_Limit_Module bitfield of enabled modules, (see enum moduleid or LIMIT_MODULE)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("LimitModule"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ModsRequired",
                Description = "AP_Limit_Module bitfield of required modules, (see enum moduleid or LIMIT_MODULE)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("LimitModule"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ModsTriggered",
                Description = "AP_Limit_Module bitfield of triggered modules, (see enum moduleid or LIMIT_MODULE)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("LimitModule"),
            });

        }

        private UInt32 mLastTrigger;
        private UInt32 mLastAction;
        private UInt32 mLastRecovery;
        private UInt32 mLastClear;
        private UInt16 mBreachCount;
        private LimitsState mLimitsState;
        private LimitModule mModsEnabled;
        private LimitModule mModsRequired;
        private LimitModule mModsTriggered;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Wind estimation
    /// </summary>
    public class UasWind: UasMessage
    {
        /// <summary>
        /// wind direction that wind is coming from (degrees)
        /// </summary>
        public float Direction {
            get { return mDirection; }
            set { mDirection = value; NotifyUpdated(); }
        }

        /// <summary>
        /// wind speed in ground plane (m/s)
        /// </summary>
        public float Speed {
            get { return mSpeed; }
            set { mSpeed = value; NotifyUpdated(); }
        }

        /// <summary>
        /// vertical wind speed (m/s)
        /// </summary>
        public float SpeedZ {
            get { return mSpeedZ; }
            set { mSpeedZ = value; NotifyUpdated(); }
        }

        public UasWind()
        {
            mMessageId = 168;
            CrcExtra = 1;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mDirection);
            s.Write(mSpeed);
            s.Write(mSpeedZ);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mDirection = s.ReadSingle();
            this.mSpeed = s.ReadSingle();
            this.mSpeedZ = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Wind estimation"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Direction",
                Description = "wind direction that wind is coming from (degrees)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Speed",
                Description = "wind speed in ground plane (m/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "SpeedZ",
                Description = "vertical wind speed (m/s)",
                NumElements = 1,
            });

        }

        private float mDirection;
        private float mSpeed;
        private float mSpeedZ;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Data packet, size 16
    /// </summary>
    public class UasData16: UasMessage
    {
        /// <summary>
        /// data type
        /// </summary>
        public byte Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// data length
        /// </summary>
        public byte Len {
            get { return mLen; }
            set { mLen = value; NotifyUpdated(); }
        }

        /// <summary>
        /// raw data
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasData16()
        {
            mMessageId = 169;
            CrcExtra = 234;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mType);
            s.Write(mLen);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mType = s.ReadByte();
            this.mLen = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Data packet, size 16"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "data type",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Len",
                Description = "data length",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "raw data",
                NumElements = 16,
            });

        }

        private byte mType;
        private byte mLen;
        private byte[] mData = new byte[16];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Data packet, size 32
    /// </summary>
    public class UasData32: UasMessage
    {
        /// <summary>
        /// data type
        /// </summary>
        public byte Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// data length
        /// </summary>
        public byte Len {
            get { return mLen; }
            set { mLen = value; NotifyUpdated(); }
        }

        /// <summary>
        /// raw data
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasData32()
        {
            mMessageId = 170;
            CrcExtra = 73;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mType);
            s.Write(mLen);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mType = s.ReadByte();
            this.mLen = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Data packet, size 32"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "data type",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Len",
                Description = "data length",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "raw data",
                NumElements = 32,
            });

        }

        private byte mType;
        private byte mLen;
        private byte[] mData = new byte[32];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Data packet, size 64
    /// </summary>
    public class UasData64: UasMessage
    {
        /// <summary>
        /// data type
        /// </summary>
        public byte Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// data length
        /// </summary>
        public byte Len {
            get { return mLen; }
            set { mLen = value; NotifyUpdated(); }
        }

        /// <summary>
        /// raw data
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasData64()
        {
            mMessageId = 171;
            CrcExtra = 181;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mType);
            s.Write(mLen);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mType = s.ReadByte();
            this.mLen = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Data packet, size 64"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "data type",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Len",
                Description = "data length",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "raw data",
                NumElements = 64,
            });

        }

        private byte mType;
        private byte mLen;
        private byte[] mData = new byte[64];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Data packet, size 96
    /// </summary>
    public class UasData96: UasMessage
    {
        /// <summary>
        /// data type
        /// </summary>
        public byte Type {
            get { return mType; }
            set { mType = value; NotifyUpdated(); }
        }

        /// <summary>
        /// data length
        /// </summary>
        public byte Len {
            get { return mLen; }
            set { mLen = value; NotifyUpdated(); }
        }

        /// <summary>
        /// raw data
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasData96()
        {
            mMessageId = 172;
            CrcExtra = 22;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mType);
            s.Write(mLen);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
            s.Write(mData[70]); 
            s.Write(mData[71]); 
            s.Write(mData[72]); 
            s.Write(mData[73]); 
            s.Write(mData[74]); 
            s.Write(mData[75]); 
            s.Write(mData[76]); 
            s.Write(mData[77]); 
            s.Write(mData[78]); 
            s.Write(mData[79]); 
            s.Write(mData[80]); 
            s.Write(mData[81]); 
            s.Write(mData[82]); 
            s.Write(mData[83]); 
            s.Write(mData[84]); 
            s.Write(mData[85]); 
            s.Write(mData[86]); 
            s.Write(mData[87]); 
            s.Write(mData[88]); 
            s.Write(mData[89]); 
            s.Write(mData[90]); 
            s.Write(mData[91]); 
            s.Write(mData[92]); 
            s.Write(mData[93]); 
            s.Write(mData[94]); 
            s.Write(mData[95]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mType = s.ReadByte();
            this.mLen = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
            this.mData[70] = s.ReadByte();
            this.mData[71] = s.ReadByte();
            this.mData[72] = s.ReadByte();
            this.mData[73] = s.ReadByte();
            this.mData[74] = s.ReadByte();
            this.mData[75] = s.ReadByte();
            this.mData[76] = s.ReadByte();
            this.mData[77] = s.ReadByte();
            this.mData[78] = s.ReadByte();
            this.mData[79] = s.ReadByte();
            this.mData[80] = s.ReadByte();
            this.mData[81] = s.ReadByte();
            this.mData[82] = s.ReadByte();
            this.mData[83] = s.ReadByte();
            this.mData[84] = s.ReadByte();
            this.mData[85] = s.ReadByte();
            this.mData[86] = s.ReadByte();
            this.mData[87] = s.ReadByte();
            this.mData[88] = s.ReadByte();
            this.mData[89] = s.ReadByte();
            this.mData[90] = s.ReadByte();
            this.mData[91] = s.ReadByte();
            this.mData[92] = s.ReadByte();
            this.mData[93] = s.ReadByte();
            this.mData[94] = s.ReadByte();
            this.mData[95] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Data packet, size 96"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Type",
                Description = "data type",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Len",
                Description = "data length",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "raw data",
                NumElements = 96,
            });

        }

        private byte mType;
        private byte mLen;
        private byte[] mData = new byte[96];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Rangefinder reporting
    /// </summary>
    public class UasRangefinder: UasMessage
    {
        /// <summary>
        /// distance in meters
        /// </summary>
        public float Distance {
            get { return mDistance; }
            set { mDistance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// raw voltage if available, zero otherwise
        /// </summary>
        public float Voltage {
            get { return mVoltage; }
            set { mVoltage = value; NotifyUpdated(); }
        }

        public UasRangefinder()
        {
            mMessageId = 173;
            CrcExtra = 83;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mDistance);
            s.Write(mVoltage);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mDistance = s.ReadSingle();
            this.mVoltage = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Rangefinder reporting"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Distance",
                Description = "distance in meters",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Voltage",
                Description = "raw voltage if available, zero otherwise",
                NumElements = 1,
            });

        }

        private float mDistance;
        private float mVoltage;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Airspeed auto-calibration
    /// </summary>
    public class UasAirspeedAutocal: UasMessage
    {
        /// <summary>
        /// GPS velocity north m/s
        /// </summary>
        public float Vx {
            get { return mVx; }
            set { mVx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity east m/s
        /// </summary>
        public float Vy {
            get { return mVy; }
            set { mVy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// GPS velocity down m/s
        /// </summary>
        public float Vz {
            get { return mVz; }
            set { mVz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Differential pressure pascals
        /// </summary>
        public float DiffPressure {
            get { return mDiffPressure; }
            set { mDiffPressure = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Estimated to true airspeed ratio
        /// </summary>
        public float Eas2tas {
            get { return mEas2tas; }
            set { mEas2tas = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Airspeed ratio
        /// </summary>
        public float Ratio {
            get { return mRatio; }
            set { mRatio = value; NotifyUpdated(); }
        }

        /// <summary>
        /// EKF state x
        /// </summary>
        public float StateX {
            get { return mStateX; }
            set { mStateX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// EKF state y
        /// </summary>
        public float StateY {
            get { return mStateY; }
            set { mStateY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// EKF state z
        /// </summary>
        public float StateZ {
            get { return mStateZ; }
            set { mStateZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// EKF Pax
        /// </summary>
        public float Pax {
            get { return mPax; }
            set { mPax = value; NotifyUpdated(); }
        }

        /// <summary>
        /// EKF Pby
        /// </summary>
        public float Pby {
            get { return mPby; }
            set { mPby = value; NotifyUpdated(); }
        }

        /// <summary>
        /// EKF Pcz
        /// </summary>
        public float Pcz {
            get { return mPcz; }
            set { mPcz = value; NotifyUpdated(); }
        }

        public UasAirspeedAutocal()
        {
            mMessageId = 174;
            CrcExtra = 167;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mVx);
            s.Write(mVy);
            s.Write(mVz);
            s.Write(mDiffPressure);
            s.Write(mEas2tas);
            s.Write(mRatio);
            s.Write(mStateX);
            s.Write(mStateY);
            s.Write(mStateZ);
            s.Write(mPax);
            s.Write(mPby);
            s.Write(mPcz);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mVx = s.ReadSingle();
            this.mVy = s.ReadSingle();
            this.mVz = s.ReadSingle();
            this.mDiffPressure = s.ReadSingle();
            this.mEas2tas = s.ReadSingle();
            this.mRatio = s.ReadSingle();
            this.mStateX = s.ReadSingle();
            this.mStateY = s.ReadSingle();
            this.mStateZ = s.ReadSingle();
            this.mPax = s.ReadSingle();
            this.mPby = s.ReadSingle();
            this.mPcz = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Airspeed auto-calibration"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vx",
                Description = "GPS velocity north m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vy",
                Description = "GPS velocity east m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Vz",
                Description = "GPS velocity down m/s",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiffPressure",
                Description = "Differential pressure pascals",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Eas2tas",
                Description = "Estimated to true airspeed ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ratio",
                Description = "Airspeed ratio",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StateX",
                Description = "EKF state x",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StateY",
                Description = "EKF state y",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "StateZ",
                Description = "EKF state z",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pax",
                Description = "EKF Pax",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pby",
                Description = "EKF Pby",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pcz",
                Description = "EKF Pcz",
                NumElements = 1,
            });

        }

        private float mVx;
        private float mVy;
        private float mVz;
        private float mDiffPressure;
        private float mEas2tas;
        private float mRatio;
        private float mStateX;
        private float mStateY;
        private float mStateZ;
        private float mPax;
        private float mPby;
        private float mPcz;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// A rally point. Used to set a point when from GCS -> MAV. Also used to return a point from MAV -> GCS
    /// </summary>
    public class UasRallyPoint: UasMessage
    {
        /// <summary>
        /// Latitude of point in degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude of point in degrees * 1E7
        /// </summary>
        public Int32 Lng {
            get { return mLng; }
            set { mLng = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Transit / loiter altitude in meters relative to home
        /// </summary>
        public Int16 Alt {
            get { return mAlt; }
            set { mAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Break altitude in meters relative to home
        /// </summary>
        public Int16 BreakAlt {
            get { return mBreakAlt; }
            set { mBreakAlt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Heading to aim for when landing. In centi-degrees.
        /// </summary>
        public UInt16 LandDir {
            get { return mLandDir; }
            set { mLandDir = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// point index (first point is 0)
        /// </summary>
        public byte Idx {
            get { return mIdx; }
            set { mIdx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// total number of points (for sanity checking)
        /// </summary>
        public byte Count {
            get { return mCount; }
            set { mCount = value; NotifyUpdated(); }
        }

        /// <summary>
        /// See RALLY_FLAGS enum for definition of the bitmask.
        /// </summary>
        public RallyFlags Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        public UasRallyPoint()
        {
            mMessageId = 175;
            CrcExtra = 138;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mLat);
            s.Write(mLng);
            s.Write(mAlt);
            s.Write(mBreakAlt);
            s.Write(mLandDir);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mIdx);
            s.Write(mCount);
            s.Write((byte)mFlags);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mLat = s.ReadInt32();
            this.mLng = s.ReadInt32();
            this.mAlt = s.ReadInt16();
            this.mBreakAlt = s.ReadInt16();
            this.mLandDir = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mIdx = s.ReadByte();
            this.mCount = s.ReadByte();
            this.mFlags = (RallyFlags)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "A rally point. Used to set a point when from GCS -> MAV. Also used to return a point from MAV -> GCS"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude of point in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lng",
                Description = "Longitude of point in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Alt",
                Description = "Transit / loiter altitude in meters relative to home",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "BreakAlt",
                Description = "Break altitude in meters relative to home",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "LandDir",
                Description = "Heading to aim for when landing. In centi-degrees.",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Idx",
                Description = "point index (first point is 0)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Count",
                Description = "total number of points (for sanity checking)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "See RALLY_FLAGS enum for definition of the bitmask.",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("RallyFlags"),
            });

        }

        private Int32 mLat;
        private Int32 mLng;
        private Int16 mAlt;
        private Int16 mBreakAlt;
        private UInt16 mLandDir;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mIdx;
        private byte mCount;
        private RallyFlags mFlags;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request a current rally point from MAV. MAV should respond with a RALLY_POINT message. MAV should not respond if the request is invalid.
    /// </summary>
    public class UasRallyFetchPoint: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// point index (first point is 0)
        /// </summary>
        public byte Idx {
            get { return mIdx; }
            set { mIdx = value; NotifyUpdated(); }
        }

        public UasRallyFetchPoint()
        {
            mMessageId = 176;
            CrcExtra = 234;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mIdx);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mIdx = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request a current rally point from MAV. MAV should respond with a RALLY_POINT message. MAV should not respond if the request is invalid."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Idx",
                Description = "point index (first point is 0)",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mIdx;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of compassmot calibration
    /// </summary>
    public class UasCompassmotStatus: UasMessage
    {
        /// <summary>
        /// current (amps)
        /// </summary>
        public float Current {
            get { return mCurrent; }
            set { mCurrent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Motor Compensation X
        /// </summary>
        public float Compensationx {
            get { return mCompensationx; }
            set { mCompensationx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Motor Compensation Y
        /// </summary>
        public float Compensationy {
            get { return mCompensationy; }
            set { mCompensationy = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Motor Compensation Z
        /// </summary>
        public float Compensationz {
            get { return mCompensationz; }
            set { mCompensationz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// throttle (percent*10)
        /// </summary>
        public UInt16 Throttle {
            get { return mThrottle; }
            set { mThrottle = value; NotifyUpdated(); }
        }

        /// <summary>
        /// interference (percent)
        /// </summary>
        public UInt16 Interference {
            get { return mInterference; }
            set { mInterference = value; NotifyUpdated(); }
        }

        public UasCompassmotStatus()
        {
            mMessageId = 177;
            CrcExtra = 240;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mCurrent);
            s.Write(mCompensationx);
            s.Write(mCompensationy);
            s.Write(mCompensationz);
            s.Write(mThrottle);
            s.Write(mInterference);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mCurrent = s.ReadSingle();
            this.mCompensationx = s.ReadSingle();
            this.mCompensationy = s.ReadSingle();
            this.mCompensationz = s.ReadSingle();
            this.mThrottle = s.ReadUInt16();
            this.mInterference = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of compassmot calibration"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Current",
                Description = "current (amps)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Compensationx",
                Description = "Motor Compensation X",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Compensationy",
                Description = "Motor Compensation Y",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Compensationz",
                Description = "Motor Compensation Z",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Throttle",
                Description = "throttle (percent*10)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Interference",
                Description = "interference (percent)",
                NumElements = 1,
            });

        }

        private float mCurrent;
        private float mCompensationx;
        private float mCompensationy;
        private float mCompensationz;
        private UInt16 mThrottle;
        private UInt16 mInterference;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of secondary AHRS filter if available
    /// </summary>
    public class UasAhrs2: UasMessage
    {
        /// <summary>
        /// Roll angle (rad)
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle (rad)
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle (rad)
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL)
        /// </summary>
        public float Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude in degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude in degrees * 1E7
        /// </summary>
        public Int32 Lng {
            get { return mLng; }
            set { mLng = value; NotifyUpdated(); }
        }

        public UasAhrs2()
        {
            mMessageId = 178;
            CrcExtra = 47;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mAltitude);
            s.Write(mLat);
            s.Write(mLng);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mAltitude = s.ReadSingle();
            this.mLat = s.ReadInt32();
            this.mLng = s.ReadInt32();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of secondary AHRS filter if available"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude (MSL)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lng",
                Description = "Longitude in degrees * 1E7",
                NumElements = 1,
            });

        }

        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mAltitude;
        private Int32 mLat;
        private Int32 mLng;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Camera Event
    /// </summary>
    public class UasCameraStatus: UasMessage
    {
        /// <summary>
        /// Image timestamp (microseconds since UNIX epoch, according to camera clock)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 1 (meaning depends on event, see CAMERA_STATUS_TYPES enum)
        /// </summary>
        public float P1 {
            get { return mP1; }
            set { mP1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 2 (meaning depends on event, see CAMERA_STATUS_TYPES enum)
        /// </summary>
        public float P2 {
            get { return mP2; }
            set { mP2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 3 (meaning depends on event, see CAMERA_STATUS_TYPES enum)
        /// </summary>
        public float P3 {
            get { return mP3; }
            set { mP3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Parameter 4 (meaning depends on event, see CAMERA_STATUS_TYPES enum)
        /// </summary>
        public float P4 {
            get { return mP4; }
            set { mP4 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Image index
        /// </summary>
        public UInt16 ImgIdx {
            get { return mImgIdx; }
            set { mImgIdx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Camera ID
        /// </summary>
        public byte CamIdx {
            get { return mCamIdx; }
            set { mCamIdx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// See CAMERA_STATUS_TYPES enum for definition of the bitmask
        /// </summary>
        public CameraStatusTypes EventId {
            get { return mEventId; }
            set { mEventId = value; NotifyUpdated(); }
        }

        public UasCameraStatus()
        {
            mMessageId = 179;
            CrcExtra = 189;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mP1);
            s.Write(mP2);
            s.Write(mP3);
            s.Write(mP4);
            s.Write(mImgIdx);
            s.Write(mTargetSystem);
            s.Write(mCamIdx);
            s.Write((byte)mEventId);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mP1 = s.ReadSingle();
            this.mP2 = s.ReadSingle();
            this.mP3 = s.ReadSingle();
            this.mP4 = s.ReadSingle();
            this.mImgIdx = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mCamIdx = s.ReadByte();
            this.mEventId = (CameraStatusTypes)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Camera Event"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Image timestamp (microseconds since UNIX epoch, according to camera clock)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P1",
                Description = "Parameter 1 (meaning depends on event, see CAMERA_STATUS_TYPES enum)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P2",
                Description = "Parameter 2 (meaning depends on event, see CAMERA_STATUS_TYPES enum)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P3",
                Description = "Parameter 3 (meaning depends on event, see CAMERA_STATUS_TYPES enum)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P4",
                Description = "Parameter 4 (meaning depends on event, see CAMERA_STATUS_TYPES enum)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ImgIdx",
                Description = "Image index",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CamIdx",
                Description = "Camera ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "EventId",
                Description = "See CAMERA_STATUS_TYPES enum for definition of the bitmask",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("CameraStatusTypes"),
            });

        }

        private UInt64 mTimeUsec;
        private float mP1;
        private float mP2;
        private float mP3;
        private float mP4;
        private UInt16 mImgIdx;
        private byte mTargetSystem;
        private byte mCamIdx;
        private CameraStatusTypes mEventId;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Camera Capture Feedback
    /// </summary>
    public class UasCameraFeedback: UasMessage
    {
        /// <summary>
        /// Image timestamp (microseconds since UNIX epoch), as passed in by CAMERA_STATUS message (or autopilot if no CCB)
        /// </summary>
        public UInt64 TimeUsec {
            get { return mTimeUsec; }
            set { mTimeUsec = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude in (deg * 1E7)
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude in (deg * 1E7)
        /// </summary>
        public Int32 Lng {
            get { return mLng; }
            set { mLng = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude Absolute (meters AMSL)
        /// </summary>
        public float AltMsl {
            get { return mAltMsl; }
            set { mAltMsl = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude Relative (meters above HOME location)
        /// </summary>
        public float AltRel {
            get { return mAltRel; }
            set { mAltRel = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Camera Roll angle (earth frame, degrees, +-180)
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Camera Pitch angle (earth frame, degrees, +-180)
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Camera Yaw (earth frame, degrees, 0-360, true)
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Focal Length (mm)
        /// </summary>
        public float FocLen {
            get { return mFocLen; }
            set { mFocLen = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Image index
        /// </summary>
        public UInt16 ImgIdx {
            get { return mImgIdx; }
            set { mImgIdx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Camera ID
        /// </summary>
        public byte CamIdx {
            get { return mCamIdx; }
            set { mCamIdx = value; NotifyUpdated(); }
        }

        /// <summary>
        /// See CAMERA_FEEDBACK_FLAGS enum for definition of the bitmask
        /// </summary>
        public CameraFeedbackFlags Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        public UasCameraFeedback()
        {
            mMessageId = 180;
            CrcExtra = 52;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTimeUsec);
            s.Write(mLat);
            s.Write(mLng);
            s.Write(mAltMsl);
            s.Write(mAltRel);
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mFocLen);
            s.Write(mImgIdx);
            s.Write(mTargetSystem);
            s.Write(mCamIdx);
            s.Write((byte)mFlags);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTimeUsec = s.ReadUInt64();
            this.mLat = s.ReadInt32();
            this.mLng = s.ReadInt32();
            this.mAltMsl = s.ReadSingle();
            this.mAltRel = s.ReadSingle();
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mFocLen = s.ReadSingle();
            this.mImgIdx = s.ReadUInt16();
            this.mTargetSystem = s.ReadByte();
            this.mCamIdx = s.ReadByte();
            this.mFlags = (CameraFeedbackFlags)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Camera Capture Feedback"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TimeUsec",
                Description = "Image timestamp (microseconds since UNIX epoch), as passed in by CAMERA_STATUS message (or autopilot if no CCB)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude in (deg * 1E7)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lng",
                Description = "Longitude in (deg * 1E7)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltMsl",
                Description = "Altitude Absolute (meters AMSL)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AltRel",
                Description = "Altitude Relative (meters above HOME location)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Camera Roll angle (earth frame, degrees, +-180)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Camera Pitch angle (earth frame, degrees, +-180)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Camera Yaw (earth frame, degrees, 0-360, true)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "FocLen",
                Description = "Focal Length (mm)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ImgIdx",
                Description = "Image index",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CamIdx",
                Description = "Camera ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "See CAMERA_FEEDBACK_FLAGS enum for definition of the bitmask",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("CameraFeedbackFlags"),
            });

        }

        private UInt64 mTimeUsec;
        private Int32 mLat;
        private Int32 mLng;
        private float mAltMsl;
        private float mAltRel;
        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mFocLen;
        private UInt16 mImgIdx;
        private byte mTargetSystem;
        private byte mCamIdx;
        private CameraFeedbackFlags mFlags;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// 2nd Battery status
    /// </summary>
    public class UasBattery2: UasMessage
    {
        /// <summary>
        /// voltage in millivolts
        /// </summary>
        public UInt16 Voltage {
            get { return mVoltage; }
            set { mVoltage = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current
        /// </summary>
        public Int16 CurrentBattery {
            get { return mCurrentBattery; }
            set { mCurrentBattery = value; NotifyUpdated(); }
        }

        public UasBattery2()
        {
            mMessageId = 181;
            CrcExtra = 174;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mVoltage);
            s.Write(mCurrentBattery);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mVoltage = s.ReadUInt16();
            this.mCurrentBattery = s.ReadInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "2nd Battery status"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Voltage",
                Description = "voltage in millivolts",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CurrentBattery",
                Description = "Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current",
                NumElements = 1,
            });

        }

        private UInt16 mVoltage;
        private Int16 mCurrentBattery;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Status of third AHRS filter if available. This is for ANU research group (Ali and Sean)
    /// </summary>
    public class UasAhrs3: UasMessage
    {
        /// <summary>
        /// Roll angle (rad)
        /// </summary>
        public float Roll {
            get { return mRoll; }
            set { mRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pitch angle (rad)
        /// </summary>
        public float Pitch {
            get { return mPitch; }
            set { mPitch = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Yaw angle (rad)
        /// </summary>
        public float Yaw {
            get { return mYaw; }
            set { mYaw = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Altitude (MSL)
        /// </summary>
        public float Altitude {
            get { return mAltitude; }
            set { mAltitude = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Latitude in degrees * 1E7
        /// </summary>
        public Int32 Lat {
            get { return mLat; }
            set { mLat = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Longitude in degrees * 1E7
        /// </summary>
        public Int32 Lng {
            get { return mLng; }
            set { mLng = value; NotifyUpdated(); }
        }

        /// <summary>
        /// test variable1
        /// </summary>
        public float V1 {
            get { return mV1; }
            set { mV1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// test variable2
        /// </summary>
        public float V2 {
            get { return mV2; }
            set { mV2 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// test variable3
        /// </summary>
        public float V3 {
            get { return mV3; }
            set { mV3 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// test variable4
        /// </summary>
        public float V4 {
            get { return mV4; }
            set { mV4 = value; NotifyUpdated(); }
        }

        public UasAhrs3()
        {
            mMessageId = 182;
            CrcExtra = 229;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mRoll);
            s.Write(mPitch);
            s.Write(mYaw);
            s.Write(mAltitude);
            s.Write(mLat);
            s.Write(mLng);
            s.Write(mV1);
            s.Write(mV2);
            s.Write(mV3);
            s.Write(mV4);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mRoll = s.ReadSingle();
            this.mPitch = s.ReadSingle();
            this.mYaw = s.ReadSingle();
            this.mAltitude = s.ReadSingle();
            this.mLat = s.ReadInt32();
            this.mLng = s.ReadInt32();
            this.mV1 = s.ReadSingle();
            this.mV2 = s.ReadSingle();
            this.mV3 = s.ReadSingle();
            this.mV4 = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Status of third AHRS filter if available. This is for ANU research group (Ali and Sean)"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Roll",
                Description = "Roll angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pitch",
                Description = "Pitch angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Yaw",
                Description = "Yaw angle (rad)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Altitude",
                Description = "Altitude (MSL)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lat",
                Description = "Latitude in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Lng",
                Description = "Longitude in degrees * 1E7",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "V1",
                Description = "test variable1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "V2",
                Description = "test variable2",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "V3",
                Description = "test variable3",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "V4",
                Description = "test variable4",
                NumElements = 1,
            });

        }

        private float mRoll;
        private float mPitch;
        private float mYaw;
        private float mAltitude;
        private Int32 mLat;
        private Int32 mLng;
        private float mV1;
        private float mV2;
        private float mV3;
        private float mV4;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request the autopilot version from the system/component.
    /// </summary>
    public class UasAutopilotVersionRequest: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasAutopilotVersionRequest()
        {
            mMessageId = 183;
            CrcExtra = 85;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request the autopilot version from the system/component."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send a block of log data to remote location
    /// </summary>
    public class UasRemoteLogDataBlock: UasMessage
    {
        /// <summary>
        /// log data block sequence number
        /// </summary>
        public UInt32 Seqno {
            get { return mSeqno; }
            set { mSeqno = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// log data block
        /// </summary>
        public byte[] Data {
            get { return mData; }
            set { mData = value; NotifyUpdated(); }
        }

        public UasRemoteLogDataBlock()
        {
            mMessageId = 184;
            CrcExtra = 159;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mSeqno);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mData[0]); 
            s.Write(mData[1]); 
            s.Write(mData[2]); 
            s.Write(mData[3]); 
            s.Write(mData[4]); 
            s.Write(mData[5]); 
            s.Write(mData[6]); 
            s.Write(mData[7]); 
            s.Write(mData[8]); 
            s.Write(mData[9]); 
            s.Write(mData[10]); 
            s.Write(mData[11]); 
            s.Write(mData[12]); 
            s.Write(mData[13]); 
            s.Write(mData[14]); 
            s.Write(mData[15]); 
            s.Write(mData[16]); 
            s.Write(mData[17]); 
            s.Write(mData[18]); 
            s.Write(mData[19]); 
            s.Write(mData[20]); 
            s.Write(mData[21]); 
            s.Write(mData[22]); 
            s.Write(mData[23]); 
            s.Write(mData[24]); 
            s.Write(mData[25]); 
            s.Write(mData[26]); 
            s.Write(mData[27]); 
            s.Write(mData[28]); 
            s.Write(mData[29]); 
            s.Write(mData[30]); 
            s.Write(mData[31]); 
            s.Write(mData[32]); 
            s.Write(mData[33]); 
            s.Write(mData[34]); 
            s.Write(mData[35]); 
            s.Write(mData[36]); 
            s.Write(mData[37]); 
            s.Write(mData[38]); 
            s.Write(mData[39]); 
            s.Write(mData[40]); 
            s.Write(mData[41]); 
            s.Write(mData[42]); 
            s.Write(mData[43]); 
            s.Write(mData[44]); 
            s.Write(mData[45]); 
            s.Write(mData[46]); 
            s.Write(mData[47]); 
            s.Write(mData[48]); 
            s.Write(mData[49]); 
            s.Write(mData[50]); 
            s.Write(mData[51]); 
            s.Write(mData[52]); 
            s.Write(mData[53]); 
            s.Write(mData[54]); 
            s.Write(mData[55]); 
            s.Write(mData[56]); 
            s.Write(mData[57]); 
            s.Write(mData[58]); 
            s.Write(mData[59]); 
            s.Write(mData[60]); 
            s.Write(mData[61]); 
            s.Write(mData[62]); 
            s.Write(mData[63]); 
            s.Write(mData[64]); 
            s.Write(mData[65]); 
            s.Write(mData[66]); 
            s.Write(mData[67]); 
            s.Write(mData[68]); 
            s.Write(mData[69]); 
            s.Write(mData[70]); 
            s.Write(mData[71]); 
            s.Write(mData[72]); 
            s.Write(mData[73]); 
            s.Write(mData[74]); 
            s.Write(mData[75]); 
            s.Write(mData[76]); 
            s.Write(mData[77]); 
            s.Write(mData[78]); 
            s.Write(mData[79]); 
            s.Write(mData[80]); 
            s.Write(mData[81]); 
            s.Write(mData[82]); 
            s.Write(mData[83]); 
            s.Write(mData[84]); 
            s.Write(mData[85]); 
            s.Write(mData[86]); 
            s.Write(mData[87]); 
            s.Write(mData[88]); 
            s.Write(mData[89]); 
            s.Write(mData[90]); 
            s.Write(mData[91]); 
            s.Write(mData[92]); 
            s.Write(mData[93]); 
            s.Write(mData[94]); 
            s.Write(mData[95]); 
            s.Write(mData[96]); 
            s.Write(mData[97]); 
            s.Write(mData[98]); 
            s.Write(mData[99]); 
            s.Write(mData[100]); 
            s.Write(mData[101]); 
            s.Write(mData[102]); 
            s.Write(mData[103]); 
            s.Write(mData[104]); 
            s.Write(mData[105]); 
            s.Write(mData[106]); 
            s.Write(mData[107]); 
            s.Write(mData[108]); 
            s.Write(mData[109]); 
            s.Write(mData[110]); 
            s.Write(mData[111]); 
            s.Write(mData[112]); 
            s.Write(mData[113]); 
            s.Write(mData[114]); 
            s.Write(mData[115]); 
            s.Write(mData[116]); 
            s.Write(mData[117]); 
            s.Write(mData[118]); 
            s.Write(mData[119]); 
            s.Write(mData[120]); 
            s.Write(mData[121]); 
            s.Write(mData[122]); 
            s.Write(mData[123]); 
            s.Write(mData[124]); 
            s.Write(mData[125]); 
            s.Write(mData[126]); 
            s.Write(mData[127]); 
            s.Write(mData[128]); 
            s.Write(mData[129]); 
            s.Write(mData[130]); 
            s.Write(mData[131]); 
            s.Write(mData[132]); 
            s.Write(mData[133]); 
            s.Write(mData[134]); 
            s.Write(mData[135]); 
            s.Write(mData[136]); 
            s.Write(mData[137]); 
            s.Write(mData[138]); 
            s.Write(mData[139]); 
            s.Write(mData[140]); 
            s.Write(mData[141]); 
            s.Write(mData[142]); 
            s.Write(mData[143]); 
            s.Write(mData[144]); 
            s.Write(mData[145]); 
            s.Write(mData[146]); 
            s.Write(mData[147]); 
            s.Write(mData[148]); 
            s.Write(mData[149]); 
            s.Write(mData[150]); 
            s.Write(mData[151]); 
            s.Write(mData[152]); 
            s.Write(mData[153]); 
            s.Write(mData[154]); 
            s.Write(mData[155]); 
            s.Write(mData[156]); 
            s.Write(mData[157]); 
            s.Write(mData[158]); 
            s.Write(mData[159]); 
            s.Write(mData[160]); 
            s.Write(mData[161]); 
            s.Write(mData[162]); 
            s.Write(mData[163]); 
            s.Write(mData[164]); 
            s.Write(mData[165]); 
            s.Write(mData[166]); 
            s.Write(mData[167]); 
            s.Write(mData[168]); 
            s.Write(mData[169]); 
            s.Write(mData[170]); 
            s.Write(mData[171]); 
            s.Write(mData[172]); 
            s.Write(mData[173]); 
            s.Write(mData[174]); 
            s.Write(mData[175]); 
            s.Write(mData[176]); 
            s.Write(mData[177]); 
            s.Write(mData[178]); 
            s.Write(mData[179]); 
            s.Write(mData[180]); 
            s.Write(mData[181]); 
            s.Write(mData[182]); 
            s.Write(mData[183]); 
            s.Write(mData[184]); 
            s.Write(mData[185]); 
            s.Write(mData[186]); 
            s.Write(mData[187]); 
            s.Write(mData[188]); 
            s.Write(mData[189]); 
            s.Write(mData[190]); 
            s.Write(mData[191]); 
            s.Write(mData[192]); 
            s.Write(mData[193]); 
            s.Write(mData[194]); 
            s.Write(mData[195]); 
            s.Write(mData[196]); 
            s.Write(mData[197]); 
            s.Write(mData[198]); 
            s.Write(mData[199]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSeqno = s.ReadUInt32();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mData[0] = s.ReadByte();
            this.mData[1] = s.ReadByte();
            this.mData[2] = s.ReadByte();
            this.mData[3] = s.ReadByte();
            this.mData[4] = s.ReadByte();
            this.mData[5] = s.ReadByte();
            this.mData[6] = s.ReadByte();
            this.mData[7] = s.ReadByte();
            this.mData[8] = s.ReadByte();
            this.mData[9] = s.ReadByte();
            this.mData[10] = s.ReadByte();
            this.mData[11] = s.ReadByte();
            this.mData[12] = s.ReadByte();
            this.mData[13] = s.ReadByte();
            this.mData[14] = s.ReadByte();
            this.mData[15] = s.ReadByte();
            this.mData[16] = s.ReadByte();
            this.mData[17] = s.ReadByte();
            this.mData[18] = s.ReadByte();
            this.mData[19] = s.ReadByte();
            this.mData[20] = s.ReadByte();
            this.mData[21] = s.ReadByte();
            this.mData[22] = s.ReadByte();
            this.mData[23] = s.ReadByte();
            this.mData[24] = s.ReadByte();
            this.mData[25] = s.ReadByte();
            this.mData[26] = s.ReadByte();
            this.mData[27] = s.ReadByte();
            this.mData[28] = s.ReadByte();
            this.mData[29] = s.ReadByte();
            this.mData[30] = s.ReadByte();
            this.mData[31] = s.ReadByte();
            this.mData[32] = s.ReadByte();
            this.mData[33] = s.ReadByte();
            this.mData[34] = s.ReadByte();
            this.mData[35] = s.ReadByte();
            this.mData[36] = s.ReadByte();
            this.mData[37] = s.ReadByte();
            this.mData[38] = s.ReadByte();
            this.mData[39] = s.ReadByte();
            this.mData[40] = s.ReadByte();
            this.mData[41] = s.ReadByte();
            this.mData[42] = s.ReadByte();
            this.mData[43] = s.ReadByte();
            this.mData[44] = s.ReadByte();
            this.mData[45] = s.ReadByte();
            this.mData[46] = s.ReadByte();
            this.mData[47] = s.ReadByte();
            this.mData[48] = s.ReadByte();
            this.mData[49] = s.ReadByte();
            this.mData[50] = s.ReadByte();
            this.mData[51] = s.ReadByte();
            this.mData[52] = s.ReadByte();
            this.mData[53] = s.ReadByte();
            this.mData[54] = s.ReadByte();
            this.mData[55] = s.ReadByte();
            this.mData[56] = s.ReadByte();
            this.mData[57] = s.ReadByte();
            this.mData[58] = s.ReadByte();
            this.mData[59] = s.ReadByte();
            this.mData[60] = s.ReadByte();
            this.mData[61] = s.ReadByte();
            this.mData[62] = s.ReadByte();
            this.mData[63] = s.ReadByte();
            this.mData[64] = s.ReadByte();
            this.mData[65] = s.ReadByte();
            this.mData[66] = s.ReadByte();
            this.mData[67] = s.ReadByte();
            this.mData[68] = s.ReadByte();
            this.mData[69] = s.ReadByte();
            this.mData[70] = s.ReadByte();
            this.mData[71] = s.ReadByte();
            this.mData[72] = s.ReadByte();
            this.mData[73] = s.ReadByte();
            this.mData[74] = s.ReadByte();
            this.mData[75] = s.ReadByte();
            this.mData[76] = s.ReadByte();
            this.mData[77] = s.ReadByte();
            this.mData[78] = s.ReadByte();
            this.mData[79] = s.ReadByte();
            this.mData[80] = s.ReadByte();
            this.mData[81] = s.ReadByte();
            this.mData[82] = s.ReadByte();
            this.mData[83] = s.ReadByte();
            this.mData[84] = s.ReadByte();
            this.mData[85] = s.ReadByte();
            this.mData[86] = s.ReadByte();
            this.mData[87] = s.ReadByte();
            this.mData[88] = s.ReadByte();
            this.mData[89] = s.ReadByte();
            this.mData[90] = s.ReadByte();
            this.mData[91] = s.ReadByte();
            this.mData[92] = s.ReadByte();
            this.mData[93] = s.ReadByte();
            this.mData[94] = s.ReadByte();
            this.mData[95] = s.ReadByte();
            this.mData[96] = s.ReadByte();
            this.mData[97] = s.ReadByte();
            this.mData[98] = s.ReadByte();
            this.mData[99] = s.ReadByte();
            this.mData[100] = s.ReadByte();
            this.mData[101] = s.ReadByte();
            this.mData[102] = s.ReadByte();
            this.mData[103] = s.ReadByte();
            this.mData[104] = s.ReadByte();
            this.mData[105] = s.ReadByte();
            this.mData[106] = s.ReadByte();
            this.mData[107] = s.ReadByte();
            this.mData[108] = s.ReadByte();
            this.mData[109] = s.ReadByte();
            this.mData[110] = s.ReadByte();
            this.mData[111] = s.ReadByte();
            this.mData[112] = s.ReadByte();
            this.mData[113] = s.ReadByte();
            this.mData[114] = s.ReadByte();
            this.mData[115] = s.ReadByte();
            this.mData[116] = s.ReadByte();
            this.mData[117] = s.ReadByte();
            this.mData[118] = s.ReadByte();
            this.mData[119] = s.ReadByte();
            this.mData[120] = s.ReadByte();
            this.mData[121] = s.ReadByte();
            this.mData[122] = s.ReadByte();
            this.mData[123] = s.ReadByte();
            this.mData[124] = s.ReadByte();
            this.mData[125] = s.ReadByte();
            this.mData[126] = s.ReadByte();
            this.mData[127] = s.ReadByte();
            this.mData[128] = s.ReadByte();
            this.mData[129] = s.ReadByte();
            this.mData[130] = s.ReadByte();
            this.mData[131] = s.ReadByte();
            this.mData[132] = s.ReadByte();
            this.mData[133] = s.ReadByte();
            this.mData[134] = s.ReadByte();
            this.mData[135] = s.ReadByte();
            this.mData[136] = s.ReadByte();
            this.mData[137] = s.ReadByte();
            this.mData[138] = s.ReadByte();
            this.mData[139] = s.ReadByte();
            this.mData[140] = s.ReadByte();
            this.mData[141] = s.ReadByte();
            this.mData[142] = s.ReadByte();
            this.mData[143] = s.ReadByte();
            this.mData[144] = s.ReadByte();
            this.mData[145] = s.ReadByte();
            this.mData[146] = s.ReadByte();
            this.mData[147] = s.ReadByte();
            this.mData[148] = s.ReadByte();
            this.mData[149] = s.ReadByte();
            this.mData[150] = s.ReadByte();
            this.mData[151] = s.ReadByte();
            this.mData[152] = s.ReadByte();
            this.mData[153] = s.ReadByte();
            this.mData[154] = s.ReadByte();
            this.mData[155] = s.ReadByte();
            this.mData[156] = s.ReadByte();
            this.mData[157] = s.ReadByte();
            this.mData[158] = s.ReadByte();
            this.mData[159] = s.ReadByte();
            this.mData[160] = s.ReadByte();
            this.mData[161] = s.ReadByte();
            this.mData[162] = s.ReadByte();
            this.mData[163] = s.ReadByte();
            this.mData[164] = s.ReadByte();
            this.mData[165] = s.ReadByte();
            this.mData[166] = s.ReadByte();
            this.mData[167] = s.ReadByte();
            this.mData[168] = s.ReadByte();
            this.mData[169] = s.ReadByte();
            this.mData[170] = s.ReadByte();
            this.mData[171] = s.ReadByte();
            this.mData[172] = s.ReadByte();
            this.mData[173] = s.ReadByte();
            this.mData[174] = s.ReadByte();
            this.mData[175] = s.ReadByte();
            this.mData[176] = s.ReadByte();
            this.mData[177] = s.ReadByte();
            this.mData[178] = s.ReadByte();
            this.mData[179] = s.ReadByte();
            this.mData[180] = s.ReadByte();
            this.mData[181] = s.ReadByte();
            this.mData[182] = s.ReadByte();
            this.mData[183] = s.ReadByte();
            this.mData[184] = s.ReadByte();
            this.mData[185] = s.ReadByte();
            this.mData[186] = s.ReadByte();
            this.mData[187] = s.ReadByte();
            this.mData[188] = s.ReadByte();
            this.mData[189] = s.ReadByte();
            this.mData[190] = s.ReadByte();
            this.mData[191] = s.ReadByte();
            this.mData[192] = s.ReadByte();
            this.mData[193] = s.ReadByte();
            this.mData[194] = s.ReadByte();
            this.mData[195] = s.ReadByte();
            this.mData[196] = s.ReadByte();
            this.mData[197] = s.ReadByte();
            this.mData[198] = s.ReadByte();
            this.mData[199] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send a block of log data to remote location"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seqno",
                Description = "log data block sequence number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Data",
                Description = "log data block",
                NumElements = 200,
            });

        }

        private UInt32 mSeqno;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte[] mData = new byte[200];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Send Status of each log block that autopilot board might have sent
    /// </summary>
    public class UasRemoteLogBlockStatus: UasMessage
    {
        /// <summary>
        /// log data block sequence number
        /// </summary>
        public UInt32 Seqno {
            get { return mSeqno; }
            set { mSeqno = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// log data block status
        /// </summary>
        public byte Status {
            get { return mStatus; }
            set { mStatus = value; NotifyUpdated(); }
        }

        public UasRemoteLogBlockStatus()
        {
            mMessageId = 185;
            CrcExtra = 186;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mSeqno);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mStatus);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mSeqno = s.ReadUInt32();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mStatus = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Send Status of each log block that autopilot board might have sent"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Seqno",
                Description = "log data block sequence number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Status",
                Description = "log data block status",
                NumElements = 1,
            });

        }

        private UInt32 mSeqno;
        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mStatus;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Control vehicle LEDs
    /// </summary>
    public class UasLedControl: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Instance (LED instance to control or 255 for all LEDs)
        /// </summary>
        public byte Instance {
            get { return mInstance; }
            set { mInstance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Pattern (see LED_PATTERN_ENUM)
        /// </summary>
        public byte Pattern {
            get { return mPattern; }
            set { mPattern = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Custom Byte Length
        /// </summary>
        public byte CustomLen {
            get { return mCustomLen; }
            set { mCustomLen = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Custom Bytes
        /// </summary>
        public byte[] CustomBytes {
            get { return mCustomBytes; }
            set { mCustomBytes = value; NotifyUpdated(); }
        }

        public UasLedControl()
        {
            mMessageId = 186;
            CrcExtra = 72;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mInstance);
            s.Write(mPattern);
            s.Write(mCustomLen);
            s.Write(mCustomBytes[0]); 
            s.Write(mCustomBytes[1]); 
            s.Write(mCustomBytes[2]); 
            s.Write(mCustomBytes[3]); 
            s.Write(mCustomBytes[4]); 
            s.Write(mCustomBytes[5]); 
            s.Write(mCustomBytes[6]); 
            s.Write(mCustomBytes[7]); 
            s.Write(mCustomBytes[8]); 
            s.Write(mCustomBytes[9]); 
            s.Write(mCustomBytes[10]); 
            s.Write(mCustomBytes[11]); 
            s.Write(mCustomBytes[12]); 
            s.Write(mCustomBytes[13]); 
            s.Write(mCustomBytes[14]); 
            s.Write(mCustomBytes[15]); 
            s.Write(mCustomBytes[16]); 
            s.Write(mCustomBytes[17]); 
            s.Write(mCustomBytes[18]); 
            s.Write(mCustomBytes[19]); 
            s.Write(mCustomBytes[20]); 
            s.Write(mCustomBytes[21]); 
            s.Write(mCustomBytes[22]); 
            s.Write(mCustomBytes[23]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mInstance = s.ReadByte();
            this.mPattern = s.ReadByte();
            this.mCustomLen = s.ReadByte();
            this.mCustomBytes[0] = s.ReadByte();
            this.mCustomBytes[1] = s.ReadByte();
            this.mCustomBytes[2] = s.ReadByte();
            this.mCustomBytes[3] = s.ReadByte();
            this.mCustomBytes[4] = s.ReadByte();
            this.mCustomBytes[5] = s.ReadByte();
            this.mCustomBytes[6] = s.ReadByte();
            this.mCustomBytes[7] = s.ReadByte();
            this.mCustomBytes[8] = s.ReadByte();
            this.mCustomBytes[9] = s.ReadByte();
            this.mCustomBytes[10] = s.ReadByte();
            this.mCustomBytes[11] = s.ReadByte();
            this.mCustomBytes[12] = s.ReadByte();
            this.mCustomBytes[13] = s.ReadByte();
            this.mCustomBytes[14] = s.ReadByte();
            this.mCustomBytes[15] = s.ReadByte();
            this.mCustomBytes[16] = s.ReadByte();
            this.mCustomBytes[17] = s.ReadByte();
            this.mCustomBytes[18] = s.ReadByte();
            this.mCustomBytes[19] = s.ReadByte();
            this.mCustomBytes[20] = s.ReadByte();
            this.mCustomBytes[21] = s.ReadByte();
            this.mCustomBytes[22] = s.ReadByte();
            this.mCustomBytes[23] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Control vehicle LEDs"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Instance",
                Description = "Instance (LED instance to control or 255 for all LEDs)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Pattern",
                Description = "Pattern (see LED_PATTERN_ENUM)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CustomLen",
                Description = "Custom Byte Length",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CustomBytes",
                Description = "Custom Bytes",
                NumElements = 24,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mInstance;
        private byte mPattern;
        private byte mCustomLen;
        private byte[] mCustomBytes = new byte[24];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reports progress of compass calibration.
    /// </summary>
    public class UasMagCalProgress: UasMessage
    {
        /// <summary>
        /// Body frame direction vector for display
        /// </summary>
        public float DirectionX {
            get { return mDirectionX; }
            set { mDirectionX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame direction vector for display
        /// </summary>
        public float DirectionY {
            get { return mDirectionY; }
            set { mDirectionY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Body frame direction vector for display
        /// </summary>
        public float DirectionZ {
            get { return mDirectionZ; }
            set { mDirectionZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Compass being calibrated
        /// </summary>
        public byte CompassId {
            get { return mCompassId; }
            set { mCompassId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask of compasses being calibrated
        /// </summary>
        public byte CalMask {
            get { return mCalMask; }
            set { mCalMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Status (see MAG_CAL_STATUS enum)
        /// </summary>
        public MagCalStatus CalStatus {
            get { return mCalStatus; }
            set { mCalStatus = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Attempt number
        /// </summary>
        public byte Attempt {
            get { return mAttempt; }
            set { mAttempt = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Completion percentage
        /// </summary>
        public byte CompletionPct {
            get { return mCompletionPct; }
            set { mCompletionPct = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask of sphere sections (see http://en.wikipedia.org/wiki/Geodesic_grid)
        /// </summary>
        public byte[] CompletionMask {
            get { return mCompletionMask; }
            set { mCompletionMask = value; NotifyUpdated(); }
        }

        public UasMagCalProgress()
        {
            mMessageId = 191;
            CrcExtra = 92;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mDirectionX);
            s.Write(mDirectionY);
            s.Write(mDirectionZ);
            s.Write(mCompassId);
            s.Write(mCalMask);
            s.Write((byte)mCalStatus);
            s.Write(mAttempt);
            s.Write(mCompletionPct);
            s.Write(mCompletionMask[0]); 
            s.Write(mCompletionMask[1]); 
            s.Write(mCompletionMask[2]); 
            s.Write(mCompletionMask[3]); 
            s.Write(mCompletionMask[4]); 
            s.Write(mCompletionMask[5]); 
            s.Write(mCompletionMask[6]); 
            s.Write(mCompletionMask[7]); 
            s.Write(mCompletionMask[8]); 
            s.Write(mCompletionMask[9]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mDirectionX = s.ReadSingle();
            this.mDirectionY = s.ReadSingle();
            this.mDirectionZ = s.ReadSingle();
            this.mCompassId = s.ReadByte();
            this.mCalMask = s.ReadByte();
            this.mCalStatus = (MagCalStatus)s.ReadByte();
            this.mAttempt = s.ReadByte();
            this.mCompletionPct = s.ReadByte();
            this.mCompletionMask[0] = s.ReadByte();
            this.mCompletionMask[1] = s.ReadByte();
            this.mCompletionMask[2] = s.ReadByte();
            this.mCompletionMask[3] = s.ReadByte();
            this.mCompletionMask[4] = s.ReadByte();
            this.mCompletionMask[5] = s.ReadByte();
            this.mCompletionMask[6] = s.ReadByte();
            this.mCompletionMask[7] = s.ReadByte();
            this.mCompletionMask[8] = s.ReadByte();
            this.mCompletionMask[9] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reports progress of compass calibration."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DirectionX",
                Description = "Body frame direction vector for display",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DirectionY",
                Description = "Body frame direction vector for display",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DirectionZ",
                Description = "Body frame direction vector for display",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CompassId",
                Description = "Compass being calibrated",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CalMask",
                Description = "Bitmask of compasses being calibrated",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CalStatus",
                Description = "Status (see MAG_CAL_STATUS enum)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MagCalStatus"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Attempt",
                Description = "Attempt number",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CompletionPct",
                Description = "Completion percentage",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CompletionMask",
                Description = "Bitmask of sphere sections (see http://en.wikipedia.org/wiki/Geodesic_grid)",
                NumElements = 10,
            });

        }

        private float mDirectionX;
        private float mDirectionY;
        private float mDirectionZ;
        private byte mCompassId;
        private byte mCalMask;
        private MagCalStatus mCalStatus;
        private byte mAttempt;
        private byte mCompletionPct;
        private byte[] mCompletionMask = new byte[10];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Reports results of completed compass calibration. Sent until MAG_CAL_ACK received.
    /// </summary>
    public class UasMagCalReport: UasMessage
    {
        /// <summary>
        /// RMS milligauss residuals
        /// </summary>
        public float Fitness {
            get { return mFitness; }
            set { mFitness = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X offset
        /// </summary>
        public float OfsX {
            get { return mOfsX; }
            set { mOfsX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y offset
        /// </summary>
        public float OfsY {
            get { return mOfsY; }
            set { mOfsY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z offset
        /// </summary>
        public float OfsZ {
            get { return mOfsZ; }
            set { mOfsZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X diagonal (matrix 11)
        /// </summary>
        public float DiagX {
            get { return mDiagX; }
            set { mDiagX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y diagonal (matrix 22)
        /// </summary>
        public float DiagY {
            get { return mDiagY; }
            set { mDiagY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z diagonal (matrix 33)
        /// </summary>
        public float DiagZ {
            get { return mDiagZ; }
            set { mDiagZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// X off-diagonal (matrix 12 and 21)
        /// </summary>
        public float OffdiagX {
            get { return mOffdiagX; }
            set { mOffdiagX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Y off-diagonal (matrix 13 and 31)
        /// </summary>
        public float OffdiagY {
            get { return mOffdiagY; }
            set { mOffdiagY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Z off-diagonal (matrix 32 and 23)
        /// </summary>
        public float OffdiagZ {
            get { return mOffdiagZ; }
            set { mOffdiagZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Compass being calibrated
        /// </summary>
        public byte CompassId {
            get { return mCompassId; }
            set { mCompassId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Bitmask of compasses being calibrated
        /// </summary>
        public byte CalMask {
            get { return mCalMask; }
            set { mCalMask = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Status (see MAG_CAL_STATUS enum)
        /// </summary>
        public MagCalStatus CalStatus {
            get { return mCalStatus; }
            set { mCalStatus = value; NotifyUpdated(); }
        }

        /// <summary>
        /// 0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters
        /// </summary>
        public MavCmd Autosaved {
            get { return mAutosaved; }
            set { mAutosaved = value; NotifyUpdated(); }
        }

        public UasMagCalReport()
        {
            mMessageId = 192;
            CrcExtra = 36;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mFitness);
            s.Write(mOfsX);
            s.Write(mOfsY);
            s.Write(mOfsZ);
            s.Write(mDiagX);
            s.Write(mDiagY);
            s.Write(mDiagZ);
            s.Write(mOffdiagX);
            s.Write(mOffdiagY);
            s.Write(mOffdiagZ);
            s.Write(mCompassId);
            s.Write(mCalMask);
            s.Write((byte)mCalStatus);
            s.Write((byte)mAutosaved);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mFitness = s.ReadSingle();
            this.mOfsX = s.ReadSingle();
            this.mOfsY = s.ReadSingle();
            this.mOfsZ = s.ReadSingle();
            this.mDiagX = s.ReadSingle();
            this.mDiagY = s.ReadSingle();
            this.mDiagZ = s.ReadSingle();
            this.mOffdiagX = s.ReadSingle();
            this.mOffdiagY = s.ReadSingle();
            this.mOffdiagZ = s.ReadSingle();
            this.mCompassId = s.ReadByte();
            this.mCalMask = s.ReadByte();
            this.mCalStatus = (MagCalStatus)s.ReadByte();
            this.mAutosaved = (MavCmd)s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Reports results of completed compass calibration. Sent until MAG_CAL_ACK received."
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Fitness",
                Description = "RMS milligauss residuals",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OfsX",
                Description = "X offset",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OfsY",
                Description = "Y offset",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OfsZ",
                Description = "Z offset",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiagX",
                Description = "X diagonal (matrix 11)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiagY",
                Description = "Y diagonal (matrix 22)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DiagZ",
                Description = "Z diagonal (matrix 33)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OffdiagX",
                Description = "X off-diagonal (matrix 12 and 21)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OffdiagY",
                Description = "Y off-diagonal (matrix 13 and 31)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "OffdiagZ",
                Description = "Z off-diagonal (matrix 32 and 23)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CompassId",
                Description = "Compass being calibrated",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CalMask",
                Description = "Bitmask of compasses being calibrated",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CalStatus",
                Description = "Status (see MAG_CAL_STATUS enum)",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MagCalStatus"),
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Autosaved",
                Description = "0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters",
                NumElements = 1,
                EnumMetadata = UasSummary.GetEnumMetadata("MavCmd"),
            });

        }

        private float mFitness;
        private float mOfsX;
        private float mOfsY;
        private float mOfsZ;
        private float mDiagX;
        private float mDiagY;
        private float mDiagZ;
        private float mOffdiagX;
        private float mOffdiagY;
        private float mOffdiagZ;
        private byte mCompassId;
        private byte mCalMask;
        private MagCalStatus mCalStatus;
        private MavCmd mAutosaved;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// EKF Status message including flags and variances
    /// </summary>
    public class UasEkfStatusReport: UasMessage
    {
        /// <summary>
        /// Velocity variance
        /// </summary>
        public float VelocityVariance {
            get { return mVelocityVariance; }
            set { mVelocityVariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Horizontal Position variance
        /// </summary>
        public float PosHorizVariance {
            get { return mPosHorizVariance; }
            set { mPosHorizVariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Vertical Position variance
        /// </summary>
        public float PosVertVariance {
            get { return mPosVertVariance; }
            set { mPosVertVariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Compass variance
        /// </summary>
        public float CompassVariance {
            get { return mCompassVariance; }
            set { mCompassVariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Terrain Altitude variance
        /// </summary>
        public float TerrainAltVariance {
            get { return mTerrainAltVariance; }
            set { mTerrainAltVariance = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Flags
        /// </summary>
        public UInt16 Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        public UasEkfStatusReport()
        {
            mMessageId = 193;
            CrcExtra = 71;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mVelocityVariance);
            s.Write(mPosHorizVariance);
            s.Write(mPosVertVariance);
            s.Write(mCompassVariance);
            s.Write(mTerrainAltVariance);
            s.Write(mFlags);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mVelocityVariance = s.ReadSingle();
            this.mPosHorizVariance = s.ReadSingle();
            this.mPosVertVariance = s.ReadSingle();
            this.mCompassVariance = s.ReadSingle();
            this.mTerrainAltVariance = s.ReadSingle();
            this.mFlags = s.ReadUInt16();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "EKF Status message including flags and variances"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "VelocityVariance",
                Description = "Velocity variance",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosHorizVariance",
                Description = "Horizontal Position variance",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "PosVertVariance",
                Description = "Vertical Position variance",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CompassVariance",
                Description = "Compass variance",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TerrainAltVariance",
                Description = "Terrain Altitude variance",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "Flags",
                NumElements = 1,
            });

        }

        private float mVelocityVariance;
        private float mPosHorizVariance;
        private float mPosVertVariance;
        private float mCompassVariance;
        private float mTerrainAltVariance;
        private UInt16 mFlags;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// PID tuning information
    /// </summary>
    public class UasPidTuning: UasMessage
    {
        /// <summary>
        /// desired rate (degrees/s)
        /// </summary>
        public float Desired {
            get { return mDesired; }
            set { mDesired = value; NotifyUpdated(); }
        }

        /// <summary>
        /// achieved rate (degrees/s)
        /// </summary>
        public float Achieved {
            get { return mAchieved; }
            set { mAchieved = value; NotifyUpdated(); }
        }

        /// <summary>
        /// FF component
        /// </summary>
        public float Ff {
            get { return mFf; }
            set { mFf = value; NotifyUpdated(); }
        }

        /// <summary>
        /// P component
        /// </summary>
        public float P {
            get { return mP; }
            set { mP = value; NotifyUpdated(); }
        }

        /// <summary>
        /// I component
        /// </summary>
        public float I {
            get { return mI; }
            set { mI = value; NotifyUpdated(); }
        }

        /// <summary>
        /// D component
        /// </summary>
        public float D {
            get { return mD; }
            set { mD = value; NotifyUpdated(); }
        }

        /// <summary>
        /// axis
        /// </summary>
        public byte Axis {
            get { return mAxis; }
            set { mAxis = value; NotifyUpdated(); }
        }

        public UasPidTuning()
        {
            mMessageId = 194;
            CrcExtra = 98;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mDesired);
            s.Write(mAchieved);
            s.Write(mFf);
            s.Write(mP);
            s.Write(mI);
            s.Write(mD);
            s.Write(mAxis);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mDesired = s.ReadSingle();
            this.mAchieved = s.ReadSingle();
            this.mFf = s.ReadSingle();
            this.mP = s.ReadSingle();
            this.mI = s.ReadSingle();
            this.mD = s.ReadSingle();
            this.mAxis = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "PID tuning information"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Desired",
                Description = "desired rate (degrees/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Achieved",
                Description = "achieved rate (degrees/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Ff",
                Description = "FF component",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "P",
                Description = "P component",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "I",
                Description = "I component",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "D",
                Description = "D component",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Axis",
                Description = "axis",
                NumElements = 1,
            });

        }

        private float mDesired;
        private float mAchieved;
        private float mFf;
        private float mP;
        private float mI;
        private float mD;
        private byte mAxis;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// 3 axis gimbal mesuraments
    /// </summary>
    public class UasGimbalReport: UasMessage
    {
        /// <summary>
        /// Time since last update (seconds)
        /// </summary>
        public float DeltaTime {
            get { return mDeltaTime; }
            set { mDeltaTime = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Delta angle X (radians)
        /// </summary>
        public float DeltaAngleX {
            get { return mDeltaAngleX; }
            set { mDeltaAngleX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Delta angle Y (radians)
        /// </summary>
        public float DeltaAngleY {
            get { return mDeltaAngleY; }
            set { mDeltaAngleY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Delta angle X (radians)
        /// </summary>
        public float DeltaAngleZ {
            get { return mDeltaAngleZ; }
            set { mDeltaAngleZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Delta velocity X (m/s)
        /// </summary>
        public float DeltaVelocityX {
            get { return mDeltaVelocityX; }
            set { mDeltaVelocityX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Delta velocity Y (m/s)
        /// </summary>
        public float DeltaVelocityY {
            get { return mDeltaVelocityY; }
            set { mDeltaVelocityY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Delta velocity Z (m/s)
        /// </summary>
        public float DeltaVelocityZ {
            get { return mDeltaVelocityZ; }
            set { mDeltaVelocityZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Joint ROLL (radians)
        /// </summary>
        public float JointRoll {
            get { return mJointRoll; }
            set { mJointRoll = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Joint EL (radians)
        /// </summary>
        public float JointEl {
            get { return mJointEl; }
            set { mJointEl = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Joint AZ (radians)
        /// </summary>
        public float JointAz {
            get { return mJointAz; }
            set { mJointAz = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasGimbalReport()
        {
            mMessageId = 200;
            CrcExtra = 134;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mDeltaTime);
            s.Write(mDeltaAngleX);
            s.Write(mDeltaAngleY);
            s.Write(mDeltaAngleZ);
            s.Write(mDeltaVelocityX);
            s.Write(mDeltaVelocityY);
            s.Write(mDeltaVelocityZ);
            s.Write(mJointRoll);
            s.Write(mJointEl);
            s.Write(mJointAz);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mDeltaTime = s.ReadSingle();
            this.mDeltaAngleX = s.ReadSingle();
            this.mDeltaAngleY = s.ReadSingle();
            this.mDeltaAngleZ = s.ReadSingle();
            this.mDeltaVelocityX = s.ReadSingle();
            this.mDeltaVelocityY = s.ReadSingle();
            this.mDeltaVelocityZ = s.ReadSingle();
            this.mJointRoll = s.ReadSingle();
            this.mJointEl = s.ReadSingle();
            this.mJointAz = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "3 axis gimbal mesuraments"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DeltaTime",
                Description = "Time since last update (seconds)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DeltaAngleX",
                Description = "Delta angle X (radians)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DeltaAngleY",
                Description = "Delta angle Y (radians)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DeltaAngleZ",
                Description = "Delta angle X (radians)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DeltaVelocityX",
                Description = "Delta velocity X (m/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DeltaVelocityY",
                Description = "Delta velocity Y (m/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DeltaVelocityZ",
                Description = "Delta velocity Z (m/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "JointRoll",
                Description = "Joint ROLL (radians)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "JointEl",
                Description = "Joint EL (radians)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "JointAz",
                Description = "Joint AZ (radians)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private float mDeltaTime;
        private float mDeltaAngleX;
        private float mDeltaAngleY;
        private float mDeltaAngleZ;
        private float mDeltaVelocityX;
        private float mDeltaVelocityY;
        private float mDeltaVelocityZ;
        private float mJointRoll;
        private float mJointEl;
        private float mJointAz;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Control message for rate gimbal
    /// </summary>
    public class UasGimbalControl: UasMessage
    {
        /// <summary>
        /// Demanded angular rate X (rad/s)
        /// </summary>
        public float DemandedRateX {
            get { return mDemandedRateX; }
            set { mDemandedRateX = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Demanded angular rate Y (rad/s)
        /// </summary>
        public float DemandedRateY {
            get { return mDemandedRateY; }
            set { mDemandedRateY = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Demanded angular rate Z (rad/s)
        /// </summary>
        public float DemandedRateZ {
            get { return mDemandedRateZ; }
            set { mDemandedRateZ = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasGimbalControl()
        {
            mMessageId = 201;
            CrcExtra = 205;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mDemandedRateX);
            s.Write(mDemandedRateY);
            s.Write(mDemandedRateZ);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mDemandedRateX = s.ReadSingle();
            this.mDemandedRateY = s.ReadSingle();
            this.mDemandedRateZ = s.ReadSingle();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Control message for rate gimbal"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DemandedRateX",
                Description = "Demanded angular rate X (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DemandedRateY",
                Description = "Demanded angular rate Y (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "DemandedRateZ",
                Description = "Demanded angular rate Z (rad/s)",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private float mDemandedRateX;
        private float mDemandedRateY;
        private float mDemandedRateZ;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// 100 Hz gimbal torque command telemetry
    /// </summary>
    public class UasGimbalTorqueCmdReport: UasMessage
    {
        /// <summary>
        /// Roll Torque Command
        /// </summary>
        public Int16 RlTorqueCmd {
            get { return mRlTorqueCmd; }
            set { mRlTorqueCmd = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Elevation Torque Command
        /// </summary>
        public Int16 ElTorqueCmd {
            get { return mElTorqueCmd; }
            set { mElTorqueCmd = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Azimuth Torque Command
        /// </summary>
        public Int16 AzTorqueCmd {
            get { return mAzTorqueCmd; }
            set { mAzTorqueCmd = value; NotifyUpdated(); }
        }

        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        public UasGimbalTorqueCmdReport()
        {
            mMessageId = 214;
            CrcExtra = 69;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mRlTorqueCmd);
            s.Write(mElTorqueCmd);
            s.Write(mAzTorqueCmd);
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mRlTorqueCmd = s.ReadInt16();
            this.mElTorqueCmd = s.ReadInt16();
            this.mAzTorqueCmd = s.ReadInt16();
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "100 Hz gimbal torque command telemetry"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "RlTorqueCmd",
                Description = "Roll Torque Command",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "ElTorqueCmd",
                Description = "Elevation Torque Command",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "AzTorqueCmd",
                Description = "Azimuth Torque Command",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

        }

        private Int16 mRlTorqueCmd;
        private Int16 mElTorqueCmd;
        private Int16 mAzTorqueCmd;
        private byte mTargetSystem;
        private byte mTargetComponent;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Heartbeat from a HeroBus attached GoPro
    /// </summary>
    public class UasGoproHeartbeat: UasMessage
    {
        /// <summary>
        /// Status
        /// </summary>
        public byte Status {
            get { return mStatus; }
            set { mStatus = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Current capture mode
        /// </summary>
        public byte CaptureMode {
            get { return mCaptureMode; }
            set { mCaptureMode = value; NotifyUpdated(); }
        }

        /// <summary>
        /// additional status bits
        /// </summary>
        public byte Flags {
            get { return mFlags; }
            set { mFlags = value; NotifyUpdated(); }
        }

        public UasGoproHeartbeat()
        {
            mMessageId = 215;
            CrcExtra = 101;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mStatus);
            s.Write(mCaptureMode);
            s.Write(mFlags);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mStatus = s.ReadByte();
            this.mCaptureMode = s.ReadByte();
            this.mFlags = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Heartbeat from a HeroBus attached GoPro"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Status",
                Description = "Status",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CaptureMode",
                Description = "Current capture mode",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Flags",
                Description = "additional status bits",
                NumElements = 1,
            });

        }

        private byte mStatus;
        private byte mCaptureMode;
        private byte mFlags;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request a GOPRO_COMMAND response from the GoPro
    /// </summary>
    public class UasGoproGetRequest: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Command ID
        /// </summary>
        public byte CmdId {
            get { return mCmdId; }
            set { mCmdId = value; NotifyUpdated(); }
        }

        public UasGoproGetRequest()
        {
            mMessageId = 216;
            CrcExtra = 50;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mCmdId);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mCmdId = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request a GOPRO_COMMAND response from the GoPro"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CmdId",
                Description = "Command ID",
                NumElements = 1,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mCmdId;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Response from a GOPRO_COMMAND get request
    /// </summary>
    public class UasGoproGetResponse: UasMessage
    {
        /// <summary>
        /// Command ID
        /// </summary>
        public byte CmdId {
            get { return mCmdId; }
            set { mCmdId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Status
        /// </summary>
        public byte Status {
            get { return mStatus; }
            set { mStatus = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Value
        /// </summary>
        public byte[] Value {
            get { return mValue; }
            set { mValue = value; NotifyUpdated(); }
        }

        public UasGoproGetResponse()
        {
            mMessageId = 217;
            CrcExtra = 202;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mCmdId);
            s.Write(mStatus);
            s.Write(mValue[0]); 
            s.Write(mValue[1]); 
            s.Write(mValue[2]); 
            s.Write(mValue[3]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mCmdId = s.ReadByte();
            this.mStatus = s.ReadByte();
            this.mValue[0] = s.ReadByte();
            this.mValue[1] = s.ReadByte();
            this.mValue[2] = s.ReadByte();
            this.mValue[3] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Response from a GOPRO_COMMAND get request"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CmdId",
                Description = "Command ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Status",
                Description = "Status",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Value",
                Description = "Value",
                NumElements = 4,
            });

        }

        private byte mCmdId;
        private byte mStatus;
        private byte[] mValue = new byte[4];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Request to set a GOPRO_COMMAND with a desired
    /// </summary>
    public class UasGoproSetRequest: UasMessage
    {
        /// <summary>
        /// System ID
        /// </summary>
        public byte TargetSystem {
            get { return mTargetSystem; }
            set { mTargetSystem = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Component ID
        /// </summary>
        public byte TargetComponent {
            get { return mTargetComponent; }
            set { mTargetComponent = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Command ID
        /// </summary>
        public byte CmdId {
            get { return mCmdId; }
            set { mCmdId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Value
        /// </summary>
        public byte[] Value {
            get { return mValue; }
            set { mValue = value; NotifyUpdated(); }
        }

        public UasGoproSetRequest()
        {
            mMessageId = 218;
            CrcExtra = 17;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mTargetSystem);
            s.Write(mTargetComponent);
            s.Write(mCmdId);
            s.Write(mValue[0]); 
            s.Write(mValue[1]); 
            s.Write(mValue[2]); 
            s.Write(mValue[3]); 
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mTargetSystem = s.ReadByte();
            this.mTargetComponent = s.ReadByte();
            this.mCmdId = s.ReadByte();
            this.mValue[0] = s.ReadByte();
            this.mValue[1] = s.ReadByte();
            this.mValue[2] = s.ReadByte();
            this.mValue[3] = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Request to set a GOPRO_COMMAND with a desired"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetSystem",
                Description = "System ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "TargetComponent",
                Description = "Component ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CmdId",
                Description = "Command ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Value",
                Description = "Value",
                NumElements = 4,
            });

        }

        private byte mTargetSystem;
        private byte mTargetComponent;
        private byte mCmdId;
        private byte[] mValue = new byte[4];
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// Response from a GOPRO_COMMAND set request
    /// </summary>
    public class UasGoproSetResponse: UasMessage
    {
        /// <summary>
        /// Command ID
        /// </summary>
        public byte CmdId {
            get { return mCmdId; }
            set { mCmdId = value; NotifyUpdated(); }
        }

        /// <summary>
        /// Status
        /// </summary>
        public byte Status {
            get { return mStatus; }
            set { mStatus = value; NotifyUpdated(); }
        }

        public UasGoproSetResponse()
        {
            mMessageId = 219;
            CrcExtra = 162;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mCmdId);
            s.Write(mStatus);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mCmdId = s.ReadByte();
            this.mStatus = s.ReadByte();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "Response from a GOPRO_COMMAND set request"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "CmdId",
                Description = "Command ID",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Status",
                Description = "Status",
                NumElements = 1,
            });

        }

        private byte mCmdId;
        private byte mStatus;
    }


    // ___________________________________________________________________________________


    /// <summary>
    /// RPM sensor output
    /// </summary>
    public class UasRpm: UasMessage
    {
        /// <summary>
        /// RPM Sensor1
        /// </summary>
        public float Rpm1 {
            get { return mRpm1; }
            set { mRpm1 = value; NotifyUpdated(); }
        }

        /// <summary>
        /// RPM Sensor2
        /// </summary>
        public float Rpm2 {
            get { return mRpm2; }
            set { mRpm2 = value; NotifyUpdated(); }
        }

        public UasRpm()
        {
            mMessageId = 226;
            CrcExtra = 207;
        }

        internal override void SerializeBody(BinaryWriter s)
        {
            s.Write(mRpm1);
            s.Write(mRpm2);
        }

        internal override void DeserializeBody(BinaryReader s)
        {
            this.mRpm1 = s.ReadSingle();
            this.mRpm2 = s.ReadSingle();
        }

        protected override void InitMetadata()
        {
            mMetadata = new UasMessageMetadata() {
                Description = "RPM sensor output"
            };

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rpm1",
                Description = "RPM Sensor1",
                NumElements = 1,
            });

            mMetadata.Fields.Add(new UasFieldMetadata() {
                Name = "Rpm2",
                Description = "RPM Sensor2",
                NumElements = 1,
            });

        }

        private float mRpm1;
        private float mRpm2;
    }


    // ___________________________________________________________________________________


    public class UasSummary
    {
        public static UasMessage CreateFromId(byte id)
        {
            switch (id)
            {
               case 0: return new UasHeartbeat();
               case 1: return new UasSysStatus();
               case 2: return new UasSystemTime();
               case 4: return new UasPing();
               case 5: return new UasChangeOperatorControl();
               case 6: return new UasChangeOperatorControlAck();
               case 7: return new UasAuthKey();
               case 11: return new UasSetMode();
               case 20: return new UasParamRequestRead();
               case 21: return new UasParamRequestList();
               case 22: return new UasParamValue();
               case 23: return new UasParamSet();
               case 24: return new UasGpsRawInt();
               case 25: return new UasGpsStatus();
               case 26: return new UasScaledImu();
               case 27: return new UasRawImu();
               case 28: return new UasRawPressure();
               case 29: return new UasScaledPressure();
               case 30: return new UasAttitude();
               case 31: return new UasAttitudeQuaternion();
               case 32: return new UasLocalPositionNed();
               case 33: return new UasGlobalPositionInt();
               case 34: return new UasRcChannelsScaled();
               case 35: return new UasRcChannelsRaw();
               case 36: return new UasServoOutputRaw();
               case 37: return new UasMissionRequestPartialList();
               case 38: return new UasMissionWritePartialList();
               case 39: return new UasMissionItem();
               case 40: return new UasMissionRequest();
               case 41: return new UasMissionSetCurrent();
               case 42: return new UasMissionCurrent();
               case 43: return new UasMissionRequestList();
               case 44: return new UasMissionCount();
               case 45: return new UasMissionClearAll();
               case 46: return new UasMissionItemReached();
               case 47: return new UasMissionAck();
               case 48: return new UasSetGpsGlobalOrigin();
               case 49: return new UasGpsGlobalOrigin();
               case 50: return new UasParamMapRc();
               case 51: return new UasMissionRequestInt();
               case 54: return new UasSafetySetAllowedArea();
               case 55: return new UasSafetyAllowedArea();
               case 61: return new UasAttitudeQuaternionCov();
               case 62: return new UasNavControllerOutput();
               case 63: return new UasGlobalPositionIntCov();
               case 64: return new UasLocalPositionNedCov();
               case 65: return new UasRcChannels();
               case 66: return new UasRequestDataStream();
               case 67: return new UasDataStream();
               case 69: return new UasManualControl();
               case 70: return new UasRcChannelsOverride();
               case 73: return new UasMissionItemInt();
               case 74: return new UasVfrHud();
               case 75: return new UasCommandInt();
               case 76: return new UasCommandLong();
               case 77: return new UasCommandAck();
               case 81: return new UasManualSetpoint();
               case 82: return new UasSetAttitudeTarget();
               case 83: return new UasAttitudeTarget();
               case 84: return new UasSetPositionTargetLocalNed();
               case 85: return new UasPositionTargetLocalNed();
               case 86: return new UasSetPositionTargetGlobalInt();
               case 87: return new UasPositionTargetGlobalInt();
               case 89: return new UasLocalPositionNedSystemGlobalOffset();
               case 90: return new UasHilState();
               case 91: return new UasHilControls();
               case 92: return new UasHilRcInputsRaw();
               case 100: return new UasOpticalFlow();
               case 101: return new UasGlobalVisionPositionEstimate();
               case 102: return new UasVisionPositionEstimate();
               case 103: return new UasVisionSpeedEstimate();
               case 104: return new UasViconPositionEstimate();
               case 105: return new UasHighresImu();
               case 106: return new UasOpticalFlowRad();
               case 107: return new UasHilSensor();
               case 108: return new UasSimState();
               case 109: return new UasRadioStatus();
               case 110: return new UasFileTransferProtocol();
               case 111: return new UasTimesync();
               case 112: return new UasCameraTrigger();
               case 113: return new UasHilGps();
               case 114: return new UasHilOpticalFlow();
               case 115: return new UasHilStateQuaternion();
               case 116: return new UasScaledImu2();
               case 117: return new UasLogRequestList();
               case 118: return new UasLogEntry();
               case 119: return new UasLogRequestData();
               case 120: return new UasLogData();
               case 121: return new UasLogErase();
               case 122: return new UasLogRequestEnd();
               case 123: return new UasGpsInjectData();
               case 124: return new UasGps2Raw();
               case 125: return new UasPowerStatus();
               case 126: return new UasSerialControl();
               case 127: return new UasGpsRtk();
               case 128: return new UasGps2Rtk();
               case 129: return new UasScaledImu3();
               case 130: return new UasDataTransmissionHandshake();
               case 131: return new UasEncapsulatedData();
               case 132: return new UasDistanceSensor();
               case 133: return new UasTerrainRequest();
               case 134: return new UasTerrainData();
               case 135: return new UasTerrainCheck();
               case 136: return new UasTerrainReport();
               case 137: return new UasScaledPressure2();
               case 138: return new UasAttPosMocap();
               case 139: return new UasSetActuatorControlTarget();
               case 140: return new UasActuatorControlTarget();
               case 141: return new UasAltitude();
               case 142: return new UasResourceRequest();
               case 143: return new UasScaledPressure3();
               case 144: return new UasFollowTarget();
               case 146: return new UasControlSystemState();
               case 147: return new UasBatteryStatus();
               case 148: return new UasAutopilotVersion();
               case 149: return new UasLandingTarget();
               case 230: return new UasEstimatorStatus();
               case 231: return new UasWindCov();
               case 233: return new UasGpsRtcmData();
               case 241: return new UasVibration();
               case 242: return new UasHomePosition();
               case 243: return new UasSetHomePosition();
               case 244: return new UasMessageInterval();
               case 245: return new UasExtendedSysState();
               case 246: return new UasAdsbVehicle();
               case 248: return new UasV2Extension();
               case 249: return new UasMemoryVect();
               case 250: return new UasDebugVect();
               case 251: return new UasNamedValueFloat();
               case 252: return new UasNamedValueInt();
               case 253: return new UasStatustext();
               case 254: return new UasDebug();
               case 150: return new UasSensorOffsets();
               case 151: return new UasSetMagOffsets();
               case 152: return new UasMeminfo();
               case 153: return new UasApAdc();
               case 154: return new UasDigicamConfigure();
               case 155: return new UasDigicamControl();
               case 156: return new UasMountConfigure();
               case 157: return new UasMountControl();
               case 158: return new UasMountStatus();
               case 160: return new UasFencePoint();
               case 161: return new UasFenceFetchPoint();
               case 162: return new UasFenceStatus();
               case 163: return new UasAhrs();
               case 164: return new UasSimstate();
               case 165: return new UasHwstatus();
               case 166: return new UasRadio();
               case 167: return new UasLimitsStatus();
               case 168: return new UasWind();
               case 169: return new UasData16();
               case 170: return new UasData32();
               case 171: return new UasData64();
               case 172: return new UasData96();
               case 173: return new UasRangefinder();
               case 174: return new UasAirspeedAutocal();
               case 175: return new UasRallyPoint();
               case 176: return new UasRallyFetchPoint();
               case 177: return new UasCompassmotStatus();
               case 178: return new UasAhrs2();
               case 179: return new UasCameraStatus();
               case 180: return new UasCameraFeedback();
               case 181: return new UasBattery2();
               case 182: return new UasAhrs3();
               case 183: return new UasAutopilotVersionRequest();
               case 184: return new UasRemoteLogDataBlock();
               case 185: return new UasRemoteLogBlockStatus();
               case 186: return new UasLedControl();
               case 191: return new UasMagCalProgress();
               case 192: return new UasMagCalReport();
               case 193: return new UasEkfStatusReport();
               case 194: return new UasPidTuning();
               case 200: return new UasGimbalReport();
               case 201: return new UasGimbalControl();
               case 214: return new UasGimbalTorqueCmdReport();
               case 215: return new UasGoproHeartbeat();
               case 216: return new UasGoproGetRequest();
               case 217: return new UasGoproGetResponse();
               case 218: return new UasGoproSetRequest();
               case 219: return new UasGoproSetResponse();
               case 226: return new UasRpm();
               default: return null;
            }
        }

        public static byte GetCrcExtraForId(byte id)
        {
            switch (id)
            {
               case 0: return 50;
               case 1: return 124;
               case 2: return 137;
               case 4: return 237;
               case 5: return 217;
               case 6: return 104;
               case 7: return 119;
               case 11: return 89;
               case 20: return 214;
               case 21: return 159;
               case 22: return 220;
               case 23: return 168;
               case 24: return 24;
               case 25: return 23;
               case 26: return 170;
               case 27: return 144;
               case 28: return 67;
               case 29: return 115;
               case 30: return 39;
               case 31: return 246;
               case 32: return 185;
               case 33: return 104;
               case 34: return 237;
               case 35: return 244;
               case 36: return 222;
               case 37: return 212;
               case 38: return 9;
               case 39: return 254;
               case 40: return 230;
               case 41: return 28;
               case 42: return 28;
               case 43: return 132;
               case 44: return 221;
               case 45: return 232;
               case 46: return 11;
               case 47: return 153;
               case 48: return 41;
               case 49: return 39;
               case 50: return 78;
               case 51: return 196;
               case 54: return 15;
               case 55: return 3;
               case 61: return 153;
               case 62: return 183;
               case 63: return 51;
               case 64: return 59;
               case 65: return 118;
               case 66: return 148;
               case 67: return 21;
               case 69: return 243;
               case 70: return 124;
               case 73: return 38;
               case 74: return 20;
               case 75: return 158;
               case 76: return 152;
               case 77: return 143;
               case 81: return 106;
               case 82: return 49;
               case 83: return 22;
               case 84: return 143;
               case 85: return 140;
               case 86: return 5;
               case 87: return 150;
               case 89: return 231;
               case 90: return 183;
               case 91: return 63;
               case 92: return 54;
               case 100: return 175;
               case 101: return 102;
               case 102: return 158;
               case 103: return 208;
               case 104: return 56;
               case 105: return 93;
               case 106: return 138;
               case 107: return 108;
               case 108: return 32;
               case 109: return 185;
               case 110: return 84;
               case 111: return 34;
               case 112: return 174;
               case 113: return 124;
               case 114: return 237;
               case 115: return 4;
               case 116: return 76;
               case 117: return 128;
               case 118: return 56;
               case 119: return 116;
               case 120: return 134;
               case 121: return 237;
               case 122: return 203;
               case 123: return 250;
               case 124: return 87;
               case 125: return 203;
               case 126: return 220;
               case 127: return 25;
               case 128: return 226;
               case 129: return 46;
               case 130: return 29;
               case 131: return 223;
               case 132: return 85;
               case 133: return 6;
               case 134: return 229;
               case 135: return 203;
               case 136: return 1;
               case 137: return 195;
               case 138: return 109;
               case 139: return 168;
               case 140: return 181;
               case 141: return 47;
               case 142: return 72;
               case 143: return 131;
               case 144: return 127;
               case 146: return 103;
               case 147: return 154;
               case 148: return 178;
               case 149: return 200;
               case 230: return 163;
               case 231: return 105;
               case 233: return 35;
               case 241: return 90;
               case 242: return 104;
               case 243: return 85;
               case 244: return 95;
               case 245: return 130;
               case 246: return 184;
               case 248: return 8;
               case 249: return 204;
               case 250: return 49;
               case 251: return 170;
               case 252: return 44;
               case 253: return 83;
               case 254: return 46;
               case 150: return 134;
               case 151: return 219;
               case 152: return 112;
               case 153: return 188;
               case 154: return 84;
               case 155: return 22;
               case 156: return 19;
               case 157: return 21;
               case 158: return 134;
               case 160: return 78;
               case 161: return 68;
               case 162: return 189;
               case 163: return 127;
               case 164: return 154;
               case 165: return 21;
               case 166: return 21;
               case 167: return 144;
               case 168: return 1;
               case 169: return 234;
               case 170: return 73;
               case 171: return 181;
               case 172: return 22;
               case 173: return 83;
               case 174: return 167;
               case 175: return 138;
               case 176: return 234;
               case 177: return 240;
               case 178: return 47;
               case 179: return 189;
               case 180: return 52;
               case 181: return 174;
               case 182: return 229;
               case 183: return 85;
               case 184: return 159;
               case 185: return 186;
               case 186: return 72;
               case 191: return 92;
               case 192: return 36;
               case 193: return 71;
               case 194: return 98;
               case 200: return 134;
               case 201: return 205;
               case 214: return 69;
               case 215: return 101;
               case 216: return 50;
               case 217: return 202;
               case 218: return 17;
               case 219: return 162;
               case 226: return 207;
               default: return 0;
            }
        }
        private static Dictionary<string, UasEnumMetadata> mEnums;

        public static UasEnumMetadata GetEnumMetadata(string enumName)
        {
            if (mEnums == null) InitEnumMetadata();

            return mEnums[enumName];
        }

        private static void InitEnumMetadata()
        {
            UasEnumMetadata en = null;
            UasEnumEntryMetadata ent = null;
            mEnums = new Dictionary<string, UasEnumMetadata>();

            en = new UasEnumMetadata() {
                Name = "MavAutopilot",
                Description = "Micro air vehicle / autopilot classes. This identifies the individual model.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Generic",
                Description = "Generic autopilot, full support for everything",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Reserved",
                Description = "Reserved for future use.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Slugs",
                Description = "SLUGS autopilot, http://slugsuav.soe.ucsc.edu",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Ardupilotmega",
                Description = "ArduPilotMega / ArduCopter, http://diydrones.com",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Openpilot",
                Description = "OpenPilot, http://openpilot.org",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "GenericWaypointsOnly",
                Description = "Generic autopilot only supporting simple waypoints",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "GenericWaypointsAndSimpleNavigationOnly",
                Description = "Generic autopilot supporting waypoints and other simple navigation commands",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "GenericMissionFull",
                Description = "Generic autopilot supporting the full mission command set",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Invalid",
                Description = "No valid autopilot, e.g. a GCS or other MAVLink component",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Ppz",
                Description = "PPZ UAV - http://nongnu.org/paparazzi",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Udb",
                Description = "UAV Dev Board",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "Fp",
                Description = "FlexiPilot",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "Px4",
                Description = "PX4 Autopilot - http://pixhawk.ethz.ch/px4/",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "Smaccmpilot",
                Description = "SMACCMPilot - http://smaccmpilot.org",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "Autoquad",
                Description = "AutoQuad -- http://autoquad.org",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Armazila",
                Description = "Armazila -- http://armazila.com",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Aerob",
                Description = "Aerob -- http://aerob.ru",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "Asluav",
                Description = "ASLUAV autopilot -- http://www.asl.ethz.ch",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Generic",
                Description = "Generic micro air vehicle.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "FixedWing",
                Description = "Fixed wing aircraft.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Quadrotor",
                Description = "Quadrotor",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Coaxial",
                Description = "Coaxial helicopter",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Helicopter",
                Description = "Normal helicopter with tail rotor.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "AntennaTracker",
                Description = "Ground installation",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Gcs",
                Description = "Operator control unit / ground control station",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Airship",
                Description = "Airship, controlled",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "FreeBalloon",
                Description = "Free balloon, uncontrolled",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Rocket",
                Description = "Rocket",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "GroundRover",
                Description = "Ground rover",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "SurfaceBoat",
                Description = "Surface vessel, boat, ship",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "Submarine",
                Description = "Submarine",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "Hexarotor",
                Description = "Hexarotor",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "Octorotor",
                Description = "Octorotor",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Tricopter",
                Description = "Octorotor",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "FlappingWing",
                Description = "Flapping wing",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "Kite",
                Description = "Flapping wing",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "OnboardController",
                Description = "Onboard companion controller",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "VtolDuorotor",
                Description = "Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 20,
                Name = "VtolQuadrotor",
                Description = "Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 21,
                Name = "VtolTiltrotor",
                Description = "Tiltrotor VTOL",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 22,
                Name = "VtolReserved2",
                Description = "VTOL reserved 2",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 23,
                Name = "VtolReserved3",
                Description = "VTOL reserved 3",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 24,
                Name = "VtolReserved4",
                Description = "VTOL reserved 4",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 25,
                Name = "VtolReserved5",
                Description = "VTOL reserved 5",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 26,
                Name = "Gimbal",
                Description = "Onboard gimbal",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 27,
                Name = "Adsb",
                Description = "Onboard ADSB peripheral",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "FirmwareVersionType",
                Description = "These values define the type of firmware release.  These values indicate the first version or release of this type.  For example the first alpha release would be 64, the second would be 65.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Dev",
                Description = "development release",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "Alpha",
                Description = "alpha release",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "Beta",
                Description = "beta release",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 192,
                Name = "Rc",
                Description = "release candidate",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 255,
                Name = "Official",
                Description = "official stable release",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavModeFlag",
                Description = "These flags encode the MAV mode.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "SafetyArmed",
                Description = "0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "ManualInputEnabled",
                Description = "0b01000000 remote control input is enabled.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "HilEnabled",
                Description = "0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software is full operational.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "StabilizeEnabled",
                Description = "0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further control inputs to move around.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "GuidedEnabled",
                Description = "0b00001000 guided mode enabled, system flies MISSIONs / mission items.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "AutoEnabled",
                Description = "0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not, depends on the actual implementation.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "TestEnabled",
                Description = "0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should not be used for stable implementations.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "CustomModeEnabled",
                Description = "0b00000001 Reserved for future use.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavModeFlagDecodePosition",
                Description = "These values encode the bit positions of the decode position. These values can be used to read the value of a flag bit by combining the base_mode variable with AND with the flag position value. The result will be either 0 or 1, depending on if the flag is set or not.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "Safety",
                Description = "First bit:  10000000",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "Manual",
                Description = "Second bit: 01000000",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Hil",
                Description = "Third bit:  00100000",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Stabilize",
                Description = "Fourth bit: 00010000",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Guided",
                Description = "Fifth bit:  00001000",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Auto",
                Description = "Sixt bit:   00000100",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Test",
                Description = "Seventh bit: 00000010",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "CustomMode",
                Description = "Eighth bit: 00000001",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavGoto",
                Description = "Override command, pauses current mission execution and moves immediately to a position",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "DoHold",
                Description = "Hold at the current position.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "DoContinue",
                Description = "Continue with the next item in mission execution.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "HoldAtCurrentPosition",
                Description = "Hold at the current position of the system",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "HoldAtSpecifiedPosition",
                Description = "Hold at the position specified in the parameters of the DO_HOLD action",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavMode",
                Description = "These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it                simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Preflight",
                Description = "System is not ready to fly, booting, calibrating, etc. No flag is set.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 80,
                Name = "StabilizeDisarmed",
                Description = "System is allowed to be active, under assisted RC control.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 208,
                Name = "StabilizeArmed",
                Description = "System is allowed to be active, under assisted RC control.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "ManualDisarmed",
                Description = "System is allowed to be active, under manual (RC) control, no stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 192,
                Name = "ManualArmed",
                Description = "System is allowed to be active, under manual (RC) control, no stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 88,
                Name = "GuidedDisarmed",
                Description = "System is allowed to be active, under autonomous control, manual setpoint",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 216,
                Name = "GuidedArmed",
                Description = "System is allowed to be active, under autonomous control, manual setpoint",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 92,
                Name = "AutoDisarmed",
                Description = "System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by MISSIONs)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 220,
                Name = "AutoArmed",
                Description = "System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by MISSIONs)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 66,
                Name = "TestDisarmed",
                Description = "UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 194,
                Name = "TestArmed",
                Description = "UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavState",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Uninit",
                Description = "Uninitialized system, state is unknown.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Boot",
                Description = "System is booting up.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Calibrating",
                Description = "System is calibrating and not flight-ready.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Standby",
                Description = "System is grounded and on standby. It can be launched any time.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Active",
                Description = "System is active and might be already airborne. Motors are engaged.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Critical",
                Description = "System is in a non-normal flight mode. It can however still navigate.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Emergency",
                Description = "System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in mayday and going down.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Poweroff",
                Description = "System just initialized its power-down sequence, will shut down now.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavComponent",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MavCompIdAll",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 220,
                Name = "MavCompIdGps",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 190,
                Name = "MavCompIdMissionplanner",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 195,
                Name = "MavCompIdPathplanner",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 180,
                Name = "MavCompIdMapper",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 100,
                Name = "MavCompIdCamera",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 200,
                Name = "MavCompIdImu",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 201,
                Name = "MavCompIdImu2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 202,
                Name = "MavCompIdImu3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 240,
                Name = "MavCompIdUdpBridge",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 241,
                Name = "MavCompIdUartBridge",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 250,
                Name = "MavCompIdSystemControl",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 140,
                Name = "MavCompIdServo1",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 141,
                Name = "MavCompIdServo2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 142,
                Name = "MavCompIdServo3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 143,
                Name = "MavCompIdServo4",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 144,
                Name = "MavCompIdServo5",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 145,
                Name = "MavCompIdServo6",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 146,
                Name = "MavCompIdServo7",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 147,
                Name = "MavCompIdServo8",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 148,
                Name = "MavCompIdServo9",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 149,
                Name = "MavCompIdServo10",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 150,
                Name = "MavCompIdServo11",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 151,
                Name = "MavCompIdServo12",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 152,
                Name = "MavCompIdServo13",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 153,
                Name = "MavCompIdServo14",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 154,
                Name = "MavCompIdGimbal",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 155,
                Name = "MavCompIdLog",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 156,
                Name = "MavCompIdAdsb",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 157,
                Name = "MavCompIdOsd",
                Description = "On Screen Display (OSD) devices for video links",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 158,
                Name = "MavCompIdPeripheral",
                Description = "Generic autopilot peripheral component ID. Meant for devices that do not implement the parameter sub-protocol",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavSysStatusSensor",
                Description = "These encode the sensors whose status is sent as part of the SYS_STATUS message.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_3dGyro",
                Description = "0x01 3D gyro",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_3dAccel",
                Description = "0x02 3D accelerometer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_3dMag",
                Description = "0x04 3D magnetometer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "AbsolutePressure",
                Description = "0x08 absolute pressure",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "DifferentialPressure",
                Description = "0x10 differential pressure",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Gps",
                Description = "0x20 GPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "OpticalFlow",
                Description = "0x40 optical flow",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "VisionPosition",
                Description = "0x80 computer vision position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "LaserPosition",
                Description = "0x100 laser based position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "ExternalGroundTruth",
                Description = "0x200 external ground truth (Vicon or Leica)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "AngularRateControl",
                Description = "0x400 3D angular rate control",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "AttitudeStabilization",
                Description = "0x800 attitude stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4096,
                Name = "YawPosition",
                Description = "0x1000 yaw position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8192,
                Name = "ZAltitudeControl",
                Description = "0x2000 z/altitude control",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16384,
                Name = "XyPositionControl",
                Description = "0x4000 x/y position control",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32768,
                Name = "MotorOutputs",
                Description = "0x8000 motor outputs / control",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 65536,
                Name = "RcReceiver",
                Description = "0x10000 rc receiver",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 131072,
                Name = "_3dGyro2",
                Description = "0x20000 2nd 3D gyro",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 262144,
                Name = "_3dAccel2",
                Description = "0x40000 2nd 3D accelerometer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 524288,
                Name = "_3dMag2",
                Description = "0x80000 2nd 3D magnetometer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1048576,
                Name = "MavSysStatusGeofence",
                Description = "0x100000 geofence",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2097152,
                Name = "MavSysStatusAhrs",
                Description = "0x200000 AHRS subsystem health",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4194304,
                Name = "MavSysStatusTerrain",
                Description = "0x400000 Terrain subsystem health",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8388608,
                Name = "MavSysStatusReverseMotor",
                Description = "0x800000 Motors are reversed",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavFrame",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Global",
                Description = "Global coordinate frame, WGS84 coordinate system. First value / x: latitude, second value / y: longitude, third value / z: positive altitude over mean sea level (MSL)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "LocalNed",
                Description = "Local coordinate frame, Z-up (x: north, y: east, z: down).",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Mission",
                Description = "NOT a coordinate frame, indicates a mission command.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "GlobalRelativeAlt",
                Description = "Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude with 0 being at the altitude of the home location.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "LocalEnu",
                Description = "Local coordinate frame, Z-down (x: east, y: north, z: up)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "GlobalInt",
                Description = "Global coordinate frame, WGS84 coordinate system. First value / x: latitude in degrees*1.0e-7, second value / y: longitude in degrees*1.0e-7, third value / z: positive altitude over mean sea level (MSL)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "GlobalRelativeAltInt",
                Description = "Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home position. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third value / z: positive altitude with 0 being at the altitude of the home location.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "LocalOffsetNed",
                Description = "Offset to the current local frame. Anything expressed in this frame should be added to the current local frame position.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "BodyNed",
                Description = "Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to command 2 m/s^2 acceleration to the right.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "BodyOffsetNed",
                Description = "Offset in body NED frame. This makes sense if adding setpoints to the current flight path, to avoid an obstacle - e.g. useful to command 2 m/s^2 acceleration to the east.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "GlobalTerrainAlt",
                Description = "Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees, second value / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level in terrain model.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "GlobalTerrainAltInt",
                Description = "Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third value / z: positive altitude in meters with 0 being at ground level in terrain model.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavlinkDataStreamType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MavlinkDataStreamImgJpeg",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MavlinkDataStreamImgBmp",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MavlinkDataStreamImgRaw8u",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MavlinkDataStreamImgRaw32u",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "MavlinkDataStreamImgPgm",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "MavlinkDataStreamImgPng",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "FenceAction",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "Disable fenced mode",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Guided",
                Description = "Switched to guided mode to return point (fence point 0)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Report",
                Description = "Report fence breach, but don't take action",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "GuidedThrPass",
                Description = "Switched to guided mode to return point (fence point 0) with manual throttle control",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Rtl",
                Description = "Switch to RTL (return to launch) mode and head for the return point.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "FenceBreach",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "No last fence breach",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Minalt",
                Description = "Breached minimum altitude",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Maxalt",
                Description = "Breached maximum altitude",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Boundary",
                Description = "Breached fence boundary",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavMountMode",
                Description = "Enumeration of possible mount operation modes",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Retract",
                Description = "Load and keep safe position (Roll,Pitch,Yaw) from permant memory and stop stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Neutral",
                Description = "Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MavlinkTargeting",
                Description = "Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "RcTargeting",
                Description = "Load neutral position and start RC Roll,Pitch,Yaw control with stabilization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "GpsPoint",
                Description = "Load neutral position and start to point to Lat,Lon,Alt",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavCmd",
                Description = "Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "NavWaypoint",
                Description = "Navigate to MISSION.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Hold time in decimal seconds. (ignored by fixed wing, time to stay at MISSION for rotary wing)");
            ent.Params.Add("Acceptance radius in meters (if the sphere with this radius is hit, the MISSION counts as reached)");
            ent.Params.Add("0 to pass through the WP, if > 0 radius in meters to pass by WP. Positive value for clockwise orbit, negative value for counter-clockwise orbit. Allows trajectory control.");
            ent.Params.Add("Desired yaw angle at MISSION (rotary wing)");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "NavLoiterUnlim",
                Description = "Loiter around this MISSION an unlimited amount of time",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Radius around MISSION, in meters. If positive loiter clockwise, else counter-clockwise");
            ent.Params.Add("Desired yaw angle.");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "NavLoiterTurns",
                Description = "Loiter around this MISSION for X turns",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Turns");
            ent.Params.Add("Empty");
            ent.Params.Add("Radius around MISSION, in meters. If positive loiter clockwise, else counter-clockwise");
            ent.Params.Add("Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "NavLoiterTime",
                Description = "Loiter around this MISSION for X seconds",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Seconds (decimal)");
            ent.Params.Add("Empty");
            ent.Params.Add("Radius around MISSION, in meters. If positive loiter clockwise, else counter-clockwise");
            ent.Params.Add("Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 20,
                Name = "NavReturnToLaunch",
                Description = "Return to launch location",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 21,
                Name = "NavLand",
                Description = "Land at location",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Abort Alt");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Desired yaw angle");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 22,
                Name = "NavTakeoff",
                Description = "Takeoff from ground / hand",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Minimum pitch (if airspeed sensor present), desired pitch without sensor");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Yaw angle (if magnetometer present), ignored without magnetometer");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 23,
                Name = "NavLandLocal",
                Description = "Land at local position (local frame only)",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Landing target number (if available)");
            ent.Params.Add("Maximum accepted offset from desired landing position [m] - computed magnitude from spherical coordinates: d = sqrt(x^2 + y^2 + z^2), which gives the maximum accepted distance between the desired landing position and the position where the vehicle is about to land");
            ent.Params.Add("Landing descend rate [ms^-1]");
            ent.Params.Add("Desired yaw angle [rad]");
            ent.Params.Add("Y-axis position [m]");
            ent.Params.Add("X-axis position [m]");
            ent.Params.Add("Z-axis / ground level position [m]");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 24,
                Name = "NavTakeoffLocal",
                Description = "Takeoff from local position (local frame only)",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Minimum pitch (if airspeed sensor present), desired pitch without sensor [rad]");
            ent.Params.Add("Empty");
            ent.Params.Add("Takeoff ascend rate [ms^-1]");
            ent.Params.Add("Yaw angle [rad] (if magnetometer or another yaw estimation source present), ignored without one of these");
            ent.Params.Add("Y-axis position [m]");
            ent.Params.Add("X-axis position [m]");
            ent.Params.Add("Z-axis position [m]");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 25,
                Name = "NavFollow",
                Description = "Vehicle following, i.e. this waypoint represents the position of a moving vehicle",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Following logic to use (e.g. loitering or sinusoidal following) - depends on specific autopilot implementation");
            ent.Params.Add("Ground speed of vehicle to be followed");
            ent.Params.Add("Radius around MISSION, in meters. If positive loiter clockwise, else counter-clockwise");
            ent.Params.Add("Desired yaw angle.");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30,
                Name = "NavContinueAndChangeAlt",
                Description = "Continue on the current course and climb/descend to specified altitude.  When the altitude is reached continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Climb or Descend (0 = Neutral, command completes when within 5m of this command's altitude, 1 = Climbing, command completes when at or above this command's altitude, 2 = Descending, command completes when at or below this command's altitude. ");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Desired altitude in meters");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31,
                Name = "NavLoiterToAlt",
                Description = "Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.  Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached.  Additionally, if the Heading Required parameter is non-zero the  aircraft will not leave the loiter until heading toward the next waypoint. ",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Heading Required (0 = False)");
            ent.Params.Add("Radius in meters. If positive loiter clockwise, negative counter-clockwise, 0 means no change to standard loiter.");
            ent.Params.Add("Empty");
            ent.Params.Add("Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "DoFollow",
                Description = "Being following a target",
            };
            ent.Params = new List<String>();
            ent.Params.Add("System ID (the system ID of the FOLLOW_TARGET beacon). Send 0 to disable follow-me and return to the default position hold mode");
            ent.Params.Add("RESERVED");
            ent.Params.Add("RESERVED");
            ent.Params.Add("altitude flag: 0: Keep current altitude, 1: keep altitude difference to target, 2: go to a fixed altitude above home");
            ent.Params.Add("altitude");
            ent.Params.Add("RESERVED");
            ent.Params.Add("TTL in seconds in which the MAV should go to the default position hold mode after a message rx timeout");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 33,
                Name = "DoFollowReposition",
                Description = "Reposition the MAV after a follow target command has been sent",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Camera q1 (where 0 is on the ray from the camera to the tracking device)");
            ent.Params.Add("Camera q2");
            ent.Params.Add("Camera q3");
            ent.Params.Add("Camera q4");
            ent.Params.Add("altitude offset from target (m)");
            ent.Params.Add("X offset from target (m)");
            ent.Params.Add("Y offset from target (m)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 80,
                Name = "NavRoi",
                Description = "Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Region of intereset mode. (see MAV_ROI enum)");
            ent.Params.Add("MISSION index/ target ID. (see MAV_ROI enum)");
            ent.Params.Add("ROI index (allows a vehicle to manage multiple ROI's)");
            ent.Params.Add("Empty");
            ent.Params.Add("x the location of the fixed ROI (see MAV_FRAME)");
            ent.Params.Add("y");
            ent.Params.Add("z");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 81,
                Name = "NavPathplanning",
                Description = "Control autonomous path planning on the MAV.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: Disable local obstacle avoidance / local path planning (without resetting map), 1: Enable local path planning, 2: Enable and reset local path planning");
            ent.Params.Add("0: Disable full path planning (without resetting map), 1: Enable, 2: Enable and reset map/occupancy grid, 3: Enable and reset planned route, but not occupancy grid");
            ent.Params.Add("Empty");
            ent.Params.Add("Yaw angle at goal, in compass degrees, [0..360]");
            ent.Params.Add("Latitude/X of goal");
            ent.Params.Add("Longitude/Y of goal");
            ent.Params.Add("Altitude/Z of goal");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 82,
                Name = "NavSplineWaypoint",
                Description = "Navigate to MISSION using a spline path.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Hold time in decimal seconds. (ignored by fixed wing, time to stay at MISSION for rotary wing)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Latitude/X of goal");
            ent.Params.Add("Longitude/Y of goal");
            ent.Params.Add("Altitude/Z of goal");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 84,
                Name = "NavVtolTakeoff",
                Description = "Takeoff from ground using VTOL mode",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Yaw angle in degrees");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 85,
                Name = "NavVtolLand",
                Description = "Land using VTOL mode",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Yaw angle in degrees");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 92,
                Name = "NavGuidedEnable",
                Description = "hand control over to an external controller",
            };
            ent.Params = new List<String>();
            ent.Params.Add("On / Off (> 0.5f on)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 93,
                Name = "NavDelay",
                Description = "Delay the next navigation command a number of seconds or until a specified time",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Delay in seconds (decimal, -1 to enable time-of-day fields)");
            ent.Params.Add("hour (24h format, UTC, -1 to ignore)");
            ent.Params.Add("minute (24h format, UTC, -1 to ignore)");
            ent.Params.Add("second (24h format, UTC)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 95,
                Name = "NavLast",
                Description = "NOP - This command is only used to mark the upper limit of the NAV/ACTION commands in the enumeration",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 112,
                Name = "ConditionDelay",
                Description = "Delay mission state machine.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Delay in seconds (decimal)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 113,
                Name = "ConditionChangeAlt",
                Description = "Ascend/descend at rate.  Delay mission state machine until desired altitude reached.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Descent / Ascend rate (m/s)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Finish Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 114,
                Name = "ConditionDistance",
                Description = "Delay mission state machine until within desired distance of next NAV point.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Distance (meters)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 115,
                Name = "ConditionYaw",
                Description = "Reach a certain target angle.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("target angle: [0-360], 0 is north");
            ent.Params.Add("speed during yaw change:[deg per second]");
            ent.Params.Add("direction: negative: counter clockwise, positive: clockwise [-1,1]");
            ent.Params.Add("relative offset or absolute angle: [ 1,0]");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 159,
                Name = "ConditionLast",
                Description = "NOP - This command is only used to mark the upper limit of the CONDITION commands in the enumeration",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 176,
                Name = "DoSetMode",
                Description = "Set system mode.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Mode, as defined by ENUM MAV_MODE");
            ent.Params.Add("Custom mode - this is system specific, please refer to the individual autopilot specifications for details.");
            ent.Params.Add("Custom sub mode - this is system specific, please refer to the individual autopilot specifications for details.");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 177,
                Name = "DoJump",
                Description = "Jump to the desired command in the mission list.  Repeat this action only the specified number of times",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Sequence number");
            ent.Params.Add("Repeat count");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 178,
                Name = "DoChangeSpeed",
                Description = "Change speed and/or throttle set points.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Speed type (0=Airspeed, 1=Ground Speed)");
            ent.Params.Add("Speed  (m/s, -1 indicates no change)");
            ent.Params.Add("Throttle  ( Percent, -1 indicates no change)");
            ent.Params.Add("absolute or relative [0,1]");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 179,
                Name = "DoSetHome",
                Description = "Changes the home location either to the current location or a specified location.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Use current (1=use current location, 0=use specified location)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Altitude");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 180,
                Name = "DoSetParameter",
                Description = "Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value of the parameter.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Parameter number");
            ent.Params.Add("Parameter value");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 181,
                Name = "DoSetRelay",
                Description = "Set a relay to a condition.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Relay number");
            ent.Params.Add("Setting (1=on, 0=off, others possible depending on system hardware)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 182,
                Name = "DoRepeatRelay",
                Description = "Cycle a relay on and off for a desired number of cyles with a desired period.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Relay number");
            ent.Params.Add("Cycle count");
            ent.Params.Add("Cycle time (seconds, decimal)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 183,
                Name = "DoSetServo",
                Description = "Set a servo to a desired PWM value.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Servo number");
            ent.Params.Add("PWM (microseconds, 1000 to 2000 typical)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 184,
                Name = "DoRepeatServo",
                Description = "Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Servo number");
            ent.Params.Add("PWM (microseconds, 1000 to 2000 typical)");
            ent.Params.Add("Cycle count");
            ent.Params.Add("Cycle time (seconds)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 185,
                Name = "DoFlighttermination",
                Description = "Terminate flight immediately",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Flight termination activated if > 0.5");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 189,
                Name = "DoLandStart",
                Description = "Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where a sequence of mission items that represents a landing starts. It may also be sent via a COMMAND_LONG to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will be used. The Latitude/Longitude is optional, and may be set to 0/0 if not needed. If specified then it will be used to help find the closest landing sequence.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Latitude");
            ent.Params.Add("Longitude");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 190,
                Name = "DoRallyLand",
                Description = "Mission command to perform a landing from a rally point.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Break altitude (meters)");
            ent.Params.Add("Landing speed (m/s)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 191,
                Name = "DoGoAround",
                Description = "Mission command to safely abort an autonmous landing.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Altitude (meters)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 192,
                Name = "DoReposition",
                Description = "Reposition the vehicle to a specific WGS84 global position.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Ground speed, less than 0 (-1) for default");
            ent.Params.Add("Bitmask of option flags, see the MAV_DO_REPOSITION_FLAGS enum.");
            ent.Params.Add("Reserved");
            ent.Params.Add("Yaw heading, NaN for unchanged. For planes indicates loiter direction (0: clockwise, 1: counter clockwise)");
            ent.Params.Add("Latitude (deg * 1E7)");
            ent.Params.Add("Longitude (deg * 1E7)");
            ent.Params.Add("Altitude (meters)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 193,
                Name = "DoPauseContinue",
                Description = "If in a GPS controlled position mode, hold the current position or continue.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: Pause current mission or reposition command, hold current position. 1: Continue mission. A VTOL capable vehicle should enter hover mode (multicopter and VTOL planes). A plane should loiter with the default loiter radius.");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 200,
                Name = "DoControlVideo",
                Description = "Control onboard camera system.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Camera ID (-1 for all)");
            ent.Params.Add("Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw");
            ent.Params.Add("Transmission mode: 0: video stream, >0: single images every n seconds (decimal)");
            ent.Params.Add("Recording: 0: disabled, 1: enabled compressed, 2: enabled raw");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 201,
                Name = "DoSetRoi",
                Description = "Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Region of intereset mode. (see MAV_ROI enum)");
            ent.Params.Add("MISSION index/ target ID. (see MAV_ROI enum)");
            ent.Params.Add("ROI index (allows a vehicle to manage multiple ROI's)");
            ent.Params.Add("Empty");
            ent.Params.Add("x the location of the fixed ROI (see MAV_FRAME)");
            ent.Params.Add("y");
            ent.Params.Add("z");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 202,
                Name = "DoDigicamConfigure",
                Description = "Mission command to configure an on-board camera controller system.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Modes: P, TV, AV, M, Etc");
            ent.Params.Add("Shutter speed: Divisor number for one second");
            ent.Params.Add("Aperture: F stop number");
            ent.Params.Add("ISO number e.g. 80, 100, 200, Etc");
            ent.Params.Add("Exposure type enumerator");
            ent.Params.Add("Command Identity");
            ent.Params.Add("Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 203,
                Name = "DoDigicamControl",
                Description = "Mission command to control an on-board camera controller system.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Session control e.g. show/hide lens");
            ent.Params.Add("Zoom's absolute position");
            ent.Params.Add("Zooming step value to offset zoom from the current position");
            ent.Params.Add("Focus Locking, Unlocking or Re-locking");
            ent.Params.Add("Shooting Command");
            ent.Params.Add("Command Identity");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 204,
                Name = "DoMountConfigure",
                Description = "Mission command to configure a camera or antenna mount",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Mount operation mode (see MAV_MOUNT_MODE enum)");
            ent.Params.Add("stabilize roll? (1 = yes, 0 = no)");
            ent.Params.Add("stabilize pitch? (1 = yes, 0 = no)");
            ent.Params.Add("stabilize yaw? (1 = yes, 0 = no)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 205,
                Name = "DoMountControl",
                Description = "Mission command to control a camera or antenna mount",
            };
            ent.Params = new List<String>();
            ent.Params.Add("pitch or lat in degrees, depending on mount mode.");
            ent.Params.Add("roll or lon in degrees depending on mount mode");
            ent.Params.Add("yaw or alt (in meters) depending on mount mode");
            ent.Params.Add("reserved");
            ent.Params.Add("reserved");
            ent.Params.Add("reserved");
            ent.Params.Add("MAV_MOUNT_MODE enum value");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 206,
                Name = "DoSetCamTriggDist",
                Description = "Mission command to set CAM_TRIGG_DIST for this flight",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Camera trigger distance (meters)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 207,
                Name = "DoFenceEnable",
                Description = "Mission command to enable the geofence",
            };
            ent.Params = new List<String>();
            ent.Params.Add("enable? (0=disable, 1=enable, 2=disable_floor_only)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 208,
                Name = "DoParachute",
                Description = "Mission command to trigger a parachute",
            };
            ent.Params = new List<String>();
            ent.Params.Add("action (0=disable, 1=enable, 2=release, for some systems see PARACHUTE_ACTION enum, not in general message set.)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 210,
                Name = "DoInvertedFlight",
                Description = "Change to/from inverted flight",
            };
            ent.Params = new List<String>();
            ent.Params.Add("inverted (0=normal, 1=inverted)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 220,
                Name = "DoMountControlQuat",
                Description = "Mission command to control a camera or antenna mount, using a quaternion as reference.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("q1 - quaternion param #1, w (1 in null-rotation)");
            ent.Params.Add("q2 - quaternion param #2, x (0 in null-rotation)");
            ent.Params.Add("q3 - quaternion param #3, y (0 in null-rotation)");
            ent.Params.Add("q4 - quaternion param #4, z (0 in null-rotation)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 221,
                Name = "DoGuidedMaster",
                Description = "set id of master controller",
            };
            ent.Params = new List<String>();
            ent.Params.Add("System ID");
            ent.Params.Add("Component ID");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 222,
                Name = "DoGuidedLimits",
                Description = "set limits for external control",
            };
            ent.Params = new List<String>();
            ent.Params.Add("timeout - maximum time (in seconds) that external controller will be allowed to control vehicle. 0 means no timeout");
            ent.Params.Add("absolute altitude min (in meters, AMSL) - if vehicle moves below this alt, the command will be aborted and the mission will continue.  0 means no lower altitude limit");
            ent.Params.Add("absolute altitude max (in meters)- if vehicle moves above this alt, the command will be aborted and the mission will continue.  0 means no upper altitude limit");
            ent.Params.Add("horizontal move limit (in meters, AMSL) - if vehicle moves more than this distance from it's location at the moment the command was executed, the command will be aborted and the mission will continue. 0 means no horizontal altitude limit");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 240,
                Name = "DoLast",
                Description = "NOP - This command is only used to mark the upper limit of the DO commands in the enumeration",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 241,
                Name = "PreflightCalibration",
                Description = "Trigger calibration. This command will be only accepted if in pre-flight mode.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Gyro calibration: 0: no, 1: yes");
            ent.Params.Add("Magnetometer calibration: 0: no, 1: yes");
            ent.Params.Add("Ground pressure: 0: no, 1: yes");
            ent.Params.Add("Radio calibration: 0: no, 1: yes");
            ent.Params.Add("Accelerometer calibration: 0: no, 1: yes");
            ent.Params.Add("Compass/Motor interference calibration: 0: no, 1: yes");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 242,
                Name = "PreflightSetSensorOffsets",
                Description = "Set sensor offsets. This command will be only accepted if in pre-flight mode.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Sensor to adjust the offsets for: 0: gyros, 1: accelerometer, 2: magnetometer, 3: barometer, 4: optical flow, 5: second magnetometer");
            ent.Params.Add("X axis offset (or generic dimension 1), in the sensor's raw units");
            ent.Params.Add("Y axis offset (or generic dimension 2), in the sensor's raw units");
            ent.Params.Add("Z axis offset (or generic dimension 3), in the sensor's raw units");
            ent.Params.Add("Generic dimension 4, in the sensor's raw units");
            ent.Params.Add("Generic dimension 5, in the sensor's raw units");
            ent.Params.Add("Generic dimension 6, in the sensor's raw units");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 243,
                Name = "PreflightUavcan",
                Description = "Trigger UAVCAN config. This command will be only accepted if in pre-flight mode.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("1: Trigger actuator ID assignment and direction mapping.");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 245,
                Name = "PreflightStorage",
                Description = "Request storage of different parameter values and logs. This command will be only accepted if in pre-flight mode.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Parameter storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults");
            ent.Params.Add("Mission storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults");
            ent.Params.Add("Onboard logging: 0: Ignore, 1: Start default rate logging, -1: Stop logging, > 1: start logging with rate of param 3 in Hz (e.g. set to 1000 for 1000 Hz logging)");
            ent.Params.Add("Reserved");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 246,
                Name = "PreflightRebootShutdown",
                Description = "Request the reboot or shutdown of system components.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0: Do nothing for autopilot, 1: Reboot autopilot, 2: Shutdown autopilot, 3: Reboot autopilot and keep it in the bootloader until upgraded.");
            ent.Params.Add("0: Do nothing for onboard computer, 1: Reboot onboard computer, 2: Shutdown onboard computer, 3: Reboot onboard computer and keep it in the bootloader until upgraded.");
            ent.Params.Add("Reserved, send 0");
            ent.Params.Add("Reserved, send 0");
            ent.Params.Add("Reserved, send 0");
            ent.Params.Add("Reserved, send 0");
            ent.Params.Add("Reserved, send 0");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 252,
                Name = "OverrideGoto",
                Description = "Hold / continue the current action",
            };
            ent.Params = new List<String>();
            ent.Params.Add("MAV_GOTO_DO_HOLD: hold MAV_GOTO_DO_CONTINUE: continue with next item in mission plan");
            ent.Params.Add("MAV_GOTO_HOLD_AT_CURRENT_POSITION: Hold at current position MAV_GOTO_HOLD_AT_SPECIFIED_POSITION: hold at specified position");
            ent.Params.Add("MAV_FRAME coordinate frame of hold point");
            ent.Params.Add("Desired yaw angle in degrees");
            ent.Params.Add("Latitude / X position");
            ent.Params.Add("Longitude / Y position");
            ent.Params.Add("Altitude / Z position");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 300,
                Name = "MissionStart",
                Description = "start running a mission",
            };
            ent.Params = new List<String>();
            ent.Params.Add("first_item: the first mission item to run");
            ent.Params.Add("last_item:  the last mission item to run (after this item is run, the mission ends)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 400,
                Name = "ComponentArmDisarm",
                Description = "Arms / Disarms a component",
            };
            ent.Params = new List<String>();
            ent.Params.Add("1 to arm, 0 to disarm");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 410,
                Name = "GetHomePosition",
                Description = "Request the home position from the vehicle.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 500,
                Name = "StartRxPair",
                Description = "Starts receiver pairing",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0:Spektrum");
            ent.Params.Add("0:Spektrum DSM2, 1:Spektrum DSMX");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 510,
                Name = "GetMessageInterval",
                Description = "Request the interval between messages for a particular MAVLink message ID",
            };
            ent.Params = new List<String>();
            ent.Params.Add("The MAVLink message ID");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 511,
                Name = "SetMessageInterval",
                Description = "Request the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREAM",
            };
            ent.Params = new List<String>();
            ent.Params.Add("The MAVLink message ID");
            ent.Params.Add("The interval between two messages, in microseconds. Set to -1 to disable and 0 to request default rate.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 520,
                Name = "RequestAutopilotCapabilities",
                Description = "Request autopilot capabilities",
            };
            ent.Params = new List<String>();
            ent.Params.Add("1: Request autopilot version");
            ent.Params.Add("Reserved (all remaining params)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2000,
                Name = "ImageStartCapture",
                Description = "Start image capture sequence",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Duration between two consecutive pictures (in seconds)");
            ent.Params.Add("Number of images to capture total - 0 for unlimited capture");
            ent.Params.Add("Resolution in megapixels (0.3 for 640x480, 1.3 for 1280x720, etc)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2001,
                Name = "ImageStopCapture",
                Description = "Stop image capture sequence",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2003,
                Name = "DoTriggerControl",
                Description = "Enable or disable on-board camera triggering system.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Trigger enable/disable (0 for disable, 1 for start)");
            ent.Params.Add("Shutter integration time (in ms)");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2500,
                Name = "VideoStartCapture",
                Description = "Starts video capture",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Camera ID (0 for all cameras), 1 for first, 2 for second, etc.");
            ent.Params.Add("Frames per second");
            ent.Params.Add("Resolution in megapixels (0.3 for 640x480, 1.3 for 1280x720, etc)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2501,
                Name = "VideoStopCapture",
                Description = "Stop the current video capture",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2800,
                Name = "PanoramaCreate",
                Description = "Create a panorama at the current position",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Viewing angle horizontal of the panorama (in degrees, +- 0.5 the total angle)");
            ent.Params.Add("Viewing angle vertical of panorama (in degrees)");
            ent.Params.Add("Speed of the horizontal rotation (in degrees per second)");
            ent.Params.Add("Speed of the vertical rotation (in degrees per second)");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3000,
                Name = "DoVtolTransition",
                Description = "Request VTOL transition",
            };
            ent.Params = new List<String>();
            ent.Params.Add("The target VTOL state, as defined by ENUM MAV_VTOL_STATE. Only MAV_VTOL_STATE_MC and MAV_VTOL_STATE_FW can be used.");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30001,
                Name = "PayloadPrepareDeploy",
                Description = "Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release position and velocity.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Operation mode. 0: prepare single payload deploy (overwriting previous requests), but do not execute it. 1: execute payload deploy immediately (rejecting further deploy commands during execution, but allowing abort). 2: add payload deploy to existing deployment list.");
            ent.Params.Add("Desired approach vector in degrees compass heading (0..360). A negative value indicates the system can define the approach vector at will.");
            ent.Params.Add("Desired ground speed at release time. This can be overriden by the airframe in case it needs to meet minimum airspeed. A negative value indicates the system can define the ground speed at will.");
            ent.Params.Add("Minimum altitude clearance to the release position in meters. A negative value indicates the system can define the clearance at will.");
            ent.Params.Add("Latitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT");
            ent.Params.Add("Longitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30002,
                Name = "PayloadControlDeploy",
                Description = "Control the payload deployment.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Operation mode. 0: Abort deployment, continue normal mission. 1: switch to payload deploment mode. 100: delete first payload deployment request. 101: delete all payload deployment requests.");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            ent.Params.Add("Reserved");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31000,
                Name = "WaypointUser1",
                Description = "User defined waypoint item. Ground Station will show the Vehicle as flying through this item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31001,
                Name = "WaypointUser2",
                Description = "User defined waypoint item. Ground Station will show the Vehicle as flying through this item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31002,
                Name = "WaypointUser3",
                Description = "User defined waypoint item. Ground Station will show the Vehicle as flying through this item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31003,
                Name = "WaypointUser4",
                Description = "User defined waypoint item. Ground Station will show the Vehicle as flying through this item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31004,
                Name = "WaypointUser5",
                Description = "User defined waypoint item. Ground Station will show the Vehicle as flying through this item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31005,
                Name = "SpatialUser1",
                Description = "User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31006,
                Name = "SpatialUser2",
                Description = "User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31007,
                Name = "SpatialUser3",
                Description = "User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31008,
                Name = "SpatialUser4",
                Description = "User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31009,
                Name = "SpatialUser5",
                Description = "User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("Latitude unscaled");
            ent.Params.Add("Longitude unscaled");
            ent.Params.Add("Altitude, in meters AMSL");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31010,
                Name = "User1",
                Description = "User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31011,
                Name = "User2",
                Description = "User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31012,
                Name = "User3",
                Description = "User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31013,
                Name = "User4",
                Description = "User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31014,
                Name = "User5",
                Description = "User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            ent.Params.Add("User defined");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 209,
                Name = "DoMotorTest",
                Description = "Mission command to perform motor test",
            };
            ent.Params = new List<String>();
            ent.Params.Add("motor sequence number (a number from 1 to max number of motors on the vehicle)");
            ent.Params.Add("throttle type (0=throttle percentage, 1=PWM, 2=pilot throttle channel pass-through. See MOTOR_TEST_THROTTLE_TYPE enum)");
            ent.Params.Add("throttle");
            ent.Params.Add("timeout (in seconds)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 211,
                Name = "DoGripper",
                Description = "Mission command to operate EPM gripper",
            };
            ent.Params = new List<String>();
            ent.Params.Add("gripper number (a number from 1 to max number of grippers on the vehicle)");
            ent.Params.Add("gripper action (0=release, 1=grab. See GRIPPER_ACTIONS enum)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 212,
                Name = "DoAutotuneEnable",
                Description = "Enable/disable autotune",
            };
            ent.Params = new List<String>();
            ent.Params.Add("enable (1: enable, 0:disable)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 83,
                Name = "NavAltitudeWait",
                Description = "Mission command to wait for an altitude or downwards vertical speed. This is meant for high altitude balloon launches, allowing the aircraft to be idle until either an altitude is reached or a negative vertical speed is reached (indicating early balloon burst). The wiggle time is how often to wiggle the control surfaces to prevent them seizing up.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("altitude (m)");
            ent.Params.Add("descent speed (m/s)");
            ent.Params.Add("Wiggle Time (s)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42000,
                Name = "PowerOffInitiated",
                Description = "A system wide power-off event has been initiated.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42001,
                Name = "SoloBtnFlyClick",
                Description = "FLY button has been clicked.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42002,
                Name = "SoloBtnFlyHold",
                Description = "FLY button has been held for 1.5 seconds.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Takeoff altitude");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42003,
                Name = "SoloBtnPauseClick",
                Description = "PAUSE button has been clicked.",
            };
            ent.Params = new List<String>();
            ent.Params.Add("1 if Solo is in a shot mode, 0 otherwise");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42424,
                Name = "DoStartMagCal",
                Description = "Initiate a magnetometer calibration",
            };
            ent.Params = new List<String>();
            ent.Params.Add("uint8_t bitmask of magnetometers (0 means all)");
            ent.Params.Add("Automatically retry on failure (0=no retry, 1=retry).");
            ent.Params.Add("Save without user input (0=require input, 1=autosave).");
            ent.Params.Add("Delay (seconds)");
            ent.Params.Add("Autoreboot (0=user reboot, 1=autoreboot)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42425,
                Name = "DoAcceptMagCal",
                Description = "Initiate a magnetometer calibration",
            };
            ent.Params = new List<String>();
            ent.Params.Add("uint8_t bitmask of magnetometers (0 means all)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42426,
                Name = "DoCancelMagCal",
                Description = "Cancel a running magnetometer calibration",
            };
            ent.Params = new List<String>();
            ent.Params.Add("uint8_t bitmask of magnetometers (0 means all)");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42428,
                Name = "DoSendBanner",
                Description = "Reply with the version banner",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42501,
                Name = "GimbalReset",
                Description = "Causes the gimbal to reset and boot as if it was just powered on",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42427,
                Name = "SetFactoryTestMode",
                Description = "Command autopilot to get into factory test/diagnostic mode",
            };
            ent.Params = new List<String>();
            ent.Params.Add("0 means get out of test mode, 1 means get into test mode");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42502,
                Name = "GimbalAxisCalibrationStatus",
                Description = "Reports progress and success or failure of gimbal axis calibration procedure",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Gimbal axis we're reporting calibration progress for");
            ent.Params.Add("Current calibration progress for this axis, 0x64=100%");
            ent.Params.Add("Status of the calibration");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42503,
                Name = "GimbalRequestAxisCalibration",
                Description = "Starts commutation calibration on the gimbal",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            ent.Params.Add("Empty");
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 42505,
                Name = "GimbalFullReset",
                Description = "Erases gimbal application and parameters",
            };
            ent.Params = new List<String>();
            ent.Params.Add("Magic number");
            ent.Params.Add("Magic number");
            ent.Params.Add("Magic number");
            ent.Params.Add("Magic number");
            ent.Params.Add("Magic number");
            ent.Params.Add("Magic number");
            ent.Params.Add("Magic number");
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavDataStream",
                Description = "THIS INTERFACE IS DEPRECATED AS OF JULY 2015. Please use MESSAGE_INTERVAL instead. A data stream is not a fixed set of messages, but rather a      recommendation to the autopilot software. Individual autopilots may or may not obey      the recommended messages.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "All",
                Description = "Enable all data streams",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "RawSensors",
                Description = "Enable IMU_RAW, GPS_RAW, GPS_STATUS packets.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ExtendedStatus",
                Description = "Enable GPS_STATUS, CONTROL_STATUS, AUX_STATUS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "RcChannels",
                Description = "Enable RC_CHANNELS_SCALED, RC_CHANNELS_RAW, SERVO_OUTPUT_RAW",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "RawController",
                Description = "Enable ATTITUDE_CONTROLLER_OUTPUT, POSITION_CONTROLLER_OUTPUT, NAV_CONTROLLER_OUTPUT.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Position",
                Description = "Enable LOCAL_POSITION, GLOBAL_POSITION/GLOBAL_POSITION_INT messages.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Extra1",
                Description = "Dependent on the autopilot",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "Extra2",
                Description = "Dependent on the autopilot",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "Extra3",
                Description = "Dependent on the autopilot",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavRoi",
                Description = " The ROI (region of interest) for the vehicle. This can be                 be used by the vehicle for camera/vehicle attitude alignment (see                 MAV_CMD_NAV_ROI).",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "None",
                Description = "No region of interest.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Wpnext",
                Description = "Point toward next MISSION.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Wpindex",
                Description = "Point toward given MISSION.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Location",
                Description = "Point toward fixed location.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Target",
                Description = "Point toward of given id.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavCmdAck",
                Description = "ACK / NACK / ERROR values as a result of MAV_CMDs and for mission item transmission.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Ok",
                Description = "Command / mission item is ok.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ErrFail",
                Description = "Generic error message if none of the other reasons fails or if no detailed error reporting is implemented.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "ErrAccessDenied",
                Description = "The system is refusing to accept this command from this source / communication partner.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "ErrNotSupported",
                Description = "Command or mission item is not supported, other commands would be accepted.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "ErrCoordinateFrameNotSupported",
                Description = "The coordinate frame of this command / mission item is not supported.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "ErrCoordinatesOutOfRange",
                Description = "The coordinate frame of this command is ok, but he coordinate values exceed the safety limits of this system. This is a generic error, please use the more specific error messages below if possible.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "ErrXLatOutOfRange",
                Description = "The X or latitude value is out of range.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "ErrYLonOutOfRange",
                Description = "The Y or longitude value is out of range.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "ErrZAltOutOfRange",
                Description = "The Z or altitude value is out of range.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavParamType",
                Description = "Specifies the datatype of a MAVLink parameter.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Uint8",
                Description = "8-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Int8",
                Description = "8-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Uint16",
                Description = "16-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Int16",
                Description = "16-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Uint32",
                Description = "32-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Int32",
                Description = "32-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Uint64",
                Description = "64-bit unsigned integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Int64",
                Description = "64-bit signed integer",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Real32",
                Description = "32-bit floating-point",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Real64",
                Description = "64-bit floating-point",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavResult",
                Description = "result from a mavlink command",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Accepted",
                Description = "Command ACCEPTED and EXECUTED",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "TemporarilyRejected",
                Description = "Command TEMPORARY REJECTED/DENIED",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Denied",
                Description = "Command PERMANENTLY DENIED",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Unsupported",
                Description = "Command UNKNOWN/UNSUPPORTED",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Failed",
                Description = "Command executed, but failed",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavMissionResult",
                Description = "result in a mavlink mission ack",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MavMissionAccepted",
                Description = "mission accepted OK",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MavMissionError",
                Description = "generic error / not accepting mission commands at all right now",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MavMissionUnsupportedFrame",
                Description = "coordinate frame is not supported",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MavMissionUnsupported",
                Description = "command is not supported",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MavMissionNoSpace",
                Description = "mission item exceeds storage space",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "MavMissionInvalid",
                Description = "one of the parameters has an invalid value",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "MavMissionInvalidParam1",
                Description = "param1 has an invalid value",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "MavMissionInvalidParam2",
                Description = "param2 has an invalid value",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "MavMissionInvalidParam3",
                Description = "param3 has an invalid value",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "MavMissionInvalidParam4",
                Description = "param4 has an invalid value",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "MavMissionInvalidParam5X",
                Description = "x/param5 has an invalid value",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "MavMissionInvalidParam6Y",
                Description = "y/param6 has an invalid value",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "MavMissionInvalidParam7",
                Description = "param7 has an invalid value",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "MavMissionInvalidSequence",
                Description = "received waypoint out of sequence",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "MavMissionDenied",
                Description = "not accepting any mission commands from this communication partner",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavSeverity",
                Description = "Indicates the severity level, generally used for status messages to indicate their relative urgency. Based on RFC-5424 using expanded definitions at: http://www.kiwisyslog.com/kb/info:-syslog-message-levels/.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Emergency",
                Description = "System is unusable. This is a 'panic' condition.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Alert",
                Description = "Action should be taken immediately. Indicates error in non-critical systems.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Critical",
                Description = "Action must be taken immediately. Indicates failure in a primary system.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Error",
                Description = "Indicates an error in secondary/redundant systems.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Warning",
                Description = "Indicates about a possible future error if this is not resolved within a given timeframe. Example would be a low battery warning.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Notice",
                Description = "An unusual event has occured, though not an error condition. This should be investigated for the root cause.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Info",
                Description = "Normal operational messages. Useful for logging. No action is required for these messages.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Debug",
                Description = "Useful non-operational messages that can assist in debugging. These should not occur during normal operation.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavPowerStatus",
                Description = "Power supply status flags (bitmask)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "BrickValid",
                Description = "main brick power supply valid",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ServoValid",
                Description = "main servo power supply valid for FMU",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "UsbConnected",
                Description = "USB power is connected",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "PeriphOvercurrent",
                Description = "peripheral supply is in over-current state",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "PeriphHipowerOvercurrent",
                Description = "hi-power peripheral supply is in over-current state",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Changed",
                Description = "Power status has changed since boot",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "SerialControlDev",
                Description = "SERIAL_CONTROL device types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Telem1",
                Description = "First telemetry port",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Telem2",
                Description = "Second telemetry port",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Gps1",
                Description = "First GPS port",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Gps2",
                Description = "Second GPS port",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Shell",
                Description = "system shell",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "SerialControlFlag",
                Description = "SERIAL_CONTROL flags (bitmask)",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Reply",
                Description = "Set if this is a reply",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Respond",
                Description = "Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Exclusive",
                Description = "Set if access to the serial port should be removed from whatever driver is currently using it, giving exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without this flag set",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Blocking",
                Description = "Block on writes to the serial port",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Multi",
                Description = "Send multiple replies until port is drained",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavDistanceSensor",
                Description = "Enumeration of distance sensor types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Laser",
                Description = "Laser rangefinder, e.g. LightWare SF02/F or PulsedLight units",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Ultrasound",
                Description = "Ultrasound rangefinder, e.g. MaxBotix units",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Infrared",
                Description = "Infrared rangefinder, e.g. Sharp units",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavSensorOrientation",
                Description = "Enumeration of sensor orientation, according to its rotations",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MavSensorRotationNone",
                Description = "Roll: 0, Pitch: 0, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MavSensorRotationYaw45",
                Description = "Roll: 0, Pitch: 0, Yaw: 45",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MavSensorRotationYaw90",
                Description = "Roll: 0, Pitch: 0, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MavSensorRotationYaw135",
                Description = "Roll: 0, Pitch: 0, Yaw: 135",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MavSensorRotationYaw180",
                Description = "Roll: 0, Pitch: 0, Yaw: 180",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "MavSensorRotationYaw225",
                Description = "Roll: 0, Pitch: 0, Yaw: 225",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "MavSensorRotationYaw270",
                Description = "Roll: 0, Pitch: 0, Yaw: 270",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "MavSensorRotationYaw315",
                Description = "Roll: 0, Pitch: 0, Yaw: 315",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "MavSensorRotationRoll180",
                Description = "Roll: 180, Pitch: 0, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "MavSensorRotationRoll180Yaw45",
                Description = "Roll: 180, Pitch: 0, Yaw: 45",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "MavSensorRotationRoll180Yaw90",
                Description = "Roll: 180, Pitch: 0, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "MavSensorRotationRoll180Yaw135",
                Description = "Roll: 180, Pitch: 0, Yaw: 135",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "MavSensorRotationPitch180",
                Description = "Roll: 0, Pitch: 180, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "MavSensorRotationRoll180Yaw225",
                Description = "Roll: 180, Pitch: 0, Yaw: 225",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "MavSensorRotationRoll180Yaw270",
                Description = "Roll: 180, Pitch: 0, Yaw: 270",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "MavSensorRotationRoll180Yaw315",
                Description = "Roll: 180, Pitch: 0, Yaw: 315",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "MavSensorRotationRoll90",
                Description = "Roll: 90, Pitch: 0, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "MavSensorRotationRoll90Yaw45",
                Description = "Roll: 90, Pitch: 0, Yaw: 45",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "MavSensorRotationRoll90Yaw90",
                Description = "Roll: 90, Pitch: 0, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "MavSensorRotationRoll90Yaw135",
                Description = "Roll: 90, Pitch: 0, Yaw: 135",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 20,
                Name = "MavSensorRotationRoll270",
                Description = "Roll: 270, Pitch: 0, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 21,
                Name = "MavSensorRotationRoll270Yaw45",
                Description = "Roll: 270, Pitch: 0, Yaw: 45",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 22,
                Name = "MavSensorRotationRoll270Yaw90",
                Description = "Roll: 270, Pitch: 0, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 23,
                Name = "MavSensorRotationRoll270Yaw135",
                Description = "Roll: 270, Pitch: 0, Yaw: 135",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 24,
                Name = "MavSensorRotationPitch90",
                Description = "Roll: 0, Pitch: 90, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 25,
                Name = "MavSensorRotationPitch270",
                Description = "Roll: 0, Pitch: 270, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 26,
                Name = "MavSensorRotationPitch180Yaw90",
                Description = "Roll: 0, Pitch: 180, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 27,
                Name = "MavSensorRotationPitch180Yaw270",
                Description = "Roll: 0, Pitch: 180, Yaw: 270",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 28,
                Name = "MavSensorRotationRoll90Pitch90",
                Description = "Roll: 90, Pitch: 90, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 29,
                Name = "MavSensorRotationRoll180Pitch90",
                Description = "Roll: 180, Pitch: 90, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 30,
                Name = "MavSensorRotationRoll270Pitch90",
                Description = "Roll: 270, Pitch: 90, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 31,
                Name = "MavSensorRotationRoll90Pitch180",
                Description = "Roll: 90, Pitch: 180, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "MavSensorRotationRoll270Pitch180",
                Description = "Roll: 270, Pitch: 180, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 33,
                Name = "MavSensorRotationRoll90Pitch270",
                Description = "Roll: 90, Pitch: 270, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 34,
                Name = "MavSensorRotationRoll180Pitch270",
                Description = "Roll: 180, Pitch: 270, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 35,
                Name = "MavSensorRotationRoll270Pitch270",
                Description = "Roll: 270, Pitch: 270, Yaw: 0",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 36,
                Name = "MavSensorRotationRoll90Pitch180Yaw90",
                Description = "Roll: 90, Pitch: 180, Yaw: 90",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 37,
                Name = "MavSensorRotationRoll90Yaw270",
                Description = "Roll: 90, Pitch: 0, Yaw: 270",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 38,
                Name = "MavSensorRotationRoll315Pitch315Yaw315",
                Description = "Roll: 315, Pitch: 315, Yaw: 315",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavProtocolCapability",
                Description = "Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MissionFloat",
                Description = "Autopilot supports MISSION float message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ParamFloat",
                Description = "Autopilot supports the new param float message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MissionInt",
                Description = "Autopilot supports MISSION_INT scaled integer message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "CommandInt",
                Description = "Autopilot supports COMMAND_INT scaled integer message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "ParamUnion",
                Description = "Autopilot supports the new param union message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "Ftp",
                Description = "Autopilot supports the new FILE_TRANSFER_PROTOCOL message type.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "SetAttitudeTarget",
                Description = "Autopilot supports commanding attitude offboard.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "SetPositionTargetLocalNed",
                Description = "Autopilot supports commanding position and velocity targets in local NED frame.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "SetPositionTargetGlobalInt",
                Description = "Autopilot supports commanding position and velocity targets in global scaled integers.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "Terrain",
                Description = "Autopilot supports terrain protocol / data handling.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "SetActuatorTarget",
                Description = "Autopilot supports direct actuator control.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2048,
                Name = "FlightTermination",
                Description = "Autopilot supports the flight termination command.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4096,
                Name = "CompassCalibration",
                Description = "Autopilot supports onboard compass calibration.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavEstimatorType",
                Description = "Enumeration of estimator types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Naive",
                Description = "This is a naive estimator without any real covariance feedback.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Vision",
                Description = "Computer vision based estimate. Might be up to scale.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Vio",
                Description = "Visual-inertial estimate.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Gps",
                Description = "Plain GPS estimate.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "GpsIns",
                Description = "Estimator integrating GPS and inertial sensing.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavBatteryType",
                Description = "Enumeration of battery types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Not specified.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Lipo",
                Description = "Lithium polymer battery",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Life",
                Description = "Lithium-iron-phosphate battery",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Lion",
                Description = "Lithium-ION battery",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Nimh",
                Description = "Nickel metal hydride battery",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavBatteryFunction",
                Description = "Enumeration of battery functions",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Battery function is unknown",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "All",
                Description = "Battery supports all flight systems",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Propulsion",
                Description = "Battery for the propulsion system",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Avionics",
                Description = "Avionics battery",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MavBatteryTypePayload",
                Description = "Payload battery",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavVtolState",
                Description = "Enumeration of VTOL states",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undefined",
                Description = "MAV is not configured as VTOL",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "TransitionToFw",
                Description = "VTOL is in transition from multicopter to fixed-wing",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "TransitionToMc",
                Description = "VTOL is in transition from fixed-wing to multicopter",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Mc",
                Description = "VTOL is in multicopter state",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Fw",
                Description = "VTOL is in fixed-wing state",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavLandedState",
                Description = "Enumeration of landed detector states",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Undefined",
                Description = "MAV landed state is unknown",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "OnGround",
                Description = "MAV is landed (on ground)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "InAir",
                Description = "MAV is in air",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "AdsbAltitudeType",
                Description = "Enumeration of the ADSB altimeter types",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "PressureQnh",
                Description = "Altitude reported from a Baro source using QNH reference",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Geometric",
                Description = "Altitude reported from a GNSS source",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "AdsbEmitterType",
                Description = "ADSB classification for the type of vehicle emitting the transponder signal",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "NoInfo",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Light",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Small",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Large",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "HighVortexLarge",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Heavy",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "HighlyManuv",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Rotocraft",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Unassigned",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Glider",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "LighterAir",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "Parachute",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "UltraLight",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "Unassigned2",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "Uav",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Space",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Unassgined3",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "EmergencySurface",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "ServiceSurface",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "PointObstacle",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "AdsbFlags",
                Description = "These flags indicate status such as data validity of each data source. Set = data valid",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "ValidCoords",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ValidAltitude",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "ValidHeading",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "ValidVelocity",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "ValidCallsign",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "ValidSquawk",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "Simulated",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavDoRepositionFlags",
                Description = "Bitmask of options for the MAV_CMD_DO_REPOSITION",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "ChangeMode",
                Description = "The aircraft should immediately transition into guided. This should not be set for follow me applications",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "EstimatorStatusFlags",
                Description = "Flags in EKF_STATUS message",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "EstimatorAttitude",
                Description = "True if the attitude estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "EstimatorVelocityHoriz",
                Description = "True if the horizontal velocity estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "EstimatorVelocityVert",
                Description = "True if the  vertical velocity estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "EstimatorPosHorizRel",
                Description = "True if the horizontal position (relative) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "EstimatorPosHorizAbs",
                Description = "True if the horizontal position (absolute) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "EstimatorPosVertAbs",
                Description = "True if the vertical position (absolute) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "EstimatorPosVertAgl",
                Description = "True if the vertical position (above ground) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "EstimatorConstPosMode",
                Description = "True if the EKF is in a constant position mode and is not using external measurements (eg GPS or optical flow)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "EstimatorPredPosHorizRel",
                Description = "True if the EKF has sufficient data to enter a mode that will provide a (relative) position estimate",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "EstimatorPredPosHorizAbs",
                Description = "True if the EKF has sufficient data to enter a mode that will provide a (absolute) position estimate",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1024,
                Name = "EstimatorGpsGlitch",
                Description = "True if the EKF has detected a GPS glitch",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "LimitsState",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "LimitsInit",
                Description = "pre-initialization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "LimitsDisabled",
                Description = "disabled",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "LimitsEnabled",
                Description = "checking limits",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "LimitsTriggered",
                Description = "a limit has been breached",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "LimitsRecovering",
                Description = "taking action eg. RTL",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "LimitsRecovered",
                Description = "we're no longer in breach of a limit",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "LimitModule",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "LimitGpslock",
                Description = "pre-initialization",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "LimitGeofence",
                Description = "disabled",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "LimitAltitude",
                Description = "checking limits",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "RallyFlags",
                Description = "Flags in RALLY_POINT message",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "FavorableWind",
                Description = "Flag set when requiring favorable winds for landing.",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "LandImmediately",
                Description = "Flag set when plane is to immediately descend to break altitude and land without GCS intervention. Flag not set when plane is to loiter at Rally point until commanded to land.",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "ParachuteAction",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "ParachuteDisable",
                Description = "Disable parachute release",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "ParachuteEnable",
                Description = "Enable parachute release",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "ParachuteRelease",
                Description = "Release parachute",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MotorTestThrottleType",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MotorTestThrottlePercent",
                Description = "throttle as a percentage from 0 ~ 100",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MotorTestThrottlePwm",
                Description = "throttle as an absolute PWM value (normally in range of 1000~2000)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MotorTestThrottlePilot",
                Description = "throttle pass-through from pilot's transmitter",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GripperActions",
                Description = "Gripper actions.",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "GripperActionRelease",
                Description = "gripper release of cargo",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "GripperActionGrab",
                Description = "gripper grabs onto cargo",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CameraStatusTypes",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "CameraStatusTypeHeartbeat",
                Description = "Camera heartbeat, announce camera component ID at 1hz",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "CameraStatusTypeTrigger",
                Description = "Camera image triggered",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "CameraStatusTypeDisconnect",
                Description = "Camera connection lost",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "CameraStatusTypeError",
                Description = "Camera unknown error",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "CameraStatusTypeLowbatt",
                Description = "Camera battery low. Parameter p1 shows reported voltage",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "CameraStatusTypeLowstore",
                Description = "Camera storage low. Parameter p1 shows reported shots remaining",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "CameraStatusTypeLowstorev",
                Description = "Camera storage low. Parameter p1 shows reported video minutes remaining",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "CameraFeedbackFlags",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "CameraFeedbackPhoto",
                Description = "Shooting photos, not video",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "CameraFeedbackVideo",
                Description = "Shooting video, not stills",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "CameraFeedbackBadexposure",
                Description = "Unable to achieve requested exposure (e.g. shutter speed too low)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "CameraFeedbackClosedloop",
                Description = "Closed loop feedback from camera, we know for sure it has successfully taken a picture",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "CameraFeedbackOpenloop",
                Description = "Open loop camera, an image trigger has been requested but we can't know for sure it has successfully taken a picture",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavModeGimbal",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Uninitialized",
                Description = "Gimbal is powered on but has not started initializing yet",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "CalibratingPitch",
                Description = "Gimbal is currently running calibration on the pitch axis",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "CalibratingRoll",
                Description = "Gimbal is currently running calibration on the roll axis",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "CalibratingYaw",
                Description = "Gimbal is currently running calibration on the yaw axis",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Initialized",
                Description = "Gimbal has finished calibrating and initializing, but is relaxed pending reception of first rate command from copter",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Active",
                Description = "Gimbal is actively stabilizing",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "RateCmdTimeout",
                Description = "Gimbal is relaxed because it missed more than 10 expected rate command messages in a row. Gimbal will move back to active mode when it receives a new rate command",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GimbalAxis",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Yaw",
                Description = "Gimbal yaw axis",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Pitch",
                Description = "Gimbal pitch axis",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Roll",
                Description = "Gimbal roll axis",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GimbalAxisCalibrationStatus",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "InProgress",
                Description = "Axis calibration is in progress",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Succeeded",
                Description = "Axis calibration succeeded",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Failed",
                Description = "Axis calibration failed",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GimbalAxisCalibrationRequired",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Whether or not this axis requires calibration is unknown at this time",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "True",
                Description = "This axis requires calibration",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "False",
                Description = "This axis does not require calibration",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproHeartbeatStatus",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Disconnected",
                Description = "No GoPro connected",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Incompatible",
                Description = "The detected GoPro is not HeroBus compatible",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Connected",
                Description = "A HeroBus compatible GoPro is connected",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Error",
                Description = "An unrecoverable error was encountered with the connected GoPro, it may require a power cycle",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproHeartbeatFlags",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "GoproFlagRecording",
                Description = "GoPro is currently recording",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproRequestStatus",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "GoproRequestSuccess",
                Description = "The write message with ID indicated succeeded",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "GoproRequestFailed",
                Description = "The write message with ID indicated failed",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproCommand",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Power",
                Description = "(Get/Set)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "CaptureMode",
                Description = "(Get/Set)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Shutter",
                Description = "(___/Set)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Battery",
                Description = "(Get/___)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Model",
                Description = "(Get/___)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "VideoSettings",
                Description = "(Get/Set)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "LowLight",
                Description = "(Get/Set)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "PhotoResolution",
                Description = "(Get/Set)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "PhotoBurstRate",
                Description = "(Get/Set)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Protune",
                Description = "(Get/Set)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "ProtuneWhiteBalance",
                Description = "(Get/Set) Hero 3+ Only",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "ProtuneColour",
                Description = "(Get/Set) Hero 3+ Only",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "ProtuneGain",
                Description = "(Get/Set) Hero 3+ Only",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "ProtuneSharpness",
                Description = "(Get/Set) Hero 3+ Only",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "ProtuneExposure",
                Description = "(Get/Set) Hero 3+ Only",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Time",
                Description = "(Get/Set)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Charging",
                Description = "(Get/Set)",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproCaptureMode",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Video",
                Description = "Video mode",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Photo",
                Description = "Photo mode",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Burst",
                Description = "Burst mode, hero 3+ only",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "TimeLapse",
                Description = "Time lapse mode, hero 3+ only",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MultiShot",
                Description = "Multi shot mode, hero 4 only",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Playback",
                Description = "Playback mode, hero 4 only, silver only except when LCD or HDMI is connected to black",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Setup",
                Description = "Playback mode, hero 4 only",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 255,
                Name = "Unknown",
                Description = "Mode not yet known",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproResolution",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "_480p",
                Description = "848 x 480 (480p)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_720p",
                Description = "1280 x 720 (720p)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_960p",
                Description = "1280 x 960 (960p)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_1080p",
                Description = "1920 x 1080 (1080p)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_1440p",
                Description = "1920 x 1440 (1440p)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "_27k179",
                Description = "2704 x 1440 (2.7k-17:9)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "_27k169",
                Description = "2704 x 1524 (2.7k-16:9)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "_27k43",
                Description = "2704 x 2028 (2.7k-4:3)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "_4k169",
                Description = "3840 x 2160 (4k-16:9)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "_4k179",
                Description = "4096 x 2160 (4k-17:9)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "_720pSuperview",
                Description = "1280 x 720 (720p-SuperView)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "_1080pSuperview",
                Description = "1920 x 1080 (1080p-SuperView)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "_27kSuperview",
                Description = "2704 x 1520 (2.7k-SuperView)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "_4kSuperview",
                Description = "3840 x 2160 (4k-SuperView)",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproFrameRate",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "_12",
                Description = "12 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_15",
                Description = "15 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_24",
                Description = "24 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_25",
                Description = "25 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_30",
                Description = "30 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "_48",
                Description = "48 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "_50",
                Description = "50 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "_60",
                Description = "60 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "_80",
                Description = "80 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "_90",
                Description = "90 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "_100",
                Description = "100 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "_120",
                Description = "120 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "_240",
                Description = "240 FPS",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "_125",
                Description = "12.5 FPS",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproFieldOfView",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Wide",
                Description = "0x00: Wide",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Medium",
                Description = "0x01: Medium",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Narrow",
                Description = "0x02: Narrow",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproVideoSettingsFlags",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "GoproVideoSettingsTvMode",
                Description = "0=NTSC, 1=PAL",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproPhotoResolution",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "_5mpMedium",
                Description = "5MP Medium",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_7mpMedium",
                Description = "7MP Medium",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_7mpWide",
                Description = "7MP Wide",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_10mpWide",
                Description = "10MP Wide",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_12mpWide",
                Description = "12MP Wide",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproProtuneWhiteBalance",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Auto",
                Description = "Auto",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_3000k",
                Description = "3000K",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_5500k",
                Description = "5500K",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_6500k",
                Description = "6500K",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Raw",
                Description = "Camera Raw",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproProtuneColour",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Standard",
                Description = "Auto",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Neutral",
                Description = "Neutral",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproProtuneGain",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "_400",
                Description = "ISO 400",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_800",
                Description = "ISO 800 (Only Hero 4)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_1600",
                Description = "ISO 1600",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_3200",
                Description = "ISO 3200 (Only Hero 4)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_6400",
                Description = "ISO 6400",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproProtuneSharpness",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Low",
                Description = "Low Sharpness",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Medium",
                Description = "Medium Sharpness",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "High",
                Description = "High Sharpness",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproProtuneExposure",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Neg50",
                Description = "-5.0 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Neg45",
                Description = "-4.5 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Neg40",
                Description = "-4.0 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Neg35",
                Description = "-3.5 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Neg30",
                Description = "-3.0 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "Neg25",
                Description = "-2.5 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "Neg20",
                Description = "-2.0 EV",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "Neg15",
                Description = "-1.5 EV",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "Neg10",
                Description = "-1.0 EV",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 9,
                Name = "Neg05",
                Description = "-0.5 EV",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 10,
                Name = "Zero",
                Description = "0.0 EV",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 11,
                Name = "Pos05",
                Description = "+0.5 EV",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 12,
                Name = "Pos10",
                Description = "+1.0 EV",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 13,
                Name = "Pos15",
                Description = "+1.5 EV",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 14,
                Name = "Pos20",
                Description = "+2.0 EV",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 15,
                Name = "Pos25",
                Description = "+2.5 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "Pos30",
                Description = "+3.0 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 17,
                Name = "Pos35",
                Description = "+3.5 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 18,
                Name = "Pos40",
                Description = "+4.0 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 19,
                Name = "Pos45",
                Description = "+4.5 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 20,
                Name = "Pos50",
                Description = "+5.0 EV (Hero 3+ Only)",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproCharging",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Disabled",
                Description = "Charging disabled",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Enabled",
                Description = "Charging enabled",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproModel",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Unknown",
                Description = "Unknown gopro model",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Hero3PlusSilver",
                Description = "Hero 3+ Silver (HeroBus not supported by GoPro)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "Hero3PlusBlack",
                Description = "Hero 3+ Black",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "Hero4Silver",
                Description = "Hero 4 Silver",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "Hero4Black",
                Description = "Hero 4 Black",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "GoproBurstRate",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "_3In1Second",
                Description = "3 Shots / 1 Second",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "_5In1Second",
                Description = "5 Shots / 1 Second",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "_10In1Second",
                Description = "10 Shots / 1 Second",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "_10In2Second",
                Description = "10 Shots / 2 Second",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "_10In3Second",
                Description = "10 Shots / 3 Second (Hero 4 Only)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "_30In1Second",
                Description = "30 Shots / 1 Second",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 6,
                Name = "_30In2Second",
                Description = "30 Shots / 2 Second",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 7,
                Name = "_30In3Second",
                Description = "30 Shots / 3 Second",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "_30In6Second",
                Description = "30 Shots / 6 Second",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "LedControlPattern",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "Off",
                Description = "LED patterns off (return control to regular vehicle control)",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "Firmwareupdate",
                Description = "LEDs show pattern during firmware update",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 255,
                Name = "Custom",
                Description = "Custom Pattern using custom bytes fields",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "EkfStatusFlags",
                Description = "Flags in EKF_STATUS message",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "EkfAttitude",
                Description = "set if EKF's attitude estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "EkfVelocityHoriz",
                Description = "set if EKF's horizontal velocity estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "EkfVelocityVert",
                Description = "set if EKF's vertical velocity estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 8,
                Name = "EkfPosHorizRel",
                Description = "set if EKF's horizontal position (relative) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 16,
                Name = "EkfPosHorizAbs",
                Description = "set if EKF's horizontal position (absolute) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 32,
                Name = "EkfPosVertAbs",
                Description = "set if EKF's vertical position (absolute) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 64,
                Name = "EkfPosVertAgl",
                Description = "set if EKF's vertical position (above ground) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 128,
                Name = "EkfConstPosMode",
                Description = "EKF is in constant position mode and does not know it's absolute or relative position",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 256,
                Name = "EkfPredPosHorizRel",
                Description = "set if EKF's predicted horizontal position (relative) estimate is good",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 512,
                Name = "EkfPredPosHorizAbs",
                Description = "set if EKF's predicted horizontal position (absolute) estimate is good",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "PidTuningAxis",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "PidTuningRoll",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "PidTuningPitch",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "PidTuningYaw",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "PidTuningAccz",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "PidTuningSteer",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MagCalStatus",
                Description = "",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MagCalNotStarted",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MagCalWaitingToStart",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2,
                Name = "MagCalRunningStepOne",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 3,
                Name = "MagCalRunningStepTwo",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 4,
                Name = "MagCalSuccess",
                Description = "",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 5,
                Name = "MagCalFailed",
                Description = "",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavRemoteLogDataBlockCommands",
                Description = "Special ACK block numbers control activation of dataflash log streaming",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 2147483645,
                Name = "MavRemoteLogDataBlockStop",
                Description = "UAV to stop sending DataFlash blocks",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 2147483646,
                Name = "MavRemoteLogDataBlockStart",
                Description = "UAV to start sending DataFlash blocks",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
            en = new UasEnumMetadata() {
                Name = "MavRemoteLogDataBlockStatuses",
                Description = "Possible remote log data block statuses",
            };

            ent = new UasEnumEntryMetadata() {
                Value = 0,
                Name = "MavRemoteLogDataBlockNack",
                Description = "This block has NOT been received",
            };
            en.Entries.Add(ent);

            ent = new UasEnumEntryMetadata() {
                Value = 1,
                Name = "MavRemoteLogDataBlockAck",
                Description = "This block has been received",
            };
            en.Entries.Add(ent);

            mEnums.Add(en.Name, en);
        }
    }

}
